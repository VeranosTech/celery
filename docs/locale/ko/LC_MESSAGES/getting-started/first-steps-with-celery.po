# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2009-2018, Ask Solem & contributors
# This file is distributed under the same license as the Celery package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Celery 4.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-22 13:45+0900\n"
"PO-Revision-Date: 2019-05-24 14:51+0900\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: ko\n"
"X-Generator: Poedit 2.2.3\n"

#: ../getting-started/first-steps-with-celery.rst:6
msgid "First Steps with Celery"
msgstr "셀러리와의 첫 걸음"

#: ../getting-started/first-steps-with-celery.rst:8
msgid ""
"Celery is a task queue with batteries included. It's easy to use so that you "
"can get started without learning the full complexities of the problem it "
"solves. It's designed around best practices so that your product can scale and "
"integrate with other languages, and it comes with the tools and support you "
"need to run such a system in production."
msgstr ""
"셀러리는 배터리(batteries)가 포함된 태스크 큐(task queue)이다. 셀러리는 우리가 "
"앞으로 해결해야하는 문제의 모든 복잡성을 완전히 알지 못한 상태에서도 쉽게 시작"
"할 수 있도록 사용하기 쉽다. 셀러리는 제품(production)이 다른 언어와 통합되고 확"
"장될 수 있도록 가장 좋은 실습(practice)을 위주로 설계되었으며, 제품 단계에서 이"
"러한 시스템을 실행하는데 필요한 도구와 지원을 함께 제공한다."

#: ../getting-started/first-steps-with-celery.rst:15
msgid "In this tutorial you'll learn the absolute basics of using Celery."
msgstr "이 튜토리얼에서는 셀러리 사용의 가장 기본을 배울 것이다."

#: ../getting-started/first-steps-with-celery.rst:17
msgid "Learn about;"
msgstr "다음에 대해 배워본다;"

#: ../getting-started/first-steps-with-celery.rst:19
msgid "Choosing and installing a message transport (broker)."
msgstr "메세지 전송 수단(브로커)의 선택 및 설치."

#: ../getting-started/first-steps-with-celery.rst:20
msgid "Installing Celery and creating your first task."
msgstr "셀러리 설치와 첫 번째 태스크 만들기."

#: ../getting-started/first-steps-with-celery.rst:21
msgid "Starting the worker and calling tasks."
msgstr "워커(worker)를 시작하고 태스크 호출하기."

#: ../getting-started/first-steps-with-celery.rst:22
msgid ""
"Keeping track of tasks as they transition through different states, and "
"inspecting return values."
msgstr "태스크가 다른 상태(state)로 변할 때 이를 추적하고, 반환 값 검사하기."

#: ../getting-started/first-steps-with-celery.rst:25
msgid ""
"Celery may seem daunting at first - but don't worry - this tutorial will get "
"you started in no time. It's deliberately kept simple, so as to not confuse you "
"with advanced features. After you have finished this tutorial, it's a good idea "
"to browse the rest of the documentation. For example the :ref:`next-steps` "
"tutorial will showcase Celery's capabilities."
msgstr ""
"셀러리가 처음에는 위압적으로 보일 수도 있지만 - 걱정하지 마라 - 이 튜토리얼은 바"
"로 셀러리를 시작해 보도록 할 것이다. 일부러 단순하게 전달하여, 고급 기능들과 혼"
"동하지 않도록 할 것이다. 이 튜토리얼을 마치고 나서, 문서의 나머지 부분을 살펴보"
"는 것이 좋다. 예를 들어 :ref:`next-steps` 튜토리얼은 셀러리의 가능성을 보여줄 것"
"이다."

#: ../getting-started/first-steps-with-celery.rst:39
msgid "Choosing a Broker"
msgstr "브로커 선택하기"

#: ../getting-started/first-steps-with-celery.rst:41
msgid ""
"Celery requires a solution to send and receive messages; usually this comes in "
"the form of a separate service called a *message broker*."
msgstr ""
"셀러리는 메세지를 전달하고 받을 수 있는 방법이 필요하다; 이것은 일반적으로 *메세"
"지 브로커(message broker)*\\라고 불리는 별도의 서비스 형태로 나와있다."

#: ../getting-started/first-steps-with-celery.rst:44
msgid "There are several choices available, including:"
msgstr "사용할 수 있는 몇가지 옵션은 다음과 같다:"

#: ../getting-started/first-steps-with-celery.rst:47
msgid "RabbitMQ"
msgstr "RabbitMQ"

#: ../getting-started/first-steps-with-celery.rst:49
msgid ""
"`RabbitMQ`_ is feature-complete, stable, durable and easy to install. It's an "
"excellent choice for a production environment. Detailed information about using "
"RabbitMQ with Celery:"
msgstr ""
"`RabbitMQ`_\\는 기능이 완전하고, 안정적이며, 내구성이 있고 설치하기 쉽다. 제품 "
"환경을 위해 아주 좋은 선택지이다. 셀러리와 함께 RabbitMQ 사용하는 것에 대한 자세"
"한 정보는:"

#: ../getting-started/first-steps-with-celery.rst:53
msgid ":ref:`broker-rabbitmq`"
msgstr ":ref:`broker-rabbitmq`"

#: ../getting-started/first-steps-with-celery.rst:57
msgid ""
"If you're using Ubuntu or Debian install RabbitMQ by executing this command:"
msgstr ""
"우분투(Ubuntu)또는 데비안(Debian)을 사용할 경우 다음의 명령을 실행하여 RabbitMQ"
"를 설치한다:"

#: ../getting-started/first-steps-with-celery.rst:64
msgid "Or, if you want to run it on Docker execute this:"
msgstr "또는, 도커(Docker)에서 실행하기 원하면 다음과 같다:"

#: ../getting-started/first-steps-with-celery.rst:70
msgid ""
"When the command completes, the broker will already be running in the "
"background, ready to move messages for you: ``Starting rabbitmq-server: "
"SUCCESS``."
msgstr ""
"명령이 완료되면, 브로커는 이미 백그라운드에서 동작하고 있을 것이며, 메세지를 옮"
"길 준비가 되어 있다: ``Starting rabbitmq-server: SUCCESS``."

#: ../getting-started/first-steps-with-celery.rst:73
msgid ""
"Don't worry if you're not running Ubuntu or Debian, you can go to this website "
"to find similarly simple installation instructions for other platforms, "
"including Microsoft Windows:"
msgstr ""
"만약 우분투 또는 데비안에서 실행하지 않더라도 걱정하지마라, 여기 웹사이트로 이동"
"하여 마이크로소프트 윈도우즈를 포함한 다른 플랫폼에서 설치할 수 있는 비슷하면서 "
"간단한 명령어를 찾아라:"

#: ../getting-started/first-steps-with-celery.rst:77
msgid "http://www.rabbitmq.com/download.html"
msgstr "http://www.rabbitmq.com/download.html"

#: ../getting-started/first-steps-with-celery.rst:80
msgid "Redis"
msgstr "Redis"

#: ../getting-started/first-steps-with-celery.rst:82
msgid ""
"`Redis`_ is also feature-complete, but is more susceptible to data loss in the "
"event of abrupt termination or power failures. Detailed information about using "
"Redis:"
msgstr ""
"`Redis`_ 또한 기능이 완전하지만, 갑작스러운 전력 장애(power failures)나 갑작스러"
"운 종료 상황이 발생할 경우 데이터 손실에 더 취약하다. Redis에 대한 자세한 정보"
"는:"

#: ../getting-started/first-steps-with-celery.rst:85
msgid ":ref:`broker-redis`"
msgstr ":ref:`broker-redis`"

#: ../getting-started/first-steps-with-celery.rst:89
msgid "If you want to run it on Docker execute this:"
msgstr "도커에서 실행하려면 다음 명령을 실행하라:"

#: ../getting-started/first-steps-with-celery.rst:96
msgid "Other brokers"
msgstr "다른 브로커들"

#: ../getting-started/first-steps-with-celery.rst:98
msgid ""
"In addition to the above, there are other experimental transport "
"implementations to choose from, including :ref:`Amazon SQS <broker-sqs>`."
msgstr ""
"위의 브로커들 이외에도, 선택할 수 있는 다른 실험적인 전송 구현 방법들이 있으"
"며, :ref:`Amazon SQS <broker-sqs>`\\를 포함한다."

#: ../getting-started/first-steps-with-celery.rst:101
msgid "See :ref:`broker-overview` for a full list."
msgstr "전체 목록은 :ref:`broker-overview`\\를 보라."

#: ../getting-started/first-steps-with-celery.rst:106
msgid "Installing Celery"
msgstr "셀러리 설치"

#: ../getting-started/first-steps-with-celery.rst:108
msgid ""
"Celery is on the Python Package Index (PyPI), so it can be installed with "
"standard Python tools like ``pip`` or ``easy_install``:"
msgstr ""
"셀러리는 파이썬 패키지 인덱스(PyPI)에 있으며, 따라서 표준 파이썬 도구인 ``pip`` "
"또는 ``easy_install``\\을 사용하여 설치할 수 있다:"

#: ../getting-started/first-steps-with-celery.rst:116
msgid "Application"
msgstr "어플리케이션"

#: ../getting-started/first-steps-with-celery.rst:118
msgid ""
"The first thing you need is a Celery instance.  We call this the *Celery "
"application* or just *app* for short. As this instance is used as the entry-"
"point for everything you want to do in Celery, like creating tasks and managing "
"workers, it must be possible for other modules to import it."
msgstr ""
"첫 번째로 필요한 것은 셀러리 인스턴스이다. 이것을 *셀러리 어플리케이션* 또는 그"
"냥 짧게 줄여 *앱(app)*\\이라고 부른다. 이 인스턴스는 태스크를 생성하거나 워커를 "
"관리하는 것처럼 셀러리에서 하려는 모든 작업의 진입점(entry-point)로 사용되며, 반"
"드시 다른 모듈에서 이 인스턴스를 가져오기(import)할 수 있어야 한다."

#: ../getting-started/first-steps-with-celery.rst:123
msgid ""
"In this tutorial we keep everything contained in a single module, but for "
"larger projects you want to create a :ref:`dedicated module <project-layout>`."
msgstr ""
"이 튜토리얼에서는 단일 모듈에 포함된 모든 것을 다루지만, 더 큰 프로젝트를 위해서"
"는 :ref:`dedicated module <project-layout>`\\을 생성하고자 한다."

#: ../getting-started/first-steps-with-celery.rst:127
msgid "Let's create the file :file:`tasks.py`:"
msgstr "이제 :file:`tasks.py` 파일을 생성해보자:"

#: ../getting-started/first-steps-with-celery.rst:139
msgid ""
"The first argument to :class:`~celery.app.Celery` is the name of the current "
"module. This is only needed so that names can be automatically generated when "
"the tasks are defined in the `__main__` module."
msgstr ""
":class:`~celery.app.Celery`\\의 첫번째 인수(argument)는 현재 모듈의 이름이다. 이"
"것만 있으면, 태스크가 `__main__` 모듈 내에 정의되었을 때 이름이 자동적으로 생성"
"되도록 한다."

#: ../getting-started/first-steps-with-celery.rst:143
msgid ""
"The second argument is the broker keyword argument, specifying the URL of the "
"message broker you want to use. Here using RabbitMQ (also the default option)."
msgstr ""
"두 번째 인수는 브로커 키워드 인수인데, 사용하고자 하는 메세지 브로커의 URL을 지"
"정한다. 여기서는 RabbitMQ(그리고 기본 옵션)를 사용한다."

#: ../getting-started/first-steps-with-celery.rst:146
msgid ""
"See :ref:`celerytut-broker` above for more choices -- for RabbitMQ you can use "
"``amqp://localhost``, or for Redis you can use ``redis://localhost``."
msgstr ""
"자세한 내용은 위의 :ref:`celerytut-broker`\\를 참조하라 — RabbitMQ의 경우 "
"``amqp://localhost``\\를 사용하거나, Redis를 위해서는 ``redis://localhost``\\를 "
"사용할 수 있다."

#: ../getting-started/first-steps-with-celery.rst:150
msgid ""
"You defined a single task, called ``add``, returning the sum of two numbers."
msgstr "두 숫자의 합을 반환하는, ``add``\\라는 이름의 단일 태스크를 정의하였다."

#: ../getting-started/first-steps-with-celery.rst:155
msgid "Running the Celery worker server"
msgstr "셀러리 워커(Celery worker) 서버 실행"

#: ../getting-started/first-steps-with-celery.rst:157
msgid ""
"You can now run the worker by executing our program with the ``worker`` "
"argument:"
msgstr ""
"이제 ``worker`` 인수를 사용하여 프로그램을 실행함으로써 워커를 동작시킬 수 있다:"

#: ../getting-started/first-steps-with-celery.rst:166
msgid ""
"See the :ref:`celerytut-troubleshooting` section if the worker doesn't start."
msgstr ""
"만약 워커가 시작하지 않는다면, :ref:`celerytut-troubleshooting` 섹션을 보라."

#: ../getting-started/first-steps-with-celery.rst:169
msgid ""
"In production you'll want to run the worker in the background as a daemon. To "
"do this you need to use the tools provided by your platform, or something like "
"`supervisord`_ (see :ref:`daemonizing` for more information)."
msgstr ""
"제품(production)에서 데몬(daemon)으로 백그라운드에서 워커를 실행시키기를 원할 것"
"이다. 이를 위해서는 플랫폼에서 제공하는 도구나, `supervisord`_ 등을 사용해야 한"
"다(보다 자세한 내용을 위해서 :ref:`daemonizing`\\를 보라)."

#: ../getting-started/first-steps-with-celery.rst:174
msgid "For a complete listing of the command-line options available, do:"
msgstr ""
"사용 가능한 커맨드 라인(command-line) 옵션의 전체 목록을 보려면, 다음과 같이 하"
"라:"

#: ../getting-started/first-steps-with-celery.rst:180
msgid ""
"There are also several other commands available, and help is also available:"
msgstr ""
"또한 몇 가지의 사용 가능한 다른 명령어들이 있으며, 도움말(help) 또한 사용 가능하"
"다:"

#: ../getting-started/first-steps-with-celery.rst:191
msgid "Calling the task"
msgstr "태스크(task) 호출"

#: ../getting-started/first-steps-with-celery.rst:193
msgid "To call our task you can use the :meth:`~@Task.delay` method."
msgstr "태스크를 호출하기 위해서 :meth:`~@Task.delay` 방법을 사용할 수 있다."

#: ../getting-started/first-steps-with-celery.rst:195
msgid ""
"This is a handy shortcut to the :meth:`~@Task.apply_async` method that gives "
"greater control of the task execution (see :ref:`guide-calling`)::"
msgstr ""
"이것은 :meth:`~@Task.apply_async`\\을 손쉽게 사용하는 방법으로 태스크 실행에 대"
"한 효과적인 제어를 할 수 있게 한다 (:ref:`guide-calling`\\를 보라)::"

#: ../getting-started/first-steps-with-celery.rst:202
msgid ""
"The task has now been processed by the worker you started earlier. You can "
"verify this by looking at the worker's console output."
msgstr ""
"태스크는 아까 시작시켰던 워커에 의해 처리되었다. 워커의 콘솔 결과(console "
"output)을 보고 확인할 수 있다."

#: ../getting-started/first-steps-with-celery.rst:205
msgid ""
"Calling a task returns an :class:`~@AsyncResult` instance. This can be used to "
"check the state of the task, wait for the task to finish, or get its return "
"value (or if the task failed, to get the exception and traceback)."
msgstr ""
"태스크 호출은 class:`~@AsyncResult` 인스턴스를 반환한다. 이것은 태스크의 상태를 "
"체크하고, 태스크가 끝날 때까지 기다리고, 반환 값을 받는 데 사용할 수 있다(또는 "
"태스크가 실패(failed)되었을 때, 예외와 traceback을 받는 데 사용할 수 있다)."

#: ../getting-started/first-steps-with-celery.rst:209
msgid ""
"Results are not enabled by default. In order to do remote procedure calls or "
"keep track of task results in a database, you will need to configure Celery to "
"use a result backend.  This is described in the next section."
msgstr ""
"결과(Result)는 기본적으로 실행되지 않는다. 원격 프로시져(remote procedure) 호출"
"을 하거나 데이터베이스에서 태스크 결과를 추적하기 위하여, 셀러리가 결과 백엔드"
"(result backend)를 사용하도록 설정하는 것이 필요하다.  이것은 다음 섹션에서 설명"
"한다."

#: ../getting-started/first-steps-with-celery.rst:216
msgid "Keeping Results"
msgstr "결과 보관"

#: ../getting-started/first-steps-with-celery.rst:218
msgid ""
"If you want to keep track of the tasks' states, Celery needs to store or send "
"the states somewhere. There are several built-in result backends to choose "
"from: `SQLAlchemy`_/`Django`_ ORM, `Memcached`_, `Redis`_, :ref:`RPC <conf-rpc-"
"result-backend>` (`RabbitMQ`_/AMQP), and -- or you can define your own."
msgstr ""
"만약 계속해서 태스크의 상태를 추적하고 싶다면, 셀러리는 상태를 어딘가로 보내거"
"나 저장해야 한다. 내장되어 있는 결과 백엔드가 몇가지 있는데: `SQLAlchemy`_/"
"`Django`_ ORM, `Memcached`_, `Redis`_, :ref:`RPC <conf-rpc-result-backend>` "
"(`RabbitMQ`_/AMQP)에서 선택할 수 있고, 또는 자체적으로 정의해서 사용할 수 있다."

#: ../getting-started/first-steps-with-celery.rst:229
msgid ""
"For this example we use the `rpc` result backend, that sends states back as "
"transient messages. The backend is specified via the ``backend`` argument to :"
"class:`@Celery`, (or via the :setting:`result_backend` setting if you choose to "
"use a configuration module):"
msgstr ""
"예시에서는 상태를 일시적 메세지(transient message)로 전송하는 `rpc` 결과 백엔드"
"를 사용한다. 백엔드는 ``backend`` 인수를 통해서(또는 설정 모듈을 선택했을 경우 :"
"setting:`result_backend` 설정을 통해서) :class:`@Celery`\\로 지정된다:"

#: ../getting-started/first-steps-with-celery.rst:238
msgid ""
"Or if you want to use Redis as the result backend, but still use RabbitMQ as "
"the message broker (a popular combination):"
msgstr ""
"혹은 결과 백엔드로 Redis를 사용하지만, 메세지 브로커로는 계속해서 RabbitMQ를 사"
"용한다면(일반적인 조합이다):"

#: ../getting-started/first-steps-with-celery.rst:245
msgid "To read more about result backends please see :ref:`task-result-backends`."
msgstr ""
"결과 백엔드에 대한 더 자세한 내용은 :ref:`task-result-backends`\\를 읽어보아라."

#: ../getting-started/first-steps-with-celery.rst:247
msgid ""
"Now with the result backend configured, let's call the task again. This time "
"you'll hold on to the :class:`~@AsyncResult` instance returned when you call a "
"task:"
msgstr ""
"결과 백엔드 설정과 함께, 이제 다시 태스크를 호출해보자. 이번에는 태스크를 호출"
"할 때 :class:`~@AsyncResult` 인스턴스가 반환될 것이다:"

#: ../getting-started/first-steps-with-celery.rst:255
msgid ""
"The :meth:`~@AsyncResult.ready` method returns whether the task has finished "
"processing or not:"
msgstr ""
":meth:`~@AsyncResult.ready` 방법은 태스크가 작업(processing)을 마쳤는지 여부를 "
"반환한다:"

#: ../getting-started/first-steps-with-celery.rst:263
msgid ""
"You can wait for the result to complete, but this is rarely used since it turns "
"the asynchronous call into a synchronous one:"
msgstr ""
"결과가 완료되기까지 기다릴 수 있지만, 비동기적 호출을 동기적으로 변환하기 때문"
"에 거의 사용되지 않는다:"

#: ../getting-started/first-steps-with-celery.rst:271
msgid ""
"In case the task raised an exception, :meth:`~@AsyncResult.get` will re-raise "
"the exception, but you can override this by specifying the ``propagate`` "
"argument:"
msgstr ""
"태스크가 예외(exception)을 발생시킨 경우에는, :meth:`~@AsyncResult.get`\\가 다"
"시 예외를 발생시게 되는데, ``propagate`` 인수를 명시하여 이를 무시할 수 있다:"

#: ../getting-started/first-steps-with-celery.rst:280
msgid ""
"If the task raised an exception, you can also gain access to the original "
"traceback:"
msgstr ""
"태스크가 예외를 발생시키면, 원본 traceback에 대한 접근 권한도 얻을 수 있다:"

#: ../getting-started/first-steps-with-celery.rst:289
msgid ""
"Backends use resources to store and transmit results. To ensure that resources "
"are released, you must eventually call :meth:`~@AsyncResult.get` or :meth:"
"`~@AsyncResult.forget` on EVERY :class:`~@AsyncResult` instance returned after "
"calling a task."
msgstr ""
"백엔드가 결과를 저장하고 전달하는데 리소스가 사용된다. 사용된 리소스가 확실히 릴"
"리즈되도록 하기 위해, 결국에는 태스크 호출 후 :class:`~@AsyncResult` 인스턴스가 "
"반환될 때 마다 :meth:`~@AsyncResult.get` 또는 :meth:`~@AsyncResult.forget`\\를 "
"호출해야만 한다."

#: ../getting-started/first-steps-with-celery.rst:295
msgid "See :mod:`celery.result` for the complete result object reference."
msgstr "전체 결과 객체 참조를 위하여 :mod:`celery.result`\\를 보라."

#: ../getting-started/first-steps-with-celery.rst:300
msgid "Configuration"
msgstr "구성 설정(Configuration)"

#: ../getting-started/first-steps-with-celery.rst:302
msgid ""
"Celery, like a consumer appliance, doesn't need much configuration to operate. "
"It has an input and an output. The input must be connected to a broker, and the "
"output can be optionally connected to a result backend. However, if you look "
"closely at the back, there's a lid revealing loads of sliders, dials, and "
"buttons: this is the configuration."
msgstr ""
"가전 제품과 마찬가지로, 셀러리는 실행하는데 많은 구성 설정들이 필요하지 않다. 단"
"지 입력(input)과 출력(output)을 가진다. 입력은 브로커와 반드시 연결되어 있어야 "
"하고, 출력은 선택적으로 결과 백엔드와 연결할 수 있다. 하지만, 가전 제품도 뒤쪽"
"을 자세하게 보면, 슬라이더, 다이얼, 그리고 버튼들을 가리고 있는 뚜껑이 있는데: "
"이것이 셀러리에서는 구성 설정(configuration)이다."

#: ../getting-started/first-steps-with-celery.rst:307
msgid ""
"The default configuration should be good enough for most use cases, but there "
"are many options that can be configured to make Celery work exactly as needed. "
"Reading about the options available is a good idea to familiarize yourself with "
"what can be configured. You can read about the options in the :ref:"
"`configuration` reference."
msgstr ""
"기본 구성 설정은 대부분의 유즈케이스에 충분하지만, 셀러리가 정확히 필요한 대로 "
"작동하도록 만들기 위해서 많은 설정 옵션들이 있다. 사용 가능한 옵션에 대하여 읽어"
"보는 것은 셀러리를 구성하는데 친숙해지기 위한 좋은 방법이다. :ref:"
"`configuration` 참조에서 옵션들에 대해 읽어볼 수 있다."

#: ../getting-started/first-steps-with-celery.rst:313
msgid ""
"The configuration can be set on the app directly or by using a dedicated "
"configuration module. As an example you can configure the default serializer "
"used for serializing task payloads by changing the :setting:`task_serializer` "
"setting:"
msgstr ""
"구성은 앱(app)에서 직접적으로 설정할 수 있고, 설정 모듈을 사용하여 할 수도 있"
"다. 예를 들어 :setting:`task_serializer` 설정을 변경하여 태스크 페이로드"
"(payloads)를 일련화하기 위해 기본 serializer를 구성할 수 있다:"

#: ../getting-started/first-steps-with-celery.rst:322
msgid "If you're configuring many settings at once you can use ``update``:"
msgstr "``update``\\를 사용하여 한 번에 많은 설정을 구성할 수도 있다:"

#: ../getting-started/first-steps-with-celery.rst:334
msgid ""
"For larger projects, a dedicated configuration module is recommended. Hard "
"coding periodic task intervals and task routing options is discouraged. It is "
"much better to keep these in a centralized location. This is especially true "
"for libraries, as it enables users to control how their tasks behave. A "
"centralized configuration will also allow your SysAdmin to make simple changes "
"in the event of system trouble."
msgstr ""
"보다 큰 프로젝트를 위해서, 전용 구성 모듈을 추천한다. 하드 코딩(hard coding)된 "
"주기적인 태스크 간격과 태스크 라우팅 옵션은 허용되지 않는다. 중앙화된 위치에서 "
"이것들을 보관하는 것이 훨씬 좋다. 특히 라이브러리의 경우에 더욱 좋은데, 사용자들"
"이 태스크가 어떻게 동작하는지 제어할 수 있도록 하기 때문이다. 중앙화된 구성 설정"
"(centrailized configuration)은 시스템 문제가 발생했을 때 SysAdmin을 간단히 변경"
"하는 것을 허용한다."

#: ../getting-started/first-steps-with-celery.rst:341
msgid ""
"You can tell your Celery instance to use a configuration module by calling the :"
"meth:`@config_from_object` method:"
msgstr ""
":meth:`@config_from_object` 방법을 호출하여 셀러리 인스턴스가 구성 모듈을 사용하"
"도록 만들 수 있다:"

#: ../getting-started/first-steps-with-celery.rst:348
msgid ""
"This module is often called \"``celeryconfig``\", but you can use any module "
"name."
msgstr ""
"이 모듈은 보통 “``celeryconfig``\\”라고 불리는데, 아무 이름을 사용해도 상관없다."

#: ../getting-started/first-steps-with-celery.rst:351
msgid ""
"In the above case, a module named ``celeryconfig.py`` must be available to load "
"from the current directory or on the Python path. It could look something like "
"this:"
msgstr ""
"위의 경우에서, ``celeryconfig.py`` 이름의 모듈은 현재 디렉토리 또는 파이썬 경로"
"로부터 로드할 수 있어야 한다. 이런식으로 보일 수도 있다:"

#: ../getting-started/first-steps-with-celery.rst:354
#: ../getting-started/first-steps-with-celery.rst:379
#: ../getting-started/first-steps-with-celery.rst:391
msgid ":file:`celeryconfig.py`:"
msgstr ":file:`celeryconfig.py`\\:"

#: ../getting-started/first-steps-with-celery.rst:367
msgid ""
"To verify that your configuration file works properly and doesn't contain any "
"syntax errors, you can try to import it:"
msgstr ""
"구성 파일이 제대로 작동하고 문구 오류(syntax errors)가 포함되어 있는지 확인하기 "
"위하여, 이것을 가져오도록(import) 시도할 수 있다:"

#: ../getting-started/first-steps-with-celery.rst:374
msgid ""
"For a complete reference of configuration options, see :ref:`configuration`."
msgstr "구성 설정 옵션에 대한 전체적인 내용은 :ref:`configuration`\\을 보라."

#: ../getting-started/first-steps-with-celery.rst:376
msgid ""
"To demonstrate the power of configuration files, this is how you'd route a "
"misbehaving task to a dedicated queue:"
msgstr ""
"구성 파일의 성능을 보여주기 위해(demonstrate), 잘못된 태스크를 전용 대기열"
"(dedicated queue)에 라우팅한다:"

#: ../getting-started/first-steps-with-celery.rst:387
msgid ""
"Or instead of routing it you could rate limit the task instead, so that only 10 "
"tasks of this type can be processed in a minute (10/m):"
msgstr ""
"또는 라우팅하는 대신에 태스크 인스턴스의 한도(limit)을 조정하여, 이 타입의 10개"
"의 태스크만1분에 실행될 수 있도록 한다 (10/m):"

#: ../getting-started/first-steps-with-celery.rst:399
msgid ""
"If you're using RabbitMQ or Redis as the broker then you can also direct the "
"workers to set a new rate limit for the task at runtime:"
msgstr ""
"브로커로 RabbitMQ 또는 Redis를 사용할 경우 워커에게 런타임의 태스크에 대한 새로"
"운 제한(rate limit)을 설정하도록 지시할 수 있다:"

#: ../getting-started/first-steps-with-celery.rst:409
msgid ""
"See :ref:`guide-routing` to read more about task routing, and the :setting:"
"`task_annotations` setting for more about annotations, or :ref:`guide-"
"monitoring` for more about remote control commands and how to monitor what your "
"workers are doing."
msgstr ""
":ref:`guide-routing`\\에서 태스크 라우팅에 대해 읽어보고, 주석(annocation)에 대"
"한 자세한 내용은 :setting:`task_annotations` 설정을 참조하거나, 원격 제어 명령 "
"및 작업자의 활동을 모니터하는 방법에 대한 내용은 :ref:`guide-monitoring`\\을 참"
"조하라."

#: ../getting-started/first-steps-with-celery.rst:415
msgid "Where to go from here"
msgstr "지금부터 가야할 곳"

#: ../getting-started/first-steps-with-celery.rst:417
msgid ""
"If you want to learn more you should continue to the :ref:`Next Steps <next-"
"steps>` tutorial, and after that you can read the :ref:`User Guide <guide>`."
msgstr ""
"계속해서 더 많은 내용을 배우고 싶다면 :ref:`Next Steps <next-steps>` 튜토리얼을 "
"보고, 그 이후에는 :ref:`User Guide <guide>`\\을 읽어보라."

#: ../getting-started/first-steps-with-celery.rst:424
msgid "Troubleshooting"
msgstr "트러블슈팅(Troubleshooting)"

#: ../getting-started/first-steps-with-celery.rst:426
msgid "There's also a troubleshooting section in the :ref:`faq`."
msgstr ":ref:`faq`\\에 트러블슈팅 섹션도 함께 있다."

#: ../getting-started/first-steps-with-celery.rst:429
msgid "Worker doesn't start: Permission Error"
msgstr "워커가 시작하지 않는다: 권한 에러(Permission Error)"

#: ../getting-started/first-steps-with-celery.rst:431
msgid "If you're using Debian, Ubuntu or other Debian-based distributions:"
msgstr ""
"데비안(Debianm), 우분투(Ubuntu)또는 데비안 기반의 다른 배포판을 사용할 경우:"

#: ../getting-started/first-steps-with-celery.rst:433
msgid ""
"Debian recently renamed the :file:`/dev/shm` special file to :file:`/run/shm`."
msgstr ""
"데비안은 최근 :file:`/dev/shm`\\의 특수 파일 이름을 :file:`/run/shm`\\로 변경하"
"였다."

#: ../getting-started/first-steps-with-celery.rst:436
msgid "A simple workaround is to create a symbolic link:"
msgstr "간단한 해결 방법은 심볼릭 링크(symbolic link)를 생성하는 것이다:"

#: ../getting-started/first-steps-with-celery.rst:442
msgid "Others:"
msgstr "기타:"

#: ../getting-started/first-steps-with-celery.rst:444
msgid ""
"If you provide any of the :option:`--pidfile <celery worker --pidfile>`, :"
"option:`--logfile <celery worker --logfile>` or :option:`--statedb <celery "
"worker --statedb>` arguments, then you must make sure that they point to a file "
"or directory that's writable and readable by the user starting the worker."
msgstr ""
":option:`—pidfile <celery worker —pidfile>`\\, :option:`—logfile <celery worker "
"—logfile>` 또는 :option:`—statedb <celery worker —statedb>` 인수를 사용할 경우에"
"는, 워커를 시작하는 사용자(user)가 읽고 쓸 수 있는 파일 또는 디렉토리를 확실하"
"게 가리키는지 확인하여야 한다."

#: ../getting-started/first-steps-with-celery.rst:451
msgid "Result backend doesn't work or tasks are always in ``PENDING`` state"
msgstr "결과 백엔드가 동작하지 않거나 태스크가 항상 ``PENDING`` 상태이다"

#: ../getting-started/first-steps-with-celery.rst:453
msgid ""
"All tasks are :state:`PENDING` by default, so the state would've been better "
"named \"unknown\". Celery doesn't update the state when a task is sent, and any "
"task with no history is assumed to be pending (you know the task id, after all)."
msgstr ""
"모든 태스크는 기본적으로 :state:`PENDING` 상태로, “unknown”으로 명명되는 것이 "
"더 낫다. 셀러리는 태스크가 전송되었을 때 상태를 업데이트하고, 히스토리가 없는 태"
"스크는 모두 보류(pending) 상태인 것으로 가정한다(어쨌든 태스크 id는 알고있을 것"
"이다)."

#: ../getting-started/first-steps-with-celery.rst:458
msgid "Make sure that the task doesn't have ``ignore_result`` enabled."
msgstr "태스크가 활성화된 ``ignore_result`` 가지지 않도록 해야 한다."

#: ../getting-started/first-steps-with-celery.rst:460
msgid "Enabling this option will force the worker to skip updating states."
msgstr "이 옵션을 활서오하하면 워커는 상태 업데이트를 강제로 생략할 것이다."

#: ../getting-started/first-steps-with-celery.rst:463
msgid "Make sure the :setting:`task_ignore_result` setting isn't enabled."
msgstr ":setting:`task_ignore_result` 설정이 활성화되지 않았는지 확인하라."

#: ../getting-started/first-steps-with-celery.rst:465
msgid "Make sure that you don't have any old workers still running."
msgstr "아직 작업하고 있는 오래된 워커가 있는지 확인하라."

#: ../getting-started/first-steps-with-celery.rst:467
msgid ""
"It's easy to start multiple workers by accident, so make sure that the previous "
"worker is properly shut down before you start a new one."
msgstr ""
"실수로, 여러 워커들이 시작하게 하는 것은 쉽기 때문에, 새로운 워커가 시작하기 전"
"에 이전 워커들이 제대로 종료되도록 해야 한다."

#: ../getting-started/first-steps-with-celery.rst:470
msgid ""
"An old worker that isn't configured with the expected result backend may be "
"running and is hijacking the tasks."
msgstr ""
"예상 결과 백엔드로 설정되지 않은 예전 워커가 혹시 실행중이면서 태스크를 가로채"
"고 있을 수 있다."

#: ../getting-started/first-steps-with-celery.rst:473
msgid ""
"The :option:`--pidfile <celery worker --pidfile>` argument can be set to an "
"absolute path to make sure this doesn't happen."
msgstr ""
":option:`—pidfile <celery worker —pidfile>` 인수는 이러한 일이 발생하지 않도록 "
"절대 경로로 설정될 수 있다."

#: ../getting-started/first-steps-with-celery.rst:476
msgid "Make sure the client is configured with the right backend."
msgstr "클라이언트가 맞는 백엔드로 설정되어 있는지 확인하라."

#: ../getting-started/first-steps-with-celery.rst:478
msgid ""
"If, for some reason, the client is configured to use a different backend than "
"the worker, you won't be able to receive the result. Make sure the backend is "
"configured correctly:"
msgstr ""
"어떠한 이유로, 클라이언트가 워커와 다른 백엔드로 설정되어 있으면, 결과를 전달받"
"지 못할 것이다. 백엔드가 올바르게 설정되었는지 확인하라:"
