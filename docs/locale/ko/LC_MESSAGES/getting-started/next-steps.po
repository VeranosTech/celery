# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2009-2018, Ask Solem & contributors
# This file is distributed under the same license as the Celery package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Celery 4.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-22 13:45+0900\n"
"PO-Revision-Date: 2019-05-24 17:18+0900\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: ko\n"
"X-Generator: Poedit 2.2.3\n"

#: ../getting-started/next-steps.rst:5
msgid "Next Steps"
msgstr "다음 단계"

#: ../getting-started/next-steps.rst:7
msgid ""
"The :ref:`first-steps` guide is intentionally minimal. In this guide I'll "
"demonstrate what Celery offers in more detail, including how to add Celery "
"support for your application and library."
msgstr ""
":ref:`first-steps`\\에서는 일부러 최소한의 것만 설명한다. 여기에서는 셀러리"
"의 어플리케이션과 라이브러리를 위한 지원(support)를 얻을 수 있는 방법을 포함"
"하여 셀러리가 제공하는 것을 좀 더 자세하게 설명하려 한다."

#: ../getting-started/next-steps.rst:11
msgid ""
"This document doesn't document all of Celery's features and best practices, "
"so it's recommended that you also read the :ref:`User Guide <guide>`"
msgstr ""
"이 문서는 셀러리의 모든 기능과 가장 좋은 실습(practice)를 설명하지는 않기 때"
"문에, :ref:`User Guide <guide>`\\도 읽어보기를 추천한다"

#: ../getting-started/next-steps.rst:20
msgid "Using Celery in your Application"
msgstr "어플리케이션에서 셀러리 사용"

#: ../getting-started/next-steps.rst:25
msgid "Our Project"
msgstr "프로젝트"

#: ../getting-started/next-steps.rst:27
msgid "Project layout::"
msgstr "프로젝트 레이아웃::"

#: ../getting-started/next-steps.rst:34
msgid ":file:`proj/celery.py`"
msgstr ":file:`proj/celery.py`"

#: ../getting-started/next-steps.rst:39
msgid ""
"In this module you created our :class:`@Celery` instance (sometimes referred "
"to as the *app*). To use Celery within your project you simply import this "
"instance."
msgstr ""
"이 모듈에서 다음과 같은 :class:`@Celery` 인스턴스(때로는 *앱 app*\\이라고 언"
"급됨)를 생성한다. 프로젝트 내에서 셀러리를 사용하기 위해서 간단하게 이 인스턴"
"스를 가져오기(import) 하면 된다."

#: ../getting-started/next-steps.rst:43
msgid "The ``broker`` argument specifies the URL of the broker to use."
msgstr "``broker`` 인수는 사용하려는 브로커의 URL을 지정한다."

#: ../getting-started/next-steps.rst:45
msgid "See :ref:`celerytut-broker` for more information."
msgstr "보다 자세한 내용은 :ref:`celerytut-broker`\\을 보라."

#: ../getting-started/next-steps.rst:47
msgid "The ``backend`` argument specifies the result backend to use,"
msgstr "``backend`` 인수는 사용하려는 결과 백엔드를 지정한다,"

#: ../getting-started/next-steps.rst:49
msgid ""
"It's used to keep track of task state and results. While results are "
"disabled by default I use the RPC result backend here because I demonstrate "
"how retrieving results work later, you may want to use a different backend "
"for your application. They all have different strengths and weaknesses. If "
"you don't need results it's better to disable them. Results can also be "
"disabled for individual tasks by setting the ``@task(ignore_result=True)`` "
"option."
msgstr ""
"백엔드는 태스크 상태와 결과를 추적하기 위해 사용한다. 기본값으로 결과를 사용"
"할 수 없지만 결과 검색이 나중에 어떻게 작동하는지 보여주기 위해서 RPC 결과 백"
"엔드를 사용하였으며, 원하는 경우에는 어플리케이션에 다른 백엔드를 사용할 수 "
"있다. 모두 각각 서로 다른 장점과 약점을 가지고 있다. 결과가 필요하지 않다면 "
"이를 비활성화시키는 것이 더 낫다. ``@task(ignore_result=True)`` 옵션 설정을 "
"이용해 태스크 별로 결과를 비활성화할 수도 있다."

#: ../getting-started/next-steps.rst:57
msgid "See :ref:`celerytut-keeping-results` for more information."
msgstr "자세한 내용은 :ref:`celerytut-keeping-results` 보라."

#: ../getting-started/next-steps.rst:59
msgid ""
"The ``include`` argument is a list of modules to import when the worker "
"starts. You need to add our tasks module here so that the worker is able to "
"find our tasks."
msgstr ""
"``include`` 인자는 워커가 시작할 때 가져오려는 모듈의 목록이다. 워커가 태스크"
"를 찾을 수 있도록 여기에 태스크 모듈을 추가하여야 한다."

#: ../getting-started/next-steps.rst:64
msgid ":file:`proj/tasks.py`"
msgstr ":file:`proj/tasks.py`"

#: ../getting-started/next-steps.rst:71
msgid "Starting the worker"
msgstr "워커 시작하기"

#: ../getting-started/next-steps.rst:73
msgid ""
"The :program:`celery` program can be used to start the worker (you need to "
"run the worker in the directory above proj):"
msgstr ""
":program:`celery` 프로그램은 워커를 시작하는데 사용할 수 있다( 프로젝트 위의 "
"디렉토리에서 워커를 실행시켜야 함):"

#: ../getting-started/next-steps.rst:79
msgid "When the worker starts you should see a banner and some messages::"
msgstr ""
"워커가 시작할 때 배너(banner)와 다음과 같은 메세지를 볼 수 있어야 한다::"

#: ../getting-started/next-steps.rst:95
msgid ""
"-- The *broker* is the URL you specified in the broker argument in our "
"``celery`` module, you can also specify a different broker on the command-"
"line by using the :option:`-b <celery -b>` option."
msgstr ""
"— *broker*\\는 ``celery`` 모듈 내의 브로커 인수에서 지정한 URL이며, :option:"
"`-b <celery -b>` 옵션을 사용하여 커맨드 라인에서 다른 브로커를 지정하는 것도 "
"가능하다."

#: ../getting-started/next-steps.rst:99
msgid ""
"-- *Concurrency* is the number of prefork worker process used to process "
"your tasks concurrently, when all of these are busy doing work new tasks "
"will have to wait for one of the tasks to finish before it can be processed."
msgstr ""
"— *Concurrency*\\는 업무를 동시에 처리하는데 사용되는 미리 분기된(prefork) 워"
"커 프로세스의 수이다. 모든 워커 프로세스가 바쁠 때 새로운 태스크는 다른 태스"
"크가 완료될 때까지 기다려야지 처리될 수 있다."

#: ../getting-started/next-steps.rst:104
msgid ""
"The default concurrency number is the number of CPU's on that machine "
"(including cores), you can specify a custom number using the :option:`celery "
"worker -c` option. There's no recommended value, as the optimal number "
"depends on a number of factors, but if your tasks are mostly I/O-bound then "
"you can try to increase it, experimentation has shown that adding more than "
"twice the number of CPU's is rarely effective, and likely to degrade "
"performance instead."
msgstr ""
"기본적인 동시성 수(concurrency number)는 해당 머신(machine)의 CPU(core 포함)"
"의 개수로, :option:`celery worker -c` 옵션을 사용하여 그 임의로 수를 지정할 "
"수 있다. 권장 값은 따로 없으며, 최적의 수는 요인의 개수에 따라 달라지지만, 태"
"스크가 대부분 I/O-bound일 경우 이를 증가시키려고 시도해볼 수 있으며, 실험해 "
"본 결과로는 CPU 수의 2배 이상 추가하게 거의 효과가 나타나지 않고, 성능이 저하"
"될 수 있음이 나타났다."

#: ../getting-started/next-steps.rst:113
msgid ""
"Including the default prefork pool, Celery also supports using Eventlet, "
"Gevent, and running in a single thread (see :ref:`concurrency`)."
msgstr ""
"기본적으로 미리 분기된 풀(pool)을 포함해, 셀러리는 Eventlet, Gevent, 그리고 "
"단일 스레드 실행도 지원한다(:ref:`concurrency` 참고)."

#: ../getting-started/next-steps.rst:116
msgid ""
"-- *Events* is an option that when enabled causes Celery to send monitoring "
"messages (events) for actions occurring in the worker. These can be used by "
"monitor programs like ``celery events``, and Flower - the real-time Celery "
"monitor, that you can read about in the :ref:`Monitoring and Management "
"guide <guide-monitoring>`."
msgstr ""
"— *Events*\\는 셀러리가 워커에게 발생되는 액션에 대해 모니터링 메세지 (이벤"
"트)를 전송하도록 하는 옵션이다. ``celery events``\\와 같은 모니터 프로그램, "
"그리고 플라워(Flower) - 실시간 셀러리 모니터 프로그램에서 사용할 수 있으며, "
"이에 대한 내용은 :ref:`Monitoring and Management guide <guide-monitoring>`"
"\\에서 볼 수 있다."

#: ../getting-started/next-steps.rst:122
msgid ""
"-- *Queues* is the list of queues that the worker will consume tasks from. "
"The worker can be told to consume from several queues at once, and this is "
"used to route messages to specific workers as a means for Quality of "
"Service, separation of concerns, and prioritization, all described in the :"
"ref:`Routing Guide <guide-routing>`."
msgstr ""
"— *Queues*\\는 워커가 태스크를 소비하는 큐(queue)의 목록이다. 워커는 여러 큐"
"에서 한 번에 태스크를 소비하도록 지시할 수 있으며, 이는 서비스 품질, 관심"
"(concenrs) 분리, 우선 순위 지정, 그리고 :ref:`Routing Guide <guide-routing>`"
"\\에서 설명된 모든 것에 대한 t수단으로서 특정 워커에게 메세지를 라우팅하기 위"
"해 사용된다."

#: ../getting-started/next-steps.rst:129
msgid ""
"You can get a complete list of command-line arguments by passing in the :"
"option:`--help <celery --help>` flag:"
msgstr ""
"커맨드라인 인수의 전체 목록을 보려면 :option:`—help <celery —help>` 플래그를 "
"사용한다:"

#: ../getting-started/next-steps.rst:136
msgid ""
"These options are described in more detailed in the :ref:`Workers Guide "
"<guide-workers>`."
msgstr ""
"이러한 옵션들 :ref:`Workers Guide <guide-workers>`\\에서 보다 자세하게 설명한"
"다."

#: ../getting-started/next-steps.rst:139
msgid "Stopping the worker"
msgstr "워커 중지"

#: ../getting-started/next-steps.rst:141
msgid ""
"To stop the worker simply hit :kbd:`Control-c`. A list of signals supported "
"by the worker is detailed in the :ref:`Workers Guide <guide-workers>`."
msgstr ""
"워커를 중지하기 위해서는 간단히 :kbd:`Control-c`\\를 실행한다. 워커가 지원하"
"는 시그널(signal)의 목록은 :ref:`Workers Guide <guide-workers>`\\에서 자세히 "
"나와있다."

#: ../getting-started/next-steps.rst:145
msgid "In the background"
msgstr "백그라운드에서"

#: ../getting-started/next-steps.rst:147
msgid ""
"In production you'll want to run the worker in the background, this is "
"described in detail in the :ref:`daemonization tutorial <daemonizing>`."
msgstr ""
"제품(production) 단계 에서 백그라운드에서 워커를 실행하고 싶다면, :ref:"
"`daemonization tutorial <daemonizing>`\\에 자세한 설명이 있다."

#: ../getting-started/next-steps.rst:150
msgid ""
"The daemonization scripts uses the :program:`celery multi` command to start "
"one or more workers in the background:"
msgstr ""
"데몬 daemonization 스크립트는 :program:`celery multi` 명령어를 사용하여 하나 "
"또는 여러 개의 워커를 백그라운드에서 시작시킨다:"

#: ../getting-started/next-steps.rst:160
msgid "You can restart it too:"
msgstr "다시 시작할 수도 있다:"

#: ../getting-started/next-steps.rst:175
msgid "or stop it:"
msgstr "또는 중지한다:"

#: ../getting-started/next-steps.rst:181
msgid ""
"The ``stop`` command is asynchronous so it won't wait for the worker to "
"shutdown. You'll probably want to use the ``stopwait`` command instead,  "
"this ensures all currently executing tasks are completed before exiting:"
msgstr ""
"``stop`` 명령은 비동기적이기 때문에 워커가 종료될 때까지 기다리지 않는다. 원"
"한다면 대신에 ``stopwait``\\를 사용할 수 있는데,  현재 실행중인 모든 태스크들"
"이 종료되기 전에 확실히 완료되도록 한다:"

#: ../getting-started/next-steps.rst:192
msgid ""
":program:`celery multi` doesn't store information about workers so you need "
"to use the same command-line arguments when restarting. Only the same "
"pidfile and logfile arguments must be used when stopping."
msgstr ""
":program:`celery multi`\\는 워커에 대한 정보를 저장하지 않기 때문에 다시 시작"
"할 때 같은 커맨드라인 인수를 사용해야 한다. 중지할 때 같은 pidfile과 logfile "
"인수를 반드시 사용해야 한다."

#: ../getting-started/next-steps.rst:197
msgid ""
"By default it'll create pid and log files in the current directory, to "
"protect against multiple workers launching on top of each other you're "
"encouraged to put these in a dedicated directory:"
msgstr ""
"기본적으로 현재 디렉토리에다 pid와 로그 파일을 생성하는데, 여러 워커들이 서로"
"의 위에서 시작하는 것을 방지하기 위해 각각 전용 디렉토리에 해당 파일들을 저장"
"하도록 한다:"

#: ../getting-started/next-steps.rst:208
msgid ""
"With the multi command you can start multiple workers, and there's a "
"powerful command-line syntax to specify arguments for different workers too, "
"for example:"
msgstr ""
"다중 명령어를 가지고 여러 워커들을 시작할 수 있으며, 다른 워커에 대한 인수를 "
"지정하기 위한 강력한 커맨드 라인 구문(syntax)가 있다, 예를 들어:"

#: ../getting-started/next-steps.rst:217
msgid ""
"For more examples see the :mod:`~celery.bin.multi` module in the API "
"reference."
msgstr "더 많은 예시는 API 레퍼런스에서 :mod:`~celery.bin.multi` 모듈을 보라."

#: ../getting-started/next-steps.rst:223
msgid "About the :option:`--app <celery --app>` argument"
msgstr ":option:`—app <celery —app>` 인수에 관하여"

#: ../getting-started/next-steps.rst:225
msgid ""
"The :option:`--app <celery --app>` argument specifies the Celery app "
"instance to use, it must be in the form of ``module.path:attribute``"
msgstr ""
":option:`—app <celery —app>` 인수는 사용하려는 셀러리 앱 인스턴스를 지정하"
"고, 반드시 ``module.path:attribute``\\의 형태로 되어 있어야 한다"

#: ../getting-started/next-steps.rst:228
msgid ""
"But it also supports a shortcut form If only a package name is specified, "
"where it'll try to search for the app instance, in the following order:"
msgstr ""
"하지만 패키지 이름만 명시하면 다음과 같은 순서로 앱 인스턴스를 검색할 수 있"
"는 바로 가기 형식도 지원한다:"

#: ../getting-started/next-steps.rst:231
msgid "With :option:`--app=proj <celery --app>`:"
msgstr ":option:`—app=proj <celery —app>` 사:"

#: ../getting-started/next-steps.rst:233
msgid "an attribute named ``proj.app``, or"
msgstr "``proj.app`` 이름의 속성(attribute), 또는"

#: ../getting-started/next-steps.rst:234
msgid "an attribute named ``proj.celery``, or"
msgstr "``proj.celery`` 이름의 속성(attribute), 또는"

#: ../getting-started/next-steps.rst:235
msgid ""
"any attribute in the module ``proj`` where the value is a Celery "
"application, or"
msgstr "값이 셀러리 어플리케이션인 경우 ``proj`` 모듈의 모든 속성, 또"

#: ../getting-started/next-steps.rst:238
msgid "If none of these are found it'll try a submodule named ``proj.celery``:"
msgstr ""
"이 중 어떤 것에도 해당하지 않으면 ``proj.celery``\\라는 이름의 서브 모듈을 사"
"용할 것이:"

#: ../getting-started/next-steps.rst:240
msgid "an attribute named ``proj.celery.app``, or"
msgstr "``proj.celery.app`` 이름의 속성, 또"

#: ../getting-started/next-steps.rst:241
msgid "an attribute named ``proj.celery.celery``, or"
msgstr "``proj.celery.celery`` 이름의 속성, 또"

#: ../getting-started/next-steps.rst:242
msgid ""
"Any attribute in the module ``proj.celery`` where the value is a Celery "
"application."
msgstr "값이 셀러리 어플리케이션인 경우 ``proj.celery`` 모듈의 모든 속성."

#: ../getting-started/next-steps.rst:245
msgid ""
"This scheme mimics the practices used in the documentation -- that is, "
"``proj:app`` for a single contained module, and ``proj.celery:app`` for "
"larger projects."
msgstr ""

#: ../getting-started/next-steps.rst:253
msgid "Calling Tasks"
msgstr ""

#: ../getting-started/next-steps.rst:255
msgid "You can call a task using the :meth:`delay` method:"
msgstr ""

#: ../getting-started/next-steps.rst:261
msgid ""
"This method is actually a star-argument shortcut to another method called :"
"meth:`apply_async`:"
msgstr ""

#: ../getting-started/next-steps.rst:268
msgid ""
"The latter enables you to specify execution options like the time to run "
"(countdown), the queue it should be sent to, and so on:"
msgstr ""

#: ../getting-started/next-steps.rst:275
msgid ""
"In the above example the task will be sent to a queue named ``lopri`` and "
"the task will execute, at the earliest, 10 seconds after the message was "
"sent."
msgstr ""

#: ../getting-started/next-steps.rst:278
msgid ""
"Applying the task directly will execute the task in the current process, so "
"that no message is sent:"
msgstr ""

#: ../getting-started/next-steps.rst:286
msgid ""
"These three methods - :meth:`delay`, :meth:`apply_async`, and applying "
"(``__call__``), represents the Celery calling API, that's also used for "
"signatures."
msgstr ""

#: ../getting-started/next-steps.rst:290
msgid ""
"A more detailed overview of the Calling API can be found in the :ref:"
"`Calling User Guide <guide-calling>`."
msgstr ""

#: ../getting-started/next-steps.rst:293
msgid ""
"Every task invocation will be given a unique identifier (an UUID), this is "
"the task id."
msgstr ""

#: ../getting-started/next-steps.rst:296
msgid ""
"The ``delay`` and ``apply_async`` methods return an :class:`~@AsyncResult` "
"instance, that can be used to keep track of the tasks execution state. But "
"for this you need to enable a :ref:`result backend <task-result-backends>` "
"so that the state can be stored somewhere."
msgstr ""

#: ../getting-started/next-steps.rst:301
msgid ""
"Results are disabled by default because of the fact that there's no result "
"backend that suits every application, so to choose one you need to consider "
"the drawbacks of each individual backend. For many tasks keeping the return "
"value isn't even very useful, so it's a sensible default to have. Also note "
"that result backends aren't used for monitoring tasks and workers, for that "
"Celery uses dedicated event messages (see :ref:`guide-monitoring`)."
msgstr ""

#: ../getting-started/next-steps.rst:308
msgid ""
"If you have a result backend configured you can retrieve the return value of "
"a task:"
msgstr ""

#: ../getting-started/next-steps.rst:317
msgid "You can find the task's id by looking at the :attr:`id` attribute:"
msgstr ""

#: ../getting-started/next-steps.rst:324
msgid ""
"You can also inspect the exception and traceback if the task raised an "
"exception, in fact ``result.get()`` will propagate any errors by default:"
msgstr ""

#: ../getting-started/next-steps.rst:342
msgid ""
"If you don't wish for the errors to propagate then you can disable that by "
"passing the ``propagate`` argument:"
msgstr ""

#: ../getting-started/next-steps.rst:350
msgid ""
"In this case it'll return the exception instance raised instead, and so to "
"check whether the task succeeded or failed you'll have to use the "
"corresponding methods on the result instance:"
msgstr ""

#: ../getting-started/next-steps.rst:362
msgid ""
"So how does it know if the task has failed or not?  It can find out by "
"looking at the tasks *state*:"
msgstr ""

#: ../getting-started/next-steps.rst:370
msgid ""
"A task can only be in a single state, but it can progress through several "
"states. The stages of a typical task can be::"
msgstr ""

#: ../getting-started/next-steps.rst:375
msgid ""
"The started state is a special state that's only recorded if the :setting:"
"`task_track_started` setting is enabled, or if the "
"``@task(track_started=True)`` option is set for the task."
msgstr ""

#: ../getting-started/next-steps.rst:379
msgid ""
"The pending state is actually not a recorded state, but rather the default "
"state for any task id that's unknown: this you can see from this example:"
msgstr ""

#: ../getting-started/next-steps.rst:391
msgid ""
"If the task is retried the stages can become even more complex. To "
"demonstrate, for a task that's retried two times the stages would be:"
msgstr ""

#: ../getting-started/next-steps.rst:398
msgid ""
"To read more about task states you should see the :ref:`task-states` section "
"in the tasks user guide."
msgstr ""

#: ../getting-started/next-steps.rst:401
msgid ""
"Calling tasks is described in detail in the :ref:`Calling Guide <guide-"
"calling>`."
msgstr ""

#: ../getting-started/next-steps.rst:407
msgid "*Canvas*: Designing Work-flows"
msgstr ""

#: ../getting-started/next-steps.rst:409
msgid ""
"You just learned how to call a task using the tasks ``delay`` method, and "
"this is often all you need, but sometimes you may want to pass the signature "
"of a task invocation to another process or as an argument to another "
"function, for this Celery uses something called *signatures*."
msgstr ""

#: ../getting-started/next-steps.rst:414
msgid ""
"A signature wraps the arguments and execution options of a single task "
"invocation in a way such that it can be passed to functions or even "
"serialized and sent across the wire."
msgstr ""

#: ../getting-started/next-steps.rst:418
msgid ""
"You can create a signature for the ``add`` task using the arguments ``(2, "
"2)``, and a countdown of 10 seconds like this:"
msgstr ""

#: ../getting-started/next-steps.rst:426
msgid "There's also a shortcut using star arguments:"
msgstr ""

#: ../getting-started/next-steps.rst:434
msgid "And there's that calling API again…"
msgstr ""

#: ../getting-started/next-steps.rst:436
msgid ""
"Signature instances also supports the calling API: meaning they have the "
"``delay`` and ``apply_async`` methods."
msgstr ""

#: ../getting-started/next-steps.rst:439
msgid ""
"But there's a difference in that the signature may already have an argument "
"signature specified. The ``add`` task takes two arguments, so a signature "
"specifying two arguments would make a complete signature:"
msgstr ""

#: ../getting-started/next-steps.rst:450
msgid ""
"But, you can also make incomplete signatures to create what we call "
"*partials*:"
msgstr ""

#: ../getting-started/next-steps.rst:458
msgid ""
"``s2`` is now a partial signature that needs another argument to be "
"complete, and this can be resolved when calling the signature:"
msgstr ""

#: ../getting-started/next-steps.rst:468
msgid ""
"Here you added the argument 8 that was prepended to the existing argument 2 "
"forming a complete signature of ``add(8, 2)``."
msgstr ""

#: ../getting-started/next-steps.rst:471
msgid ""
"Keyword arguments can also be added later, these are then merged with any "
"existing keyword arguments, but with new arguments taking precedence:"
msgstr ""

#: ../getting-started/next-steps.rst:479
msgid "As stated signatures supports the calling API: meaning that;"
msgstr ""

#: ../getting-started/next-steps.rst:481
msgid "``sig.apply_async(args=(), kwargs={}, **options)``"
msgstr ""

#: ../getting-started/next-steps.rst:483
msgid ""
"Calls the signature with optional partial arguments and partial keyword "
"arguments. Also supports partial execution options."
msgstr ""

#: ../getting-started/next-steps.rst:486
msgid "``sig.delay(*args, **kwargs)``"
msgstr ""

#: ../getting-started/next-steps.rst:488
msgid ""
"Star argument version of ``apply_async``. Any arguments will be prepended to "
"the arguments in the signature, and keyword arguments is merged with any "
"existing keys."
msgstr ""

#: ../getting-started/next-steps.rst:492
msgid ""
"So this all seems very useful, but what can you actually do with these? To "
"get to that I must introduce the canvas primitives…"
msgstr ""

#: ../getting-started/next-steps.rst:496
msgid "The Primitives"
msgstr ""

#: ../getting-started/next-steps.rst:503
msgid ":ref:`group <canvas-group>`"
msgstr ""

#: ../getting-started/next-steps.rst:504
msgid ":ref:`chain <canvas-chain>`"
msgstr ""

#: ../getting-started/next-steps.rst:505
msgid ":ref:`chord <canvas-chord>`"
msgstr ""

#: ../getting-started/next-steps.rst:506
msgid ":ref:`map <canvas-map>`"
msgstr ""

#: ../getting-started/next-steps.rst:507
msgid ":ref:`starmap <canvas-map>`"
msgstr ""

#: ../getting-started/next-steps.rst:508
msgid ":ref:`chunks <canvas-chunks>`"
msgstr ""

#: ../getting-started/next-steps.rst:510
msgid ""
"These primitives are signature objects themselves, so they can be combined "
"in any number of ways to compose complex work-flows."
msgstr ""

#: ../getting-started/next-steps.rst:515
msgid ""
"These examples retrieve results, so to try them out you need to configure a "
"result backend. The example project above already does that (see the backend "
"argument to :class:`~celery.Celery`)."
msgstr ""

#: ../getting-started/next-steps.rst:519
msgid "Let's look at some examples:"
msgstr ""

#: ../getting-started/next-steps.rst:522
msgid "Groups"
msgstr ""

#: ../getting-started/next-steps.rst:524
msgid ""
"A :class:`~celery.group` calls a list of tasks in parallel, and it returns a "
"special result instance that lets you inspect the results as a group, and "
"retrieve the return values in order."
msgstr ""

#: ../getting-started/next-steps.rst:536
msgid "Partial group"
msgstr ""

#: ../getting-started/next-steps.rst:545
msgid "Chains"
msgstr ""

#: ../getting-started/next-steps.rst:547
msgid ""
"Tasks can be linked together so that after one task returns the other is "
"called:"
msgstr ""

#: ../getting-started/next-steps.rst:560
msgid "or a partial chain:"
msgstr ""

#: ../getting-started/next-steps.rst:570
msgid "Chains can also be written like this:"
msgstr ""

#: ../getting-started/next-steps.rst:578
msgid "Chords"
msgstr ""

#: ../getting-started/next-steps.rst:580
msgid "A chord is a group with a callback:"
msgstr ""

#: ../getting-started/next-steps.rst:591
msgid ""
"A group chained to another task will be automatically converted to a chord:"
msgstr ""

#: ../getting-started/next-steps.rst:600
msgid ""
"Since these primitives are all of the signature type they can be combined "
"almost however you want, for example:"
msgstr ""

#: ../getting-started/next-steps.rst:607
msgid ""
"Be sure to read more about work-flows in the :ref:`Canvas <guide-canvas>` "
"user guide."
msgstr ""

#: ../getting-started/next-steps.rst:611
msgid "Routing"
msgstr ""

#: ../getting-started/next-steps.rst:613
msgid ""
"Celery supports all of the routing facilities provided by AMQP, but it also "
"supports simple routing where messages are sent to named queues."
msgstr ""

#: ../getting-started/next-steps.rst:616
msgid ""
"The :setting:`task_routes` setting enables you to route tasks by name and "
"keep everything centralized in one location:"
msgstr ""

#: ../getting-started/next-steps.rst:627
msgid ""
"You can also specify the queue at runtime with the ``queue`` argument to "
"``apply_async``:"
msgstr ""

#: ../getting-started/next-steps.rst:635
msgid ""
"You can then make a worker consume from this queue by specifying the :option:"
"`celery worker -Q` option:"
msgstr ""

#: ../getting-started/next-steps.rst:642
msgid ""
"You may specify multiple queues by using a comma separated list, for example "
"you can make the worker consume from both the default queue, and the "
"``hipri`` queue, where the default queue is named ``celery`` for historical "
"reasons:"
msgstr ""

#: ../getting-started/next-steps.rst:651
msgid ""
"The order of the queues doesn't matter as the worker will give equal weight "
"to the queues."
msgstr ""

#: ../getting-started/next-steps.rst:654
msgid ""
"To learn more about routing, including taking use of the full power of AMQP "
"routing, see the :ref:`Routing Guide <guide-routing>`."
msgstr ""

#: ../getting-started/next-steps.rst:658
msgid "Remote Control"
msgstr ""

#: ../getting-started/next-steps.rst:660
msgid ""
"If you're using RabbitMQ (AMQP), Redis, or Qpid as the broker then you can "
"control and inspect the worker at runtime."
msgstr ""

#: ../getting-started/next-steps.rst:663
msgid "For example you can see what tasks the worker is currently working on:"
msgstr ""

#: ../getting-started/next-steps.rst:669
msgid ""
"This is implemented by using broadcast messaging, so all remote control "
"commands are received by every worker in the cluster."
msgstr ""

#: ../getting-started/next-steps.rst:672
msgid ""
"You can also specify one or more workers to act on the request using the :"
"option:`--destination <celery inspect --destination>` option. This is a "
"comma separated list of worker host names:"
msgstr ""

#: ../getting-started/next-steps.rst:680
msgid ""
"If a destination isn't provided then every worker will act and reply to the "
"request."
msgstr ""

#: ../getting-started/next-steps.rst:683
msgid ""
"The :program:`celery inspect` command contains commands that doesn't change "
"anything in the worker, it only replies information and statistics about "
"what's going on inside the worker. For a list of inspect commands you can "
"execute:"
msgstr ""

#: ../getting-started/next-steps.rst:692
msgid ""
"Then there's the :program:`celery control` command, that contains commands "
"that actually changes things in the worker at runtime:"
msgstr ""

#: ../getting-started/next-steps.rst:699
msgid ""
"For example you can force workers to enable event messages (used for "
"monitoring tasks and workers):"
msgstr ""

#: ../getting-started/next-steps.rst:706
msgid ""
"When events are enabled you can then start the event dumper to see what the "
"workers are doing:"
msgstr ""

#: ../getting-started/next-steps.rst:713
msgid "or you can start the curses interface:"
msgstr ""

#: ../getting-started/next-steps.rst:719
msgid "when you're finished monitoring you can disable events again:"
msgstr ""

#: ../getting-started/next-steps.rst:725
msgid ""
"The :program:`celery status` command also uses remote control commands and "
"shows a list of online workers in the cluster:"
msgstr ""

#: ../getting-started/next-steps.rst:732
msgid ""
"You can read more about the :program:`celery` command and monitoring in the :"
"ref:`Monitoring Guide <guide-monitoring>`."
msgstr ""

#: ../getting-started/next-steps.rst:736
msgid "Timezone"
msgstr ""

#: ../getting-started/next-steps.rst:738
msgid "All times and dates, internally and in messages uses the UTC timezone."
msgstr ""

#: ../getting-started/next-steps.rst:740
msgid ""
"When the worker receives a message, for example with a countdown set it "
"converts that UTC time to local time. If you wish to use a different "
"timezone than the system timezone then you must configure that using the :"
"setting:`timezone` setting:"
msgstr ""

#: ../getting-started/next-steps.rst:750
msgid "Optimization"
msgstr ""

#: ../getting-started/next-steps.rst:752
msgid ""
"The default configuration isn't optimized for throughput by default, it "
"tries to walk the middle way between many short tasks and fewer long tasks, "
"a compromise between throughput and fair scheduling."
msgstr ""

#: ../getting-started/next-steps.rst:756
msgid ""
"If you have strict fair scheduling requirements, or want to optimize for "
"throughput then you should read the :ref:`Optimizing Guide <guide-"
"optimizing>`."
msgstr ""

#: ../getting-started/next-steps.rst:760
msgid ""
"If you're using RabbitMQ then you can install the :pypi:`librabbitmq` "
"module: this is an AMQP client implemented in C:"
msgstr ""

#: ../getting-started/next-steps.rst:768
msgid "What to do now?"
msgstr ""

#: ../getting-started/next-steps.rst:770
msgid ""
"Now that you have read this document you should continue to the :ref:`User "
"Guide <guide>`."
msgstr ""

#: ../getting-started/next-steps.rst:773
msgid "There's also an :ref:`API reference <apiref>` if you're so inclined."
msgstr ""
