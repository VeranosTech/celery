# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2009-2018, Ask Solem & contributors
# This file is distributed under the same license as the Celery package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Celery 4.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-22 13:42+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../userguide/application.rst:5
msgid "Application"
msgstr ""

#: ../../userguide/application.rst:11
msgid ""
"The Celery library must be instantiated before use, this instance is "
"called an application (or *app* for short)."
msgstr ""

#: ../../userguide/application.rst:14
msgid ""
"The application is thread-safe so that multiple Celery applications with "
"different configurations, components, and tasks can co-exist in the same "
"process space."
msgstr ""

#: ../../userguide/application.rst:18
msgid "Let's create one now:"
msgstr ""

#: ../../userguide/application.rst:27
msgid ""
"The last line shows the textual representation of the application: "
"including the name of the app class (``Celery``), the name of the current"
" main module (``__main__``), and the memory address of the object "
"(``0x100469fd0``)."
msgstr ""

#: ../../userguide/application.rst:33
msgid "Main Name"
msgstr ""

#: ../../userguide/application.rst:35
msgid ""
"Only one of these is important, and that's the main module name. Let's "
"look at why that is."
msgstr ""

#: ../../userguide/application.rst:38
msgid ""
"When you send a task message in Celery, that message won't contain any "
"source code, but only the name of the task you want to execute. This "
"works similarly to how host names work on the internet: every worker "
"maintains a mapping of task names to their actual functions, called the "
"*task registry*."
msgstr ""

#: ../../userguide/application.rst:44
msgid ""
"Whenever you define a task, that task will also be added to the local "
"registry:"
msgstr ""

#: ../../userguide/application.rst:61
msgid ""
"and there you see that ``__main__`` again; whenever Celery isn't able to "
"detect what module the function belongs to, it uses the main module name "
"to generate the beginning of the task name."
msgstr ""

#: ../../userguide/application.rst:65
msgid "This is only a problem in a limited set of use cases:"
msgstr ""

#: ../../userguide/application.rst:67
msgid "If the module that the task is defined in is run as a program."
msgstr ""

#: ../../userguide/application.rst:68
msgid "If the application is created in the Python shell (REPL)."
msgstr ""

#: ../../userguide/application.rst:70
msgid ""
"For example here, where the tasks module is also used to start a worker "
"with :meth:`@worker_main`:"
msgstr ""

#: ../../userguide/application.rst:73 ../../userguide/tasks.rst:225
msgid ":file:`tasks.py`:"
msgstr ""

#: ../../userguide/application.rst:86
msgid ""
"When this module is executed the tasks will be named starting with "
"\"``__main__``\", but when the module is imported by another process, say"
" to call a task, the tasks will be named starting with \"``tasks``\" (the"
" real name of the module):"
msgstr ""

#: ../../userguide/application.rst:96
msgid "You can specify another name for the main module:"
msgstr ""

#: ../../userguide/application.rst:111
msgid ":ref:`task-names`"
msgstr ""

#: ../../userguide/application.rst:114
msgid "Configuration"
msgstr ""

#: ../../userguide/application.rst:116
msgid ""
"There are several options you can set that'll change how Celery works. "
"These options can be set directly on the app instance, or you can use a "
"dedicated configuration module."
msgstr ""

#: ../../userguide/application.rst:120
msgid "The configuration is available as :attr:`@conf`:"
msgstr ""

#: ../../userguide/application.rst:127
msgid "where you can also set configuration values directly:"
msgstr ""

#: ../../userguide/application.rst:133
msgid "or update several keys at once by using the ``update`` method:"
msgstr ""

#: ../../userguide/application.rst:142
msgid ""
"The configuration object consists of multiple dictionaries that are "
"consulted in order:"
msgstr ""

#: ../../userguide/application.rst:145
msgid "Changes made at run-time."
msgstr ""

#: ../../userguide/application.rst:146
msgid "The configuration module (if any)"
msgstr ""

#: ../../userguide/application.rst:147
msgid "The default configuration (:mod:`celery.app.defaults`)."
msgstr ""

#: ../../userguide/application.rst:149
msgid ""
"You can even add new default sources by using the :meth:`@add_defaults` "
"method."
msgstr ""

#: ../../userguide/application.rst:154
msgid ""
"Go to the :ref:`Configuration reference <configuration>` for a complete "
"listing of all the available settings, and their default values."
msgstr ""

#: ../../userguide/application.rst:158
msgid "``config_from_object``"
msgstr ""

#: ../../userguide/application.rst:160
msgid ""
"The :meth:`@config_from_object` method loads configuration from a "
"configuration object."
msgstr ""

#: ../../userguide/application.rst:163
msgid ""
"This can be a configuration module, or any object with configuration "
"attributes."
msgstr ""

#: ../../userguide/application.rst:165
msgid ""
"Note that any configuration that was previously set will be reset when "
":meth:`~@config_from_object` is called. If you want to set additional "
"configuration you should do so after."
msgstr ""

#: ../../userguide/application.rst:170
msgid "Example 1: Using the name of a module"
msgstr ""

#: ../../userguide/application.rst:172
msgid ""
"The :meth:`@config_from_object` method can take the fully qualified name "
"of a Python module, or even the name of a Python attribute, for example: "
"``\"celeryconfig\"``, ``\"myproj.config.celery\"``, or "
"``\"myproj.config:CeleryConfig\"``:"
msgstr ""

#: ../../userguide/application.rst:184
msgid "The ``celeryconfig`` module may then look like this:"
msgstr ""

#: ../../userguide/application.rst:186
msgid ":file:`celeryconfig.py`:"
msgstr ""

#: ../../userguide/application.rst:193
msgid ""
"and the app will be able to use it as long as ``import celeryconfig`` is "
"possible."
msgstr ""

#: ../../userguide/application.rst:197
msgid "Example 2: Passing an actual module object"
msgstr ""

#: ../../userguide/application.rst:199
msgid ""
"You can also pass an already imported module object, but this isn't "
"always recommended."
msgstr ""

#: ../../userguide/application.rst:204
msgid ""
"Using the name of a module is recommended as this means the module does "
"not need to be serialized when the prefork pool is used. If you're "
"experiencing configuration problems or pickle errors then please try "
"using the name of a module instead."
msgstr ""

#: ../../userguide/application.rst:220
msgid "Example 3:  Using a configuration class/object"
msgstr ""

#: ../../userguide/application.rst:237
msgid "``config_from_envvar``"
msgstr ""

#: ../../userguide/application.rst:239
msgid ""
"The :meth:`@config_from_envvar` takes the configuration module name from "
"an environment variable"
msgstr ""

#: ../../userguide/application.rst:242
msgid ""
"For example -- to load configuration from a module specified in the "
"environment variable named :envvar:`CELERY_CONFIG_MODULE`:"
msgstr ""

#: ../../userguide/application.rst:256
msgid "You can then specify the configuration module to use via the environment:"
msgstr ""

#: ../../userguide/application.rst:265
msgid "Censored configuration"
msgstr ""

#: ../../userguide/application.rst:267
msgid ""
"If you ever want to print out the configuration, as debugging information"
" or similar, you may also want to filter out sensitive information like "
"passwords and API keys."
msgstr ""

#: ../../userguide/application.rst:271
msgid ""
"Celery comes with several utilities useful for presenting the "
"configuration, one is :meth:`~celery.app.utils.Settings.humanize`:"
msgstr ""

#: ../../userguide/application.rst:278
msgid ""
"This method returns the configuration as a tabulated string. This will "
"only contain changes to the configuration by default, but you can include"
" the built-in default keys and values by enabling the ``with_defaults`` "
"argument."
msgstr ""

#: ../../userguide/application.rst:282
msgid ""
"If you instead want to work with the configuration as a dictionary, you "
"can use the :meth:`~celery.app.utils.Settings.table` method:"
msgstr ""

#: ../../userguide/application.rst:289
msgid ""
"Please note that Celery won't be able to remove all sensitive "
"information, as it merely uses a regular expression to search for "
"commonly named keys. If you add custom settings containing sensitive "
"information you should name the keys using a name that Celery identifies "
"as secret."
msgstr ""

#: ../../userguide/application.rst:294
msgid ""
"A configuration setting will be censored if the name contains any of "
"these sub-strings:"
msgstr ""

#: ../../userguide/application.rst:297
msgid ""
"``API``, ``TOKEN``, ``KEY``, ``SECRET``, ``PASS``, ``SIGNATURE``, "
"``DATABASE``"
msgstr ""

#: ../../userguide/application.rst:300
msgid "Laziness"
msgstr ""

#: ../../userguide/application.rst:302
msgid ""
"The application instance is lazy, meaning it won't be evaluated until "
"it's actually needed."
msgstr ""

#: ../../userguide/application.rst:305
msgid "Creating a :class:`@Celery` instance will only do the following:"
msgstr ""

#: ../../userguide/application.rst:307
msgid "Create a logical clock instance, used for events."
msgstr ""

#: ../../userguide/application.rst:308
msgid "Create the task registry."
msgstr ""

#: ../../userguide/application.rst:309
msgid ""
"Set itself as the current app (but not if the ``set_as_current`` argument"
" was disabled)"
msgstr ""

#: ../../userguide/application.rst:311
msgid "Call the :meth:`@on_init` callback (does nothing by default)."
msgstr ""

#: ../../userguide/application.rst:313
msgid ""
"The :meth:`@task` decorators don't create the tasks at the point when the"
" task is defined, instead it'll defer the creation of the task to happen "
"either when the task is used, or after the application has been "
"*finalized*,"
msgstr ""

#: ../../userguide/application.rst:318
msgid ""
"This example shows how the task isn't created until you use the task, or "
"access an attribute (in this case :meth:`repr`):"
msgstr ""

#: ../../userguide/application.rst:339
msgid ""
"*Finalization* of the app happens either explicitly by calling "
":meth:`@finalize` -- or implicitly by accessing the :attr:`@tasks` "
"attribute."
msgstr ""

#: ../../userguide/application.rst:343
msgid "Finalizing the object will:"
msgstr ""

#: ../../userguide/application.rst:345
msgid "Copy tasks that must be shared between apps"
msgstr ""

#: ../../userguide/application.rst:347
msgid ""
"Tasks are shared by default, but if the ``shared`` argument to the task "
"decorator is disabled, then the task will be private to the app it's "
"bound to."
msgstr ""

#: ../../userguide/application.rst:351
msgid "Evaluate all pending task decorators."
msgstr ""

#: ../../userguide/application.rst:353
msgid "Make sure all tasks are bound to the current app."
msgstr ""

#: ../../userguide/application.rst:355
msgid ""
"Tasks are bound to an app so that they can read default values from the "
"configuration."
msgstr ""

msgid "The \"default app\""
msgstr ""

#: ../../userguide/application.rst:362
msgid ""
"Celery didn't always have applications, it used to be that there was only"
" a module-based API, and for backwards compatibility the old API is still"
" there until the release of Celery 5.0."
msgstr ""

#: ../../userguide/application.rst:366
msgid ""
"Celery always creates a special app - the \"default app\", and this is "
"used if no custom application has been instantiated."
msgstr ""

#: ../../userguide/application.rst:369
msgid ""
"The :mod:`celery.task` module is there to accommodate the old API, and "
"shouldn't be used if you use a custom app. You should always use the "
"methods on the app instance, not the module based API."
msgstr ""

#: ../../userguide/application.rst:373
msgid ""
"For example, the old Task base class enables many compatibility features "
"where some may be incompatible with newer features, such as task methods:"
msgstr ""

#: ../../userguide/application.rst:383
msgid ""
"The new base class is recommended even if you use the old module-based "
"API."
msgstr ""

#: ../../userguide/application.rst:388
msgid "Breaking the chain"
msgstr ""

#: ../../userguide/application.rst:390
msgid ""
"While it's possible to depend on the current app being set, the best "
"practice is to always pass the app instance around to anything that needs"
" it."
msgstr ""

#: ../../userguide/application.rst:394
msgid ""
"I call this the \"app chain\", since it creates a chain of instances "
"depending on the app being passed."
msgstr ""

#: ../../userguide/application.rst:397
msgid "The following example is considered bad practice:"
msgstr ""

#: ../../userguide/application.rst:408
msgid "Instead it should take the ``app`` as an argument:"
msgstr ""

#: ../../userguide/application.rst:417
msgid ""
"Internally Celery uses the :func:`celery.app.app_or_default` function so "
"that everything also works in the module-based compatibility API"
msgstr ""

#: ../../userguide/application.rst:428
msgid ""
"In development you can set the :envvar:`CELERY_TRACE_APP` environment "
"variable to raise an exception if the app chain breaks:"
msgstr ""

#: ../../userguide/application.rst:439
msgid "Celery has changed a lot from 2009 since it was initially created."
msgstr ""

#: ../../userguide/application.rst:442
msgid ""
"For example, in the beginning it was possible to use any callable as a "
"task:"
msgstr ""

#: ../../userguide/application.rst:454
msgid ""
"or you could also create a ``Task`` class to set certain options, or "
"override other behavior"
msgstr ""

#: ../../userguide/application.rst:471
msgid ""
"Later, it was decided that passing arbitrary call-able's was an anti-"
"pattern, since it makes it very hard to use serializers other than "
"pickle, and the feature was removed in 2.0, replaced by task decorators:"
msgstr ""

#: ../../userguide/application.rst:485
msgid "Abstract Tasks"
msgstr ""

#: ../../userguide/application.rst:487
msgid ""
"All tasks created using the :meth:`~@task` decorator will inherit from "
"the application's base :attr:`~@Task` class."
msgstr ""

#: ../../userguide/application.rst:490
msgid "You can specify a different base class using the ``base`` argument:"
msgstr ""

#: ../../userguide/application.rst:498
msgid ""
"To create a custom task class you should inherit from the neutral base "
"class: :class:`celery.Task`."
msgstr ""

#: ../../userguide/application.rst:514
msgid ""
"If you override the tasks ``__call__`` method, then it's very important "
"that you also call super so that the base call method can set up the "
"default request used when a task is called directly."
msgstr ""

#: ../../userguide/application.rst:518
msgid ""
"The neutral base class is special because it's not bound to any specific "
"app yet. Once a task is bound to an app it'll read configuration to set "
"default values, and so on."
msgstr ""

#: ../../userguide/application.rst:522
msgid ""
"To realize a base class you need to create a task using the :meth:`@task`"
" decorator:"
msgstr ""

#: ../../userguide/application.rst:531
msgid ""
"It's even possible to change the default base class for an application by"
" changing its :meth:`@Task` attribute:"
msgstr ""

#: ../../userguide/calling.rst:5
msgid "Calling Tasks"
msgstr ""

#: ../../userguide/calling.rst:15 ../../userguide/debugging.rst:13
#: ../../userguide/routing.rst:20 ../../userguide/signals.rst:19
#: ../../userguide/tasks.rst:91
msgid "Basics"
msgstr ""

#: ../../userguide/calling.rst:17
msgid ""
"This document describes Celery's uniform \"Calling API\" used by task "
"instances and the :ref:`canvas <guide-canvas>`."
msgstr ""

#: ../../userguide/calling.rst:20
msgid ""
"The API defines a standard set of execution options, as well as three "
"methods:"
msgstr ""

#: ../../userguide/calling.rst:22
msgid "``apply_async(args[, kwargs[, …]])``"
msgstr ""

#: ../../userguide/calling.rst:24
msgid "Sends a task message."
msgstr ""

#: ../../userguide/calling.rst:26
msgid "``delay(*args, **kwargs)``"
msgstr ""

#: ../../userguide/calling.rst:28
msgid "Shortcut to send a task message, but doesn't support execution options."
msgstr ""

#: ../../userguide/calling.rst:31
msgid "*calling* (``__call__``)"
msgstr ""

#: ../../userguide/calling.rst:33
msgid ""
"Applying an object supporting the calling API (e.g., ``add(2, 2)``) means"
" that the task will not be executed by a worker, but in the current "
"process instead (a message won't be sent)."
msgstr ""

#: ../../userguide/calling.rst:43
msgid "``T.delay(arg, kwarg=value)``"
msgstr ""

#: ../../userguide/calling.rst:42
msgid ""
"Star arguments shortcut to ``.apply_async``. (``.delay(*args, **kwargs)``"
" calls ``.apply_async(args, kwargs)``)."
msgstr ""

#: ../../userguide/calling.rst:45
msgid "``T.apply_async((arg,), {'kwarg': value})``"
msgstr ""

#: ../../userguide/calling.rst:48
msgid "``T.apply_async(countdown=10)``"
msgstr ""

#: ../../userguide/calling.rst:48
msgid "executes in 10 seconds from now."
msgstr ""

#: ../../userguide/calling.rst:51
msgid "``T.apply_async(eta=now + timedelta(seconds=10))``"
msgstr ""

#: ../../userguide/calling.rst:51
msgid "executes in 10 seconds from now, specified using ``eta``"
msgstr ""

#: ../../userguide/calling.rst:54
msgid "``T.apply_async(countdown=60, expires=120)``"
msgstr ""

#: ../../userguide/calling.rst:54
msgid "executes in one minute from now, but expires after 2 minutes."
msgstr ""

#: ../../userguide/calling.rst:56
msgid "``T.apply_async(expires=now + timedelta(days=2))``"
msgstr ""

#: ../../userguide/calling.rst:57
msgid "expires in 2 days, set using :class:`~datetime.datetime`."
msgstr ""

#: ../../userguide/calling.rst:61 ../../userguide/tasks.rst:461
#: ../../userguide/tasks.rst:1948
msgid "Example"
msgstr ""

#: ../../userguide/calling.rst:63
msgid ""
"The :meth:`~@Task.delay` method is convenient as it looks like calling a "
"regular function:"
msgstr ""

#: ../../userguide/calling.rst:70
msgid "Using :meth:`~@Task.apply_async` instead you have to write:"
msgstr ""

#: ../../userguide/monitoring.rst
msgid "Tip"
msgstr ""

#: ../../userguide/calling.rst:78
msgid ""
"If the task isn't registered in the current process you can use "
":meth:`~@send_task` to call the task by name instead."
msgstr ""

#: ../../userguide/calling.rst:82
msgid ""
"So `delay` is clearly convenient, but if you want to set additional "
"execution options you have to use ``apply_async``."
msgstr ""

#: ../../userguide/calling.rst:85
msgid ""
"The rest of this document will go into the task execution options in "
"detail. All examples use a task called `add`, returning the sum of two "
"arguments:"
msgstr ""

#: ../../userguide/calling.rst:98
msgid ""
"You'll learn more about this later while reading about the :ref:`Canvas "
"<guide-canvas>`, but :class:`~celery.signature`'s are objects used to "
"pass around the signature of a task invocation, (for example to send it "
"over the network), and they also support the Calling API:"
msgstr ""

#: ../../userguide/calling.rst:110
msgid "Linking (callbacks/errbacks)"
msgstr ""

#: ../../userguide/calling.rst:112
msgid ""
"Celery supports linking tasks together so that one task follows another. "
"The callback task will be applied with the result of the parent task as a"
" partial argument:"
msgstr ""

msgid "What's ``s``?"
msgstr ""

#: ../../userguide/calling.rst:122
msgid ""
"The ``add.s`` call used here is called a signature. If you don't know "
"what they are you should read about them in the :ref:`canvas guide "
"<guide-canvas>`. There you can also learn about :class:`~celery.chain`:  "
"a simpler way to chain tasks together."
msgstr ""

#: ../../userguide/calling.rst:128
msgid ""
"In practice the ``link`` execution option is considered an internal "
"primitive, and you'll probably not use it directly, but use chains "
"instead."
msgstr ""

#: ../../userguide/calling.rst:132
msgid ""
"Here the result of the first task (4) will be sent to a new task that "
"adds 16 to the previous result, forming the expression :math:`(2 + 2) + "
"16 = 20`"
msgstr ""

#: ../../userguide/calling.rst:137
msgid ""
"You can also cause a callback to be applied if task raises an exception "
"(*errback*), but this behaves differently from a regular callback in that"
" it will be passed the id of the parent task, not the result. This is "
"because it may not always be possible to serialize the exception raised, "
"and so this way the error callback requires a result backend to be "
"enabled, and the task must retrieve the result of the task instead."
msgstr ""

#: ../../userguide/calling.rst:145
msgid "This is an example error callback:"
msgstr ""

#: ../../userguide/calling.rst:156
msgid "it can be added to the task using the ``link_error`` execution option:"
msgstr ""

#: ../../userguide/calling.rst:164
msgid ""
"In addition, both the ``link`` and ``link_error`` options can be "
"expressed as a list:"
msgstr ""

#: ../../userguide/calling.rst:171
msgid ""
"The callbacks/errbacks will then be called in order, and all callbacks "
"will be called with the return value of the parent task as a partial "
"argument."
msgstr ""

#: ../../userguide/calling.rst:178
msgid "On message"
msgstr ""

#: ../../userguide/calling.rst:180
msgid ""
"Celery supports catching all states changes by setting on_message "
"callback."
msgstr ""

#: ../../userguide/calling.rst:182
msgid ""
"For example for long-running tasks to send task progress you can do "
"something like this:"
msgstr ""

#: ../../userguide/calling.rst:203
msgid "Will generate output like this:"
msgstr ""

#: ../../userguide/calling.rst:228
msgid "ETA and Countdown"
msgstr ""

#: ../../userguide/calling.rst:230
msgid ""
"The ETA (estimated time of arrival) lets you set a specific date and time"
" that is the earliest time at which your task will be executed. "
"`countdown` is a shortcut to set ETA by seconds into the future."
msgstr ""

#: ../../userguide/calling.rst:240
msgid ""
"The task is guaranteed to be executed at some time *after* the specified "
"date and time, but not necessarily at that exact time. Possible reasons "
"for broken deadlines may include many items waiting in the queue, or "
"heavy network latency. To make sure your tasks are executed in a timely "
"manner you should monitor the queue for congestion. Use Munin, or similar"
" tools, to receive alerts, so appropriate action can be taken to ease the"
" workload. See :ref:`monitoring-munin`."
msgstr ""

#: ../../userguide/calling.rst:248
msgid ""
"While `countdown` is an integer, `eta` must be a "
":class:`~datetime.datetime` object, specifying an exact date and time "
"(including millisecond precision, and timezone information):"
msgstr ""

#: ../../userguide/calling.rst:262
msgid "Expiration"
msgstr ""

#: ../../userguide/calling.rst:264
msgid ""
"The `expires` argument defines an optional expiry time, either as seconds"
" after task publish, or a specific date and time using "
":class:`~datetime.datetime`:"
msgstr ""

#: ../../userguide/calling.rst:279
msgid ""
"When a worker receives an expired task it will mark the task as "
":state:`REVOKED` (:exc:`~@TaskRevokedError`)."
msgstr ""

#: ../../userguide/calling.rst:285
msgid "Message Sending Retry"
msgstr ""

#: ../../userguide/calling.rst:287
msgid ""
"Celery will automatically retry sending messages in the event of "
"connection failure, and retry behavior can be configured -- like how "
"often to retry, or a maximum number of retries -- or disabled all "
"together."
msgstr ""

#: ../../userguide/calling.rst:291
msgid ""
"To disable retry you can set the ``retry`` execution option to "
":const:`False`:"
msgstr ""

#: ../../userguide/calling.rst:302 ../../userguide/configuration.rst:140
msgid ":setting:`task_publish_retry`"
msgstr ""

#: ../../userguide/calling.rst:303 ../../userguide/configuration.rst:141
msgid ":setting:`task_publish_retry_policy`"
msgstr ""

#: ../../userguide/calling.rst:306
msgid "Retry Policy"
msgstr ""

#: ../../userguide/calling.rst:308
msgid ""
"A retry policy is a mapping that controls how retries behave, and can "
"contain the following keys:"
msgstr ""

#: ../../userguide/calling.rst:311
msgid "`max_retries`"
msgstr ""

#: ../../userguide/calling.rst:313
msgid ""
"Maximum number of retries before giving up, in this case the exception "
"that caused the retry to fail will be raised."
msgstr ""

#: ../../userguide/calling.rst:316
msgid "A value of :const:`None` means it will retry forever."
msgstr ""

#: ../../userguide/calling.rst:318
msgid "The default is to retry 3 times."
msgstr ""

#: ../../userguide/calling.rst:320
msgid "`interval_start`"
msgstr ""

#: ../../userguide/calling.rst:322
msgid ""
"Defines the number of seconds (float or integer) to wait between retries."
" Default is 0 (the first retry will be instantaneous)."
msgstr ""

#: ../../userguide/calling.rst:325
msgid "`interval_step`"
msgstr ""

#: ../../userguide/calling.rst:327
msgid ""
"On each consecutive retry this number will be added to the retry delay "
"(float or integer). Default is 0.2."
msgstr ""

#: ../../userguide/calling.rst:330
msgid "`interval_max`"
msgstr ""

#: ../../userguide/calling.rst:332
msgid ""
"Maximum number of seconds (float or integer) to wait between retries. "
"Default is 0.2."
msgstr ""

#: ../../userguide/calling.rst:335
msgid "For example, the default policy correlates to:"
msgstr ""

#: ../../userguide/calling.rst:346
msgid ""
"the maximum time spent retrying will be 0.4 seconds. It's set relatively "
"short by default because a connection failure could lead to a retry pile "
"effect if the broker connection is down -- For example, many web server "
"processes waiting to retry, blocking other incoming requests."
msgstr ""

#: ../../userguide/calling.rst:354
msgid "Connection Error Handling"
msgstr ""

#: ../../userguide/calling.rst:356
msgid ""
"When you send a task and the message transport connection is lost, or the"
" connection cannot be initiated, an "
":exc:`~kombu.exceptions.OperationalError` error will be raised:"
msgstr ""

#: ../../userguide/calling.rst:384
msgid ""
"If you have :ref:`retries <calling-retry>` enabled this will only happen "
"after retries are exhausted, or when disabled immediately."
msgstr ""

#: ../../userguide/calling.rst:387
msgid "You can handle this error too:"
msgstr ""

#: ../../userguide/calling.rst:402 ../../userguide/security.rst:96
msgid "Serializers"
msgstr ""

#: ../../userguide/configuration.rst:2822 ../../userguide/security.rst:5
msgid "Security"
msgstr ""

#: ../../userguide/calling.rst:406
msgid ""
"The pickle module allows for execution of arbitrary functions, please see"
" the :ref:`security guide <guide-security>`."
msgstr ""

#: ../../userguide/calling.rst:409
msgid ""
"Celery also comes with a special serializer that uses cryptography to "
"sign your messages."
msgstr ""

#: ../../userguide/calling.rst:412
msgid ""
"Data transferred between clients and workers needs to be serialized, so "
"every message in Celery has a ``content_type`` header that describes the "
"serialization method used to encode it."
msgstr ""

#: ../../userguide/calling.rst:416
msgid ""
"The default serializer is `JSON`, but you can change this using the "
":setting:`task_serializer` setting, or for each individual task, or even "
"per message."
msgstr ""

#: ../../userguide/calling.rst:420
msgid ""
"There's built-in support for `JSON`, :mod:`pickle`, `YAML` and "
"``msgpack``, and you can also add your own custom serializers by "
"registering them into the Kombu serializer registry"
msgstr ""

#: ../../userguide/calling.rst:426
msgid ""
":ref:`Message Serialization <kombu:guide-serialization>` in the Kombu "
"user guide."
msgstr ""

#: ../../userguide/calling.rst:429
msgid "Each option has its advantages and disadvantages."
msgstr ""

#: ../../userguide/calling.rst:447
msgid "json -- JSON is supported in many programming languages, is now"
msgstr ""

#: ../../userguide/calling.rst:432
msgid ""
"a standard part of Python (since 2.6), and is fairly fast to decode using"
" the modern Python libraries, such as :pypi:`simplejson`."
msgstr ""

#: ../../userguide/calling.rst:435
msgid ""
"The primary disadvantage to JSON is that it limits you to the following "
"data types: strings, Unicode, floats, Boolean, dictionaries, and lists. "
"Decimals and dates are notably missing."
msgstr ""

#: ../../userguide/calling.rst:439
#, python-format
msgid ""
"Binary data will be transferred using Base64 encoding, increasing the "
"size of the transferred data by 34% compared to an encoding format where "
"native binary types are supported."
msgstr ""

#: ../../userguide/calling.rst:443
msgid ""
"However, if your data fits inside the above constraints and you need "
"cross-language support, the default setting of JSON is probably your best"
" choice."
msgstr ""

#: ../../userguide/calling.rst:447
msgid "See http://json.org for more information."
msgstr ""

#: ../../userguide/calling.rst:455
msgid "pickle -- If you have no desire to support any language other than"
msgstr ""

#: ../../userguide/calling.rst:450
msgid ""
"Python, then using the pickle encoding will gain you the support of all "
"built-in Python data types (except class instances), smaller messages "
"when sending binary files, and a slight speedup over JSON processing."
msgstr ""

#: ../../userguide/calling.rst:455
msgid "See :mod:`pickle` for more information."
msgstr ""

#: ../../userguide/calling.rst:467
msgid "yaml -- YAML has many of the same characteristics as json,"
msgstr ""

#: ../../userguide/calling.rst:458
msgid ""
"except that it natively supports more data types (including dates, "
"recursive references, etc.)."
msgstr ""

#: ../../userguide/calling.rst:461
msgid ""
"However, the Python libraries for YAML are a good bit slower than the "
"libraries for JSON."
msgstr ""

#: ../../userguide/calling.rst:464
msgid ""
"If you need a more expressive set of data types and need to maintain "
"cross-language compatibility, then YAML may be a better fit than the "
"above."
msgstr ""

#: ../../userguide/calling.rst:467
msgid "See http://yaml.org/ for more information."
msgstr ""

#: ../../userguide/calling.rst:473
msgid "msgpack -- msgpack is a binary serialization format that's closer to JSON"
msgstr ""

#: ../../userguide/calling.rst:470
msgid ""
"in features. It's very young however, and support should be considered "
"experimental at this point."
msgstr ""

#: ../../userguide/calling.rst:473
msgid "See http://msgpack.org/ for more information."
msgstr ""

#: ../../userguide/calling.rst:475
msgid ""
"The encoding used is available as a message header, so the worker knows "
"how to deserialize any task. If you use a custom serializer, this "
"serializer must be available for the worker."
msgstr ""

#: ../../userguide/calling.rst:479
msgid ""
"The following order is used to decide the serializer used when sending a "
"task:"
msgstr ""

#: ../../userguide/calling.rst:482
msgid "The `serializer` execution option."
msgstr ""

#: ../../userguide/calling.rst:483
msgid "The :attr:`@-Task.serializer` attribute"
msgstr ""

#: ../../userguide/calling.rst:484
msgid "The :setting:`task_serializer` setting."
msgstr ""

#: ../../userguide/calling.rst:487
msgid "Example setting a custom serializer for a single task invocation:"
msgstr ""

#: ../../userguide/calling.rst:496
msgid "Compression"
msgstr ""

#: ../../userguide/calling.rst:498
msgid "Celery can compress messages using the following builtin schemes:"
msgstr ""

#: ../../userguide/calling.rst:500
msgid "`brotli`"
msgstr ""

#: ../../userguide/calling.rst:502
msgid ""
"brotli is optimized for the web, in particular small text documents. It "
"is most effective for serving static content such as fonts and html "
"pages."
msgstr ""

#: ../../userguide/calling.rst:506 ../../userguide/calling.rst:605
msgid "To use it, install Celery with:"
msgstr ""

#: ../../userguide/calling.rst:512
msgid "`bzip2`"
msgstr ""

#: ../../userguide/calling.rst:514
msgid ""
"bzip2 creates smaller files than gzip, but compression and decompression "
"speeds are noticeably slower than those of gzip."
msgstr ""

#: ../../userguide/calling.rst:517
msgid ""
"To use it, please ensure your Python executable was compiled with bzip2 "
"support."
msgstr ""

#: ../../userguide/calling.rst:520 ../../userguide/calling.rst:540
#: ../../userguide/calling.rst:560 ../../userguide/calling.rst:588
msgid "If you get the following :class:`ImportError`:"
msgstr ""

#: ../../userguide/calling.rst:529
msgid "it means that you should recompile your Python version with bzip2 support."
msgstr ""

#: ../../userguide/calling.rst:531
msgid "`gzip`"
msgstr ""

#: ../../userguide/calling.rst:533
msgid ""
"gzip is suitable for systems that require a small memory footprint, "
"making it ideal for systems with limited memory. It is often used to "
"generate files with the \".tar.gz\" extension."
msgstr ""

#: ../../userguide/calling.rst:537
msgid ""
"To use it, please ensure your Python executable was compiled with gzip "
"support."
msgstr ""

#: ../../userguide/calling.rst:549
msgid "it means that you should recompile your Python version with gzip support."
msgstr ""

#: ../../userguide/calling.rst:551
msgid "`lzma`"
msgstr ""

#: ../../userguide/calling.rst:553
msgid ""
"lzma provides a good compression ratio and executes with fast compression"
" and decompression speeds at the expense of higher memory usage."
msgstr ""

#: ../../userguide/calling.rst:557
msgid ""
"To use it, please ensure your Python executable was compiled with lzma "
"support and that your Python version is 3.3 and above."
msgstr ""

#: ../../userguide/calling.rst:569
msgid "it means that you should recompile your Python version with lzma support."
msgstr ""

#: ../../userguide/calling.rst:571
msgid "Alternatively, you can also install a backport using:"
msgstr ""

#: ../../userguide/calling.rst:577
msgid "`zlib`"
msgstr ""

#: ../../userguide/calling.rst:579
msgid ""
"zlib is an abstraction of the Deflate algorithm in library form which "
"includes support both for the gzip file format and a lightweight stream "
"format in its API. It is a crucial component of many software systems - "
"Linux kernel and Git VCS just to name a few."
msgstr ""

#: ../../userguide/calling.rst:585
msgid ""
"To use it, please ensure your Python executable was compiled with zlib "
"support."
msgstr ""

#: ../../userguide/calling.rst:597
msgid "it means that you should recompile your Python version with zlib support."
msgstr ""

#: ../../userguide/calling.rst:599
msgid "`zstd`"
msgstr ""

#: ../../userguide/calling.rst:601
msgid ""
"zstd targets real-time compression scenarios at zlib-level and better "
"compression ratios. It's backed by a very fast entropy stage, provided by"
" Huff0 and FSE library."
msgstr ""

#: ../../userguide/calling.rst:611
msgid ""
"You can also create your own compression schemes and register them in the"
" :func:`kombu compression registry <kombu.compression.register>`."
msgstr ""

#: ../../userguide/calling.rst:614
msgid ""
"The following order is used to decide the compression scheme used when "
"sending a task:"
msgstr ""

#: ../../userguide/calling.rst:617
msgid "The `compression` execution option."
msgstr ""

#: ../../userguide/calling.rst:618
msgid "The :attr:`@-Task.compression` attribute."
msgstr ""

#: ../../userguide/calling.rst:619
msgid "The :setting:`task_compression` attribute."
msgstr ""

#: ../../userguide/calling.rst:621
msgid "Example specifying the compression used when calling a task::"
msgstr ""

#: ../../userguide/calling.rst:628
msgid "Connections"
msgstr ""

msgid "Automatic Pool Support"
msgstr ""

#: ../../userguide/calling.rst:632
msgid ""
"Since version 2.3 there's support for automatic connection pools, so you "
"don't have to manually handle connections and publishers to reuse "
"connections."
msgstr ""

#: ../../userguide/calling.rst:636
msgid "The connection pool is enabled by default since version 2.5."
msgstr ""

#: ../../userguide/calling.rst:638
msgid "See the :setting:`broker_pool_limit` setting for more information."
msgstr ""

#: ../../userguide/calling.rst:640
msgid "You can handle the connection manually by creating a publisher:"
msgstr ""

#: ../../userguide/calling.rst:656
msgid "Though this particular example is much better expressed as a group:"
msgstr ""

#: ../../userguide/calling.rst:671
msgid "Routing options"
msgstr ""

#: ../../userguide/calling.rst:673
msgid "Celery can route tasks to different queues."
msgstr ""

#: ../../userguide/calling.rst:675
msgid ""
"Simple routing (name <-> name) is accomplished using the ``queue`` "
"option::"
msgstr ""

#: ../../userguide/calling.rst:679
msgid ""
"You can then assign workers to the ``priority.high`` queue by using the "
"workers :option:`-Q <celery worker -Q>` argument:"
msgstr ""

#: ../../userguide/calling.rst:688
msgid ""
"Hard-coding queue names in code isn't recommended, the best practice is "
"to use configuration routers (:setting:`task_routes`)."
msgstr ""

#: ../../userguide/calling.rst:691
msgid "To find out more about routing, please see :ref:`guide-routing`."
msgstr ""

#: ../../userguide/calling.rst:696
msgid "Results options"
msgstr ""

#: ../../userguide/calling.rst:698
msgid ""
"You can enable or disable result storage using the "
":setting:`task_ignore_result` setting or by using the ``ignore_result`` "
"option:"
msgstr ""

#: ../../userguide/calling.rst:713
msgid ""
"If you'd like to store additional metadata about the task in the result "
"backend set the :setting:`result_extended` setting to ``True``."
msgstr ""

#: ../../userguide/calling.rst:718
msgid "For more information on tasks, please see :ref:`guide-tasks`."
msgstr ""

#: ../../userguide/calling.rst:721
msgid "Advanced Options"
msgstr ""

#: ../../userguide/calling.rst:723
msgid ""
"These options are for advanced users who want to take use of AMQP's full "
"routing capabilities. Interested parties may read the :ref:`routing guide"
" <guide-routing>`."
msgstr ""

#: ../../userguide/calling.rst:727
msgid "exchange"
msgstr ""

#: ../../userguide/calling.rst:729
msgid ""
"Name of exchange (or a :class:`kombu.entity.Exchange`) to send the "
"message to."
msgstr ""

#: ../../userguide/calling.rst:732
msgid "routing_key"
msgstr ""

#: ../../userguide/calling.rst:734
msgid "Routing key used to determine."
msgstr ""

#: ../../userguide/calling.rst:736
msgid "priority"
msgstr ""

#: ../../userguide/calling.rst:738
msgid "A number between `0` and `255`, where `255` is the highest priority."
msgstr ""

#: ../../userguide/calling.rst:740
msgid "Supported by: RabbitMQ, Redis (priority reversed, 0 is highest)."
msgstr ""

#: ../../userguide/canvas.rst:5
msgid "Canvas: Designing Work-flows"
msgstr ""

#: ../../userguide/canvas.rst:16
msgid "Signatures"
msgstr ""

#: ../../userguide/canvas.rst:20
msgid ""
"You just learned how to call a task using the tasks ``delay`` method in "
"the :ref:`calling <guide-calling>` guide, and this is often all you need,"
" but sometimes you may want to pass the signature of a task invocation to"
" another process or as an argument to another function."
msgstr ""

#: ../../userguide/canvas.rst:25
msgid ""
"A :func:`~celery.signature` wraps the arguments, keyword arguments, and "
"execution options of a single task invocation in a way such that it can "
"be passed to functions or even serialized and sent across the wire."
msgstr ""

#: ../../userguide/canvas.rst:29
msgid "You can create a signature for the ``add`` task using its name like this:"
msgstr ""

#: ../../userguide/canvas.rst:37
msgid ""
"This task has a signature of arity 2 (two arguments): ``(2, 2)``, and "
"sets the countdown execution option to 10."
msgstr ""

#: ../../userguide/canvas.rst:40
msgid "or you can create one using the task's ``signature`` method:"
msgstr ""

#: ../../userguide/canvas.rst:47
msgid "There's also a shortcut using star arguments:"
msgstr ""

#: ../../userguide/canvas.rst:54
msgid "Keyword arguments are also supported:"
msgstr ""

#: ../../userguide/canvas.rst:61
msgid "From any signature instance you can inspect the different fields:"
msgstr ""

#: ../../userguide/canvas.rst:73
msgid ""
"It supports the \"Calling API\" of ``delay``, ``apply_async``, etc., "
"including being called directly (``__call__``)."
msgstr ""

#: ../../userguide/canvas.rst:76
msgid "Calling the signature will execute the task inline in the current process:"
msgstr ""

#: ../../userguide/canvas.rst:85
msgid ""
"``delay`` is our beloved shortcut to ``apply_async`` taking star-"
"arguments:"
msgstr ""

#: ../../userguide/canvas.rst:93
msgid ""
"``apply_async`` takes the same arguments as the :meth:`Task.apply_async "
"<@Task.apply_async>` method:"
msgstr ""

#: ../../userguide/canvas.rst:104
msgid ""
"You can't define options with :meth:`~@Task.s`, but a chaining ``set`` "
"call takes care of that:"
msgstr ""

#: ../../userguide/canvas.rst:113
msgid "Partials"
msgstr ""

#: ../../userguide/canvas.rst:115
msgid "With a signature, you can execute the task in a worker:"
msgstr ""

#: ../../userguide/canvas.rst:122
msgid "Or you can call it directly in the current process:"
msgstr ""

#: ../../userguide/canvas.rst:129
msgid ""
"Specifying additional args, kwargs, or options to "
"``apply_async``/``delay`` creates partials:"
msgstr ""

#: ../../userguide/canvas.rst:132
msgid "Any arguments added will be prepended to the args in the signature:"
msgstr ""

#: ../../userguide/canvas.rst:140
msgid ""
"Any keyword arguments added will be merged with the kwargs in the "
"signature, with the new keyword arguments taking precedence:"
msgstr ""

#: ../../userguide/canvas.rst:149
msgid ""
"Any options added will be merged with the options in the signature, with "
"the new options taking precedence:"
msgstr ""

#: ../../userguide/canvas.rst:157
msgid "You can also clone signatures to create derivatives:"
msgstr ""

#: ../../userguide/canvas.rst:168
msgid "Immutability"
msgstr ""

#: ../../userguide/canvas.rst:172
msgid ""
"Partials are meant to be used with callbacks, any tasks linked, or chord "
"callbacks will be applied with the result of the parent task. Sometimes "
"you want to specify a callback that doesn't take additional arguments, "
"and in that case you can set the signature to be immutable:"
msgstr ""

#: ../../userguide/canvas.rst:182
msgid "The ``.si()`` shortcut can also be used to create immutable signatures:"
msgstr ""

#: ../../userguide/canvas.rst:188
msgid ""
"Only the execution options can be set when a signature is immutable, so "
"it's not possible to call the signature with partial args/kwargs."
msgstr ""

#: ../../userguide/canvas.rst:193
msgid ""
"In this tutorial I sometimes use the prefix operator `~` to signatures. "
"You probably shouldn't use it in your production code, but it's a handy "
"shortcut when experimenting in the Python shell:"
msgstr ""

#: ../../userguide/canvas.rst:208
msgid "Callbacks"
msgstr ""

#: ../../userguide/canvas.rst:212
msgid ""
"Callbacks can be added to any task using the ``link`` argument to "
"``apply_async``:"
msgstr ""

#: ../../userguide/canvas.rst:219
msgid ""
"The callback will only be applied if the task exited successfully, and it"
" will be applied with the return value of the parent task as argument."
msgstr ""

#: ../../userguide/canvas.rst:222
msgid ""
"As I mentioned earlier, any arguments you add to a signature, will be "
"prepended to the arguments specified by the signature itself!"
msgstr ""

#: ../../userguide/canvas.rst:225
msgid "If you have the signature:"
msgstr ""

#: ../../userguide/canvas.rst:231
msgid "then `sig.delay(result)` becomes:"
msgstr ""

#: ../../userguide/canvas.rst:237
msgid "..."
msgstr ""

#: ../../userguide/canvas.rst:239
msgid "Now let's call our ``add`` task with a callback using partial arguments:"
msgstr ""

#: ../../userguide/canvas.rst:246
msgid ""
"As expected this will first launch one task calculating :math:`2 + 2`, "
"then another task calculating :math:`4 + 8`."
msgstr ""

#: ../../userguide/canvas.rst:250
msgid "The Primitives"
msgstr ""

#: ../../userguide/canvas.rst:256
msgid "``group``"
msgstr ""

#: ../../userguide/canvas.rst:258
msgid ""
"The group primitive is a signature that takes a list of tasks that should"
" be applied in parallel."
msgstr ""

#: ../../userguide/canvas.rst:261
msgid "``chain``"
msgstr ""

#: ../../userguide/canvas.rst:263
msgid ""
"The chain primitive lets us link together signatures so that one is "
"called after the other, essentially forming a *chain* of callbacks."
msgstr ""

#: ../../userguide/canvas.rst:266
msgid "``chord``"
msgstr ""

#: ../../userguide/canvas.rst:268
msgid ""
"A chord is just like a group but with a callback. A chord consists of a "
"header group and a body,  where the body is a task that should execute "
"after all of the tasks in the header are complete."
msgstr ""

#: ../../userguide/canvas.rst:272
msgid "``map``"
msgstr ""

#: ../../userguide/canvas.rst:274
msgid ""
"The map primitive works like the built-in ``map`` function, but creates a"
" temporary task where a list of arguments is applied to the task. For "
"example, ``task.map([1, 2])`` -- results in a single task being called, "
"applying the arguments in order to the task function so that the result "
"is:"
msgstr ""

#: ../../userguide/canvas.rst:284
msgid "``starmap``"
msgstr ""

#: ../../userguide/canvas.rst:286
msgid ""
"Works exactly like map except the arguments are applied as ``*args``. For"
" example ``add.starmap([(2, 2), (4, 4)])`` results in a single task "
"calling:"
msgstr ""

#: ../../userguide/canvas.rst:294
msgid "``chunks``"
msgstr ""

#: ../../userguide/canvas.rst:296
msgid ""
"Chunking splits a long list of arguments into parts, for example the "
"operation:"
msgstr ""

#: ../../userguide/canvas.rst:304
msgid ""
"will split the list of items into chunks of 10, resulting in 100 tasks "
"(each processing 10 items in sequence)."
msgstr ""

#: ../../userguide/canvas.rst:308
msgid ""
"The primitives are also signature objects themselves, so that they can be"
" combined in any number of ways to compose complex work-flows."
msgstr ""

#: ../../userguide/canvas.rst:311
msgid "Here's some examples:"
msgstr ""

#: ../../userguide/canvas.rst:313
msgid "Simple chain"
msgstr ""

#: ../../userguide/canvas.rst:315
msgid ""
"Here's a simple chain, the first task executes passing its return value "
"to the next task in the chain, and so on."
msgstr ""

#: ../../userguide/canvas.rst:327
msgid "This can also be written using pipes:"
msgstr ""

#: ../../userguide/canvas.rst:334
msgid "Immutable signatures"
msgstr ""

#: ../../userguide/canvas.rst:336
msgid ""
"Signatures can be partial so arguments can be added to the existing "
"arguments, but you may not always want that, for example if you don't "
"want the result of the previous task in a chain."
msgstr ""

#: ../../userguide/canvas.rst:340
msgid ""
"In that case you can mark the signature as immutable, so that the "
"arguments cannot be changed:"
msgstr ""

#: ../../userguide/canvas.rst:347
msgid ""
"There's also a ``.si()`` shortcut for this, and this is the preffered way"
" of creating signatures:"
msgstr ""

#: ../../userguide/canvas.rst:354
msgid "Now you can create a chain of independent tasks instead:"
msgstr ""

#: ../../userguide/canvas.rst:368
msgid "Simple group"
msgstr ""

#: ../../userguide/canvas.rst:370
msgid "You can easily create a group of tasks to execute in parallel:"
msgstr ""

#: ../../userguide/canvas.rst:379
msgid "Simple chord"
msgstr ""

#: ../../userguide/canvas.rst:381
msgid ""
"The chord primitive enables us to add a callback to be called when all of"
" the tasks in a group have finished executing.  This is often required "
"for algorithms that aren't *embarrassingly parallel*:"
msgstr ""

#: ../../userguide/canvas.rst:392
msgid ""
"The above example creates 10 task that all start in parallel, and when "
"all of them are complete the return values are combined into a list and "
"sent to the ``xsum`` task."
msgstr ""

#: ../../userguide/canvas.rst:396
msgid ""
"The body of a chord can also be immutable, so that the return value of "
"the group isn't passed on to the callback:"
msgstr ""

#: ../../userguide/canvas.rst:404
msgid ""
"Note the use of ``.si`` above; this creates an immutable signature, "
"meaning any new arguments passed (including to return value of the "
"previous task) will be ignored."
msgstr ""

#: ../../userguide/canvas.rst:408
msgid "Blow your mind by combining"
msgstr ""

#: ../../userguide/canvas.rst:410
msgid "Chains can be partial too:"
msgstr ""

#: ../../userguide/canvas.rst:421
msgid "this means that you can combine chains:"
msgstr ""

#: ../../userguide/canvas.rst:432
msgid ""
"Chaining a group together with another task will automatically upgrade it"
" to be a chord:"
msgstr ""

#: ../../userguide/canvas.rst:442
msgid ""
"Groups and chords accepts partial arguments too, so in a chain the return"
" value of the previous task is forwarded to all tasks in the group:"
msgstr ""

#: ../../userguide/canvas.rst:457
msgid ""
"If you don't want to forward arguments to the group then you can make the"
" signatures in the group immutable:"
msgstr ""

#: ../../userguide/canvas.rst:483
msgid "Chains"
msgstr ""

#: ../../userguide/canvas.rst:487
msgid ""
"Tasks can be linked together: the linked task is called when the task "
"returns successfully:"
msgstr ""

#: ../../userguide/canvas.rst:496
msgid ""
"The linked task will be applied with the result of its parent task as the"
" first argument. In the above case where the result was 64, this will "
"result in ``mul(4, 16)``."
msgstr ""

#: ../../userguide/canvas.rst:500
msgid ""
"The results will keep track of any subtasks called by the original task, "
"and this can be accessed from the result instance:"
msgstr ""

#: ../../userguide/canvas.rst:511
msgid ""
"The result instance also has a :meth:`~@AsyncResult.collect` method that "
"treats the result as a graph, enabling you to iterate over the results:"
msgstr ""

#: ../../userguide/canvas.rst:521
msgid ""
"By default :meth:`~@AsyncResult.collect` will raise an "
":exc:`~@IncompleteStream` exception if the graph isn't fully formed (one "
"of the tasks hasn't completed yet), but you can get an intermediate "
"representation of the graph too:"
msgstr ""

#: ../../userguide/canvas.rst:532
msgid ""
"You can link together as many tasks as you like, and signatures can be "
"linked too:"
msgstr ""

#: ../../userguide/canvas.rst:541
msgid "You can also add *error callbacks* using the `on_error` method:"
msgstr ""

#: ../../userguide/canvas.rst:547
msgid ""
"This will result in the following ``.apply_async`` call when the "
"signature is applied:"
msgstr ""

#: ../../userguide/canvas.rst:554
msgid ""
"The worker won't actually call the errback as a task, but will instead "
"call the errback function directly so that the raw request, exception and"
" traceback objects can be passed to it."
msgstr ""

#: ../../userguide/canvas.rst:558
msgid "Here's an example errback:"
msgstr ""

#: ../../userguide/canvas.rst:574
msgid ""
"To make it even easier to link tasks together there's a special signature"
" called :class:`~celery.chain` that lets you chain tasks together:"
msgstr ""

#: ../../userguide/canvas.rst:588
msgid ""
"Calling the chain will call the tasks in the current process and return "
"the result of the last task in the chain:"
msgstr ""

#: ../../userguide/canvas.rst:597
msgid ""
"It also sets ``parent`` attributes so that you can work your way up the "
"chain to get intermediate results:"
msgstr ""

#: ../../userguide/canvas.rst:612
msgid "Chains can also be made using the ``|`` (pipe) operator:"
msgstr ""

#: ../../userguide/canvas.rst:619
msgid "Graphs"
msgstr ""

#: ../../userguide/canvas.rst:621
msgid ""
"In addition you can work with the result graph as a "
":class:`~celery.utils.graph.DependencyGraph`:"
msgstr ""

#: ../../userguide/canvas.rst:635
msgid "You can even convert these graphs to *dot* format:"
msgstr ""

#: ../../userguide/canvas.rst:643
msgid "and create images:"
msgstr ""

#: ../../userguide/canvas.rst:654
msgid "Groups"
msgstr ""

#: ../../userguide/canvas.rst:658
msgid "A group can be used to execute several tasks in parallel."
msgstr ""

#: ../../userguide/canvas.rst:660
msgid "The :class:`~celery.group` function takes a list of signatures:"
msgstr ""

#: ../../userguide/canvas.rst:670
msgid ""
"If you **call** the group, the tasks will be applied one after another in"
" the current process, and a :class:`~celery.result.GroupResult` instance "
"is returned that can be used to keep track of the results, or tell how "
"many tasks are ready and so on:"
msgstr ""

#: ../../userguide/canvas.rst:682
msgid "Group also supports iterators:"
msgstr ""

#: ../../userguide/canvas.rst:688
msgid ""
"A group is a signature object, so it can be used in combination with "
"other signatures."
msgstr ""

#: ../../userguide/canvas.rst:692
msgid "Group Results"
msgstr ""

#: ../../userguide/canvas.rst:694
msgid ""
"The group task returns a special result too, this result works just like "
"normal task results, except that it works on the group as a whole:"
msgstr ""

#: ../../userguide/canvas.rst:720
msgid ""
"The :class:`~celery.result.GroupResult` takes a list of "
":class:`~celery.result.AsyncResult` instances and operates on them as if "
"it was a single task."
msgstr ""

#: ../../userguide/canvas.rst:724
msgid "It supports the following operations:"
msgstr ""

#: ../../userguide/canvas.rst:726
msgid ":meth:`~celery.result.GroupResult.successful`"
msgstr ""

#: ../../userguide/canvas.rst:728
msgid ""
"Return :const:`True` if all of the subtasks finished successfully (e.g., "
"didn't raise an exception)."
msgstr ""

#: ../../userguide/canvas.rst:731
msgid ":meth:`~celery.result.GroupResult.failed`"
msgstr ""

#: ../../userguide/canvas.rst:733
msgid "Return :const:`True` if any of the subtasks failed."
msgstr ""

#: ../../userguide/canvas.rst:735
msgid ":meth:`~celery.result.GroupResult.waiting`"
msgstr ""

#: ../../userguide/canvas.rst:737
msgid "Return :const:`True` if any of the subtasks isn't ready yet."
msgstr ""

#: ../../userguide/canvas.rst:740
msgid ":meth:`~celery.result.GroupResult.ready`"
msgstr ""

#: ../../userguide/canvas.rst:742
msgid "Return :const:`True` if all of the subtasks are ready."
msgstr ""

#: ../../userguide/canvas.rst:745
msgid ":meth:`~celery.result.GroupResult.completed_count`"
msgstr ""

#: ../../userguide/canvas.rst:747
msgid "Return the number of completed subtasks."
msgstr ""

#: ../../userguide/canvas.rst:749
msgid ":meth:`~celery.result.GroupResult.revoke`"
msgstr ""

#: ../../userguide/canvas.rst:751
msgid "Revoke all of the subtasks."
msgstr ""

#: ../../userguide/canvas.rst:753
msgid ":meth:`~celery.result.GroupResult.join`"
msgstr ""

#: ../../userguide/canvas.rst:755
msgid ""
"Gather the results of all subtasks and return them in the same order as "
"they were called (as a list)."
msgstr ""

#: ../../userguide/canvas.rst:761
msgid "Chords"
msgstr ""

#: ../../userguide/canvas.rst:767
msgid ""
"Tasks used within a chord must *not* ignore their results. If the result "
"backend is disabled for *any* task (header or body) in your chord you "
"should read \":ref:`chord-important-notes`.\" Chords are not currently "
"supported with the RPC result backend."
msgstr ""

#: ../../userguide/canvas.rst:773
msgid ""
"A chord is a task that only executes after all of the tasks in a group "
"have finished executing."
msgstr ""

#: ../../userguide/canvas.rst:777
msgid ""
"Let's calculate the sum of the expression :math:`1 + 1 + 2 + 2 + 3 + 3 "
"... n + n` up to a hundred digits."
msgstr ""

#: ../../userguide/canvas.rst:780
msgid ""
"First you need two tasks, :func:`add` and :func:`tsum` (:func:`sum` is "
"already a standard function):"
msgstr ""

#: ../../userguide/canvas.rst:794
msgid ""
"Now you can use a chord to calculate each addition step in parallel, and "
"then get the sum of the resulting numbers:"
msgstr ""

#: ../../userguide/canvas.rst:807
msgid ""
"This is obviously a very contrived example, the overhead of messaging and"
" synchronization makes this a lot slower than its Python counterpart:"
msgstr ""

#: ../../userguide/canvas.rst:814
msgid ""
"The synchronization step is costly, so you should avoid using chords as "
"much as possible. Still, the chord is a powerful primitive to have in "
"your toolbox as synchronization is a required step for many parallel "
"algorithms."
msgstr ""

#: ../../userguide/canvas.rst:818
msgid "Let's break the chord expression down:"
msgstr ""

#: ../../userguide/canvas.rst:828
msgid ""
"Remember, the callback can only be executed after all of the tasks in the"
" header have returned. Each step in the header is executed as a task, in "
"parallel, possibly on different nodes. The callback is then applied with "
"the return value of each task in the header. The task id returned by "
":meth:`chord` is the id of the callback, so you can wait for it to "
"complete and get the final return value (but remember to :ref:`never have"
" a task wait for other tasks <task-synchronous-subtasks>`)"
msgstr ""

#: ../../userguide/canvas.rst:839
msgid "Error handling"
msgstr ""

#: ../../userguide/canvas.rst:841
msgid "So what happens if one of the tasks raises an exception?"
msgstr ""

#: ../../userguide/canvas.rst:843
msgid ""
"The chord callback result will transition to the failure state, and the "
"error is set to the :exc:`~@ChordError` exception:"
msgstr ""

#: ../../userguide/canvas.rst:863
msgid ""
"While the traceback may be different depending on the result backend "
"used, you can see that the error description includes the id of the task "
"that failed and a string representation of the original exception. You "
"can also find the original traceback in ``result.traceback``."
msgstr ""

#: ../../userguide/canvas.rst:868
msgid ""
"Note that the rest of the tasks will still execute, so the third task "
"(``add.s(8, 8)``) is still executed even though the middle task failed. "
"Also the :exc:`~@ChordError` only shows the task that failed first (in "
"time): it doesn't respect the ordering of the header group."
msgstr ""

#: ../../userguide/canvas.rst:873
msgid ""
"To perform an action when a chord fails you can therefore attach an "
"errback to the chord callback:"
msgstr ""

#: ../../userguide/canvas.rst:890
msgid "Important Notes"
msgstr ""

#: ../../userguide/canvas.rst:892
msgid ""
"Tasks used within a chord must *not* ignore their results. In practice "
"this means that you must enable a :const:`result_backend` in order to use"
" chords. Additionally, if :const:`task_ignore_result` is set to "
":const:`True` in your configuration, be sure that the individual tasks to"
" be used within the chord are defined with :const:`ignore_result=False`. "
"This applies to both Task subclasses and decorated tasks."
msgstr ""

#: ../../userguide/canvas.rst:899
msgid "Example Task subclass:"
msgstr ""

#: ../../userguide/canvas.rst:907
msgid "Example decorated task:"
msgstr ""

#: ../../userguide/canvas.rst:915
msgid ""
"By default the synchronization step is implemented by having a recurring "
"task poll the completion of the group every second, calling the signature"
" when ready."
msgstr ""

#: ../../userguide/canvas.rst:919
msgid "Example implementation:"
msgstr ""

#: ../../userguide/canvas.rst:932
msgid ""
"This is used by all result backends except Redis and Memcached: they "
"increment a counter after each task in the header, then applies the "
"callback when the counter exceeds the number of tasks in the set."
msgstr ""

#: ../../userguide/canvas.rst:936
msgid ""
"The Redis and Memcached approach is a much better solution, but not "
"easily implemented in other backends (suggestions welcome!)."
msgstr ""

#: ../../userguide/canvas.rst:941
msgid ""
"Chords don't properly work with Redis before version 2.2; you'll need to "
"upgrade to at least redis-server 2.2 to use them."
msgstr ""

#: ../../userguide/canvas.rst:946
msgid ""
"If you're using chords with the Redis result backend and also overriding "
"the :meth:`Task.after_return` method, you need to make sure to call the "
"super method or else the chord callback won't be applied."
msgstr ""

#: ../../userguide/canvas.rst:959
msgid "Map & Starmap"
msgstr ""

#: ../../userguide/canvas.rst:961
msgid ""
":class:`~celery.map` and :class:`~celery.starmap` are built-in tasks that"
" calls the task for every element in a sequence."
msgstr ""

#: ../../userguide/canvas.rst:964
msgid "They differ from group in that"
msgstr ""

#: ../../userguide/canvas.rst:966
msgid "only one task message is sent"
msgstr ""

#: ../../userguide/canvas.rst:968
msgid "the operation is sequential."
msgstr ""

#: ../../userguide/canvas.rst:970
msgid "For example using ``map``:"
msgstr ""

#: ../../userguide/canvas.rst:979 ../../userguide/canvas.rst:994
msgid "is the same as having a task doing:"
msgstr ""

#: ../../userguide/canvas.rst:987
msgid "and using ``starmap``:"
msgstr ""

#: ../../userguide/canvas.rst:1002
msgid ""
"Both ``map`` and ``starmap`` are signature objects, so they can be used "
"as other signatures and combined in groups etc., for example to call the "
"starmap after 10 seconds:"
msgstr ""

#: ../../userguide/canvas.rst:1013
msgid "Chunks"
msgstr ""

#: ../../userguide/canvas.rst:1015
msgid ""
"Chunking lets you divide an iterable of work into pieces, so that if you "
"have one million objects, you can create 10 tasks with hundred thousand "
"objects each."
msgstr ""

#: ../../userguide/canvas.rst:1019
msgid ""
"Some may worry that chunking your tasks results in a degradation of "
"parallelism, but this is rarely true for a busy cluster and in practice "
"since you're avoiding the overhead  of messaging it may considerably "
"increase performance."
msgstr ""

#: ../../userguide/canvas.rst:1024
msgid "To create a chunks signature you can use :meth:`@Task.chunks`:"
msgstr ""

#: ../../userguide/canvas.rst:1030
msgid ""
"As with :class:`~celery.group` the act of sending the messages for the "
"chunks will happen in the current process when called:"
msgstr ""

#: ../../userguide/canvas.rst:1050
msgid ""
"while calling ``.apply_async`` will create a dedicated task so that the "
"individual tasks are applied in a worker instead:"
msgstr ""

#: ../../userguide/canvas.rst:1058
msgid "You can also convert chunks to a group:"
msgstr ""

#: ../../userguide/canvas.rst:1064
msgid "and with the group skew the countdown of each task by increments of one:"
msgstr ""

#: ../../userguide/canvas.rst:1071
msgid ""
"This means that the first task will have a countdown of one second, the "
"second task a countdown of two seconds, and so on."
msgstr ""

#: ../../userguide/concurrency/eventlet.rst:5
msgid "Concurrency with Eventlet"
msgstr ""

#: ../../userguide/concurrency/eventlet.rst:10
#: ../../userguide/monitoring.rst:11 ../../userguide/optimizing.rst:8
#: ../../userguide/periodic-tasks.rst:11 ../../userguide/security.rst:11
#: celery.contrib.sphinx:4 of
msgid "Introduction"
msgstr ""

#: ../../userguide/concurrency/eventlet.rst:12
msgid ""
"The `Eventlet`_ homepage describes it as a concurrent networking library "
"for Python that allows you to change how you run your code, not how you "
"write it."
msgstr ""

#: ../../userguide/concurrency/eventlet.rst:16
msgid ""
"It uses `epoll(4)`_ or `libevent`_ for `highly scalable non-blocking "
"I/O`_."
msgstr ""

#: ../../userguide/concurrency/eventlet.rst:18
msgid ""
"`Coroutines`_ ensure that the developer uses a blocking style of "
"programming that's similar to threading, but provide the benefits of non-"
"blocking I/O."
msgstr ""

#: ../../userguide/concurrency/eventlet.rst:21
msgid ""
"The event dispatch is implicit: meaning you can easily use Eventlet from "
"the Python interpreter, or as a small part of a larger application."
msgstr ""

#: ../../userguide/concurrency/eventlet.rst:25
msgid ""
"Celery supports Eventlet as an alternative execution pool implementation "
"and in some cases superior to prefork. However, you need to ensure one "
"task doesn't block the event loop too long. Generally, CPU-bound "
"operations don't go well with Evenetlet. Also note that some libraries, "
"usually with C extensions, cannot be monkeypatched and therefore cannot "
"benefit from using Eventlet. Please refer to their documentation if you "
"are not sure. For example, pylibmc does not allow cooperation with "
"Eventlet but psycopg2 does when both of them are libraries with C "
"extensions."
msgstr ""

#: ../../userguide/concurrency/eventlet.rst:35
msgid ""
"The prefork pool can take use of multiple processes, but how many is "
"often limited to a few processes per CPU. With Eventlet you can "
"efficiently spawn hundreds, or thousands of green threads. In an informal"
" test with a feed hub system the Eventlet pool could fetch and process "
"hundreds of feeds every second, while the prefork pool spent 14 seconds "
"processing 100 feeds. Note that this is one of the applications async I/O"
" is especially good at (asynchronous HTTP requests). You may want a mix "
"of both Eventlet and prefork workers, and route tasks according to "
"compatibility or what works best."
msgstr ""

#: ../../userguide/concurrency/eventlet.rst:46
msgid "Enabling Eventlet"
msgstr ""

#: ../../userguide/concurrency/eventlet.rst:48
msgid ""
"You can enable the Eventlet pool by using the :option:`celery worker -P` "
"worker option."
msgstr ""

#: ../../userguide/concurrency/eventlet.rst:58
msgid "Examples"
msgstr ""

#: ../../userguide/concurrency/eventlet.rst:60
msgid ""
"See the `Eventlet examples`_ directory in the Celery distribution for "
"some examples taking use of Eventlet support."
msgstr ""

#: ../../userguide/concurrency/index.rst:5 ../../userguide/workers.rst:216
msgid "Concurrency"
msgstr ""

#: ../../userguide/concurrency/index.rst ../../userguide/index.rst
msgid "Release"
msgstr ""

#: ../../userguide/concurrency/index.rst:7 ../../userguide/index.rst:7
msgid "|version|"
msgstr ""

#: ../../userguide/concurrency/index.rst ../../userguide/index.rst
msgid "Date"
msgstr ""

#: ../../userguide/concurrency/index.rst:8 ../../userguide/index.rst:8
msgid "|today|"
msgstr ""

#: ../../userguide/configuration.rst:5
msgid "Configuration and defaults"
msgstr ""

#: ../../userguide/configuration.rst:7
msgid "This document describes the configuration options available."
msgstr ""

#: ../../userguide/configuration.rst:9
msgid ""
"If you're using the default loader, you must create the "
":file:`celeryconfig.py` module and make sure it's available on the Python"
" path."
msgstr ""

#: ../../userguide/configuration.rst:19
msgid "Example configuration file"
msgstr ""

#: ../../userguide/configuration.rst:21
msgid ""
"This is an example configuration file to get you started. It should "
"contain all you need to run a basic Celery set-up."
msgstr ""

#: ../../userguide/configuration.rst:41
msgid "New lowercase settings"
msgstr ""

#: ../../userguide/configuration.rst:43
msgid "Version 4.0 introduced new lower case settings and setting organization."
msgstr ""

#: ../../userguide/configuration.rst:45
msgid ""
"The major difference between previous versions, apart from the lower case"
" names, are the renaming of some prefixes, like ``celerybeat_`` to "
"``beat_``, ``celeryd_`` to ``worker_``, and most of the top level "
"``celery_`` settings have been moved into a new  ``task_`` prefix."
msgstr ""

#: ../../userguide/configuration.rst:52
msgid ""
"Celery will still be able to read old configuration files, so there's no "
"rush in moving to the new settings format. Furthermore, we provide the "
"``celery upgrade`` command that should handle plenty of cases (including "
":ref:`Django <latentcall-django-admonition>`)."
msgstr ""

#: ../../userguide/configuration.rst:59
msgid "**Setting name**"
msgstr ""

#: ../../userguide/configuration.rst:59
msgid "**Replace with**"
msgstr ""

#: ../../userguide/configuration.rst:61
msgid "``CELERY_ACCEPT_CONTENT``"
msgstr ""

#: ../../userguide/configuration.rst:61
msgid ":setting:`accept_content`"
msgstr ""

#: ../../userguide/configuration.rst:62
msgid "``CELERY_ENABLE_UTC``"
msgstr ""

#: ../../userguide/configuration.rst:62
msgid ":setting:`enable_utc`"
msgstr ""

#: ../../userguide/configuration.rst:63
msgid "``CELERY_IMPORTS``"
msgstr ""

#: ../../userguide/configuration.rst:63
msgid ":setting:`imports`"
msgstr ""

#: ../../userguide/configuration.rst:64
msgid "``CELERY_INCLUDE``"
msgstr ""

#: ../../userguide/configuration.rst:64
msgid ":setting:`include`"
msgstr ""

#: ../../userguide/configuration.rst:65
msgid "``CELERY_TIMEZONE``"
msgstr ""

#: ../../userguide/configuration.rst:65
msgid ":setting:`timezone`"
msgstr ""

#: ../../userguide/configuration.rst:66
msgid "``CELERYBEAT_MAX_LOOP_INTERVAL``"
msgstr ""

#: ../../userguide/configuration.rst:66
msgid ":setting:`beat_max_loop_interval`"
msgstr ""

#: ../../userguide/configuration.rst:67
msgid "``CELERYBEAT_SCHEDULE``"
msgstr ""

#: ../../userguide/configuration.rst:67
msgid ":setting:`beat_schedule`"
msgstr ""

#: ../../userguide/configuration.rst:68
msgid "``CELERYBEAT_SCHEDULER``"
msgstr ""

#: ../../userguide/configuration.rst:68
msgid ":setting:`beat_scheduler`"
msgstr ""

#: ../../userguide/configuration.rst:69
msgid "``CELERYBEAT_SCHEDULE_FILENAME``"
msgstr ""

#: ../../userguide/configuration.rst:69
msgid ":setting:`beat_schedule_filename`"
msgstr ""

#: ../../userguide/configuration.rst:70
msgid "``CELERYBEAT_SYNC_EVERY``"
msgstr ""

#: ../../userguide/configuration.rst:70
msgid ":setting:`beat_sync_every`"
msgstr ""

#: ../../userguide/configuration.rst:71
msgid "``BROKER_URL``"
msgstr ""

#: ../../userguide/configuration.rst:71
msgid ":setting:`broker_url`"
msgstr ""

#: ../../userguide/configuration.rst:72
msgid "``BROKER_TRANSPORT``"
msgstr ""

#: ../../userguide/configuration.rst:72
msgid ":setting:`broker_transport`"
msgstr ""

#: ../../userguide/configuration.rst:73
msgid "``BROKER_TRANSPORT_OPTIONS``"
msgstr ""

#: ../../userguide/configuration.rst:73
msgid ":setting:`broker_transport_options`"
msgstr ""

#: ../../userguide/configuration.rst:74
msgid "``BROKER_CONNECTION_TIMEOUT``"
msgstr ""

#: ../../userguide/configuration.rst:74
msgid ":setting:`broker_connection_timeout`"
msgstr ""

#: ../../userguide/configuration.rst:75
msgid "``BROKER_CONNECTION_RETRY``"
msgstr ""

#: ../../userguide/configuration.rst:75
msgid ":setting:`broker_connection_retry`"
msgstr ""

#: ../../userguide/configuration.rst:76
msgid "``BROKER_CONNECTION_MAX_RETRIES``"
msgstr ""

#: ../../userguide/configuration.rst:76
msgid ":setting:`broker_connection_max_retries`"
msgstr ""

#: ../../userguide/configuration.rst:77
msgid "``BROKER_FAILOVER_STRATEGY``"
msgstr ""

#: ../../userguide/configuration.rst:77
msgid ":setting:`broker_failover_strategy`"
msgstr ""

#: ../../userguide/configuration.rst:78
msgid "``BROKER_HEARTBEAT``"
msgstr ""

#: ../../userguide/configuration.rst:78
msgid ":setting:`broker_heartbeat`"
msgstr ""

#: ../../userguide/configuration.rst:79
msgid "``BROKER_LOGIN_METHOD``"
msgstr ""

#: ../../userguide/configuration.rst:79
msgid ":setting:`broker_login_method`"
msgstr ""

#: ../../userguide/configuration.rst:80
msgid "``BROKER_POOL_LIMIT``"
msgstr ""

#: ../../userguide/configuration.rst:80
msgid ":setting:`broker_pool_limit`"
msgstr ""

#: ../../userguide/configuration.rst:81
msgid "``BROKER_USE_SSL``"
msgstr ""

#: ../../userguide/configuration.rst:81
msgid ":setting:`broker_use_ssl`"
msgstr ""

#: ../../userguide/configuration.rst:82
msgid "``CELERY_CACHE_BACKEND``"
msgstr ""

#: ../../userguide/configuration.rst:82
msgid ":setting:`cache_backend`"
msgstr ""

#: ../../userguide/configuration.rst:83
msgid "``CELERY_CACHE_BACKEND_OPTIONS``"
msgstr ""

#: ../../userguide/configuration.rst:83
msgid ":setting:`cache_backend_options`"
msgstr ""

#: ../../userguide/configuration.rst:84
msgid "``CASSANDRA_COLUMN_FAMILY``"
msgstr ""

#: ../../userguide/configuration.rst:84
msgid ":setting:`cassandra_table`"
msgstr ""

#: ../../userguide/configuration.rst:85
msgid "``CASSANDRA_ENTRY_TTL``"
msgstr ""

#: ../../userguide/configuration.rst:85
msgid ":setting:`cassandra_entry_ttl`"
msgstr ""

#: ../../userguide/configuration.rst:86
msgid "``CASSANDRA_KEYSPACE``"
msgstr ""

#: ../../userguide/configuration.rst:86
msgid ":setting:`cassandra_keyspace`"
msgstr ""

#: ../../userguide/configuration.rst:87
msgid "``CASSANDRA_PORT``"
msgstr ""

#: ../../userguide/configuration.rst:87
msgid ":setting:`cassandra_port`"
msgstr ""

#: ../../userguide/configuration.rst:88
msgid "``CASSANDRA_READ_CONSISTENCY``"
msgstr ""

#: ../../userguide/configuration.rst:88
msgid ":setting:`cassandra_read_consistency`"
msgstr ""

#: ../../userguide/configuration.rst:89
msgid "``CASSANDRA_SERVERS``"
msgstr ""

#: ../../userguide/configuration.rst:89
msgid ":setting:`cassandra_servers`"
msgstr ""

#: ../../userguide/configuration.rst:90
msgid "``CASSANDRA_WRITE_CONSISTENCY``"
msgstr ""

#: ../../userguide/configuration.rst:90
msgid ":setting:`cassandra_write_consistency`"
msgstr ""

#: ../../userguide/configuration.rst:91
msgid "``CASSANDRA_OPTIONS``"
msgstr ""

#: ../../userguide/configuration.rst:91
msgid ":setting:`cassandra_options`"
msgstr ""

#: ../../userguide/configuration.rst:92
msgid "``S3_ACCESS_KEY_ID``"
msgstr ""

#: ../../userguide/configuration.rst:92
msgid ":setting:`s3_access_key_id`"
msgstr ""

#: ../../userguide/configuration.rst:93
msgid "``S3_SECRET_ACCESS_KEY``"
msgstr ""

#: ../../userguide/configuration.rst:93
msgid ":setting:`s3_secret_access_key`"
msgstr ""

#: ../../userguide/configuration.rst:94
msgid "``S3_BUCKET``"
msgstr ""

#: ../../userguide/configuration.rst:94
msgid ":setting:`s3_bucket`"
msgstr ""

#: ../../userguide/configuration.rst:95
msgid "``S3_BASE_PATH``"
msgstr ""

#: ../../userguide/configuration.rst:95
msgid ":setting:`s3_base_path`"
msgstr ""

#: ../../userguide/configuration.rst:96
msgid "``S3_ENDPOINT_URL``"
msgstr ""

#: ../../userguide/configuration.rst:96
msgid ":setting:`s3_endpoint_url`"
msgstr ""

#: ../../userguide/configuration.rst:97
msgid "``S3_REGION``"
msgstr ""

#: ../../userguide/configuration.rst:97
msgid ":setting:`s3_region`"
msgstr ""

#: ../../userguide/configuration.rst:98
msgid "``CELERY_COUCHBASE_BACKEND_SETTINGS``"
msgstr ""

#: ../../userguide/configuration.rst:98
msgid ":setting:`couchbase_backend_settings`"
msgstr ""

#: ../../userguide/configuration.rst:99
msgid "``CELERY_ARANGODB_BACKEND_SETTINGS``"
msgstr ""

#: ../../userguide/configuration.rst:99
msgid ":setting:`arangodb_backend_settings`"
msgstr ""

#: ../../userguide/configuration.rst:100
msgid "``CELERY_MONGODB_BACKEND_SETTINGS``"
msgstr ""

#: ../../userguide/configuration.rst:100
msgid ":setting:`mongodb_backend_settings`"
msgstr ""

#: ../../userguide/configuration.rst:101
msgid "``CELERY_EVENT_QUEUE_EXPIRES``"
msgstr ""

#: ../../userguide/configuration.rst:101
msgid ":setting:`event_queue_expires`"
msgstr ""

#: ../../userguide/configuration.rst:102
msgid "``CELERY_EVENT_QUEUE_TTL``"
msgstr ""

#: ../../userguide/configuration.rst:102
msgid ":setting:`event_queue_ttl`"
msgstr ""

#: ../../userguide/configuration.rst:103
msgid "``CELERY_EVENT_QUEUE_PREFIX``"
msgstr ""

#: ../../userguide/configuration.rst:103
msgid ":setting:`event_queue_prefix`"
msgstr ""

#: ../../userguide/configuration.rst:104
msgid "``CELERY_EVENT_SERIALIZER``"
msgstr ""

#: ../../userguide/configuration.rst:104
msgid ":setting:`event_serializer`"
msgstr ""

#: ../../userguide/configuration.rst:105
msgid "``CELERY_REDIS_DB``"
msgstr ""

#: ../../userguide/configuration.rst:105
msgid ":setting:`redis_db`"
msgstr ""

#: ../../userguide/configuration.rst:106
msgid "``CELERY_REDIS_HOST``"
msgstr ""

#: ../../userguide/configuration.rst:106
msgid ":setting:`redis_host`"
msgstr ""

#: ../../userguide/configuration.rst:107
msgid "``CELERY_REDIS_MAX_CONNECTIONS``"
msgstr ""

#: ../../userguide/configuration.rst:107
msgid ":setting:`redis_max_connections`"
msgstr ""

#: ../../userguide/configuration.rst:108
msgid "``CELERY_REDIS_PASSWORD``"
msgstr ""

#: ../../userguide/configuration.rst:108
msgid ":setting:`redis_password`"
msgstr ""

#: ../../userguide/configuration.rst:109
msgid "``CELERY_REDIS_PORT``"
msgstr ""

#: ../../userguide/configuration.rst:109
msgid ":setting:`redis_port`"
msgstr ""

#: ../../userguide/configuration.rst:110
msgid "``CELERY_REDIS_BACKEND_USE_SSL``"
msgstr ""

#: ../../userguide/configuration.rst:110
msgid ":setting:`redis_backend_use_ssl`"
msgstr ""

#: ../../userguide/configuration.rst:111
msgid "``CELERY_RESULT_BACKEND``"
msgstr ""

#: ../../userguide/configuration.rst:111
msgid ":setting:`result_backend`"
msgstr ""

#: ../../userguide/configuration.rst:112
msgid "``CELERY_MAX_CACHED_RESULTS``"
msgstr ""

#: ../../userguide/configuration.rst:112
msgid ":setting:`result_cache_max`"
msgstr ""

#: ../../userguide/configuration.rst:113
msgid "``CELERY_MESSAGE_COMPRESSION``"
msgstr ""

#: ../../userguide/configuration.rst:113
msgid ":setting:`result_compression`"
msgstr ""

#: ../../userguide/configuration.rst:114
msgid "``CELERY_RESULT_EXCHANGE``"
msgstr ""

#: ../../userguide/configuration.rst:114
msgid ":setting:`result_exchange`"
msgstr ""

#: ../../userguide/configuration.rst:115
msgid "``CELERY_RESULT_EXCHANGE_TYPE``"
msgstr ""

#: ../../userguide/configuration.rst:115
msgid ":setting:`result_exchange_type`"
msgstr ""

#: ../../userguide/configuration.rst:116
msgid "``CELERY_RESULT_EXPIRES``"
msgstr ""

#: ../../userguide/configuration.rst:116
msgid ":setting:`result_expires`"
msgstr ""

#: ../../userguide/configuration.rst:117
msgid "``CELERY_RESULT_PERSISTENT``"
msgstr ""

#: ../../userguide/configuration.rst:117
msgid ":setting:`result_persistent`"
msgstr ""

#: ../../userguide/configuration.rst:118
msgid "``CELERY_RESULT_SERIALIZER``"
msgstr ""

#: ../../userguide/configuration.rst:118
msgid ":setting:`result_serializer`"
msgstr ""

#: ../../userguide/configuration.rst:119
msgid "``CELERY_RESULT_DBURI``"
msgstr ""

#: ../../userguide/configuration.rst:119
msgid "Use :setting:`result_backend` instead."
msgstr ""

#: ../../userguide/configuration.rst:120
msgid "``CELERY_RESULT_ENGINE_OPTIONS``"
msgstr ""

#: ../../userguide/configuration.rst:120
msgid ":setting:`database_engine_options`"
msgstr ""

#: ../../userguide/configuration.rst:121
msgid "``[...]_DB_SHORT_LIVED_SESSIONS``"
msgstr ""

#: ../../userguide/configuration.rst:121
msgid ":setting:`database_short_lived_sessions`"
msgstr ""

#: ../../userguide/configuration.rst:122
msgid "``CELERY_RESULT_DB_TABLE_NAMES``"
msgstr ""

#: ../../userguide/configuration.rst:122
msgid ":setting:`database_db_names`"
msgstr ""

#: ../../userguide/configuration.rst:123
msgid "``CELERY_SECURITY_CERTIFICATE``"
msgstr ""

#: ../../userguide/configuration.rst:123
msgid ":setting:`security_certificate`"
msgstr ""

#: ../../userguide/configuration.rst:124
msgid "``CELERY_SECURITY_CERT_STORE``"
msgstr ""

#: ../../userguide/configuration.rst:124
msgid ":setting:`security_cert_store`"
msgstr ""

#: ../../userguide/configuration.rst:125
msgid "``CELERY_SECURITY_KEY``"
msgstr ""

#: ../../userguide/configuration.rst:125
msgid ":setting:`security_key`"
msgstr ""

#: ../../userguide/configuration.rst:126
msgid "``CELERY_TASK_ACKS_LATE``"
msgstr ""

#: ../../userguide/configuration.rst:126
msgid ":setting:`task_acks_late`"
msgstr ""

#: ../../userguide/configuration.rst:127
msgid "``CELERY_TASK_ACKS_ON_FAILURE_OR_TIMEOUT``"
msgstr ""

#: ../../userguide/configuration.rst:127
msgid ":setting:`task_acks_on_failure_or_timeout`"
msgstr ""

#: ../../userguide/configuration.rst:128
msgid "``CELERY_TASK_ALWAYS_EAGER``"
msgstr ""

#: ../../userguide/configuration.rst:128
msgid ":setting:`task_always_eager`"
msgstr ""

#: ../../userguide/configuration.rst:129
msgid "``CELERY_TASK_ANNOTATIONS``"
msgstr ""

#: ../../userguide/configuration.rst:129
msgid ":setting:`task_annotations`"
msgstr ""

#: ../../userguide/configuration.rst:130
msgid "``CELERY_TASK_COMPRESSION``"
msgstr ""

#: ../../userguide/configuration.rst:130
msgid ":setting:`task_compression`"
msgstr ""

#: ../../userguide/configuration.rst:131
msgid "``CELERY_TASK_CREATE_MISSING_QUEUES``"
msgstr ""

#: ../../userguide/configuration.rst:131
msgid ":setting:`task_create_missing_queues`"
msgstr ""

#: ../../userguide/configuration.rst:132
msgid "``CELERY_TASK_DEFAULT_DELIVERY_MODE``"
msgstr ""

#: ../../userguide/configuration.rst:132
msgid ":setting:`task_default_delivery_mode`"
msgstr ""

#: ../../userguide/configuration.rst:133
msgid "``CELERY_TASK_DEFAULT_EXCHANGE``"
msgstr ""

#: ../../userguide/configuration.rst:133
msgid ":setting:`task_default_exchange`"
msgstr ""

#: ../../userguide/configuration.rst:134
msgid "``CELERY_TASK_DEFAULT_EXCHANGE_TYPE``"
msgstr ""

#: ../../userguide/configuration.rst:134
msgid ":setting:`task_default_exchange_type`"
msgstr ""

#: ../../userguide/configuration.rst:135
msgid "``CELERY_TASK_DEFAULT_QUEUE``"
msgstr ""

#: ../../userguide/configuration.rst:135
msgid ":setting:`task_default_queue`"
msgstr ""

#: ../../userguide/configuration.rst:136
msgid "``CELERY_TASK_DEFAULT_RATE_LIMIT``"
msgstr ""

#: ../../userguide/configuration.rst:136
msgid ":setting:`task_default_rate_limit`"
msgstr ""

#: ../../userguide/configuration.rst:137
msgid "``CELERY_TASK_DEFAULT_ROUTING_KEY``"
msgstr ""

#: ../../userguide/configuration.rst:137
msgid ":setting:`task_default_routing_key`"
msgstr ""

#: ../../userguide/configuration.rst:138
msgid "``CELERY_TASK_EAGER_PROPAGATES``"
msgstr ""

#: ../../userguide/configuration.rst:138
msgid ":setting:`task_eager_propagates`"
msgstr ""

#: ../../userguide/configuration.rst:139
msgid "``CELERY_TASK_IGNORE_RESULT``"
msgstr ""

#: ../../userguide/configuration.rst:139
msgid ":setting:`task_ignore_result`"
msgstr ""

#: ../../userguide/configuration.rst:140
msgid "``CELERY_TASK_PUBLISH_RETRY``"
msgstr ""

#: ../../userguide/configuration.rst:141
msgid "``CELERY_TASK_PUBLISH_RETRY_POLICY``"
msgstr ""

#: ../../userguide/configuration.rst:142
msgid "``CELERY_QUEUES``"
msgstr ""

#: ../../userguide/configuration.rst:142
msgid ":setting:`task_queues`"
msgstr ""

#: ../../userguide/configuration.rst:143
msgid "``CELERY_ROUTES``"
msgstr ""

#: ../../userguide/configuration.rst:143
msgid ":setting:`task_routes`"
msgstr ""

#: ../../userguide/configuration.rst:144
msgid "``CELERY_TASK_SEND_SENT_EVENT``"
msgstr ""

#: ../../userguide/configuration.rst:144
msgid ":setting:`task_send_sent_event`"
msgstr ""

#: ../../userguide/configuration.rst:145
msgid "``CELERY_TASK_SERIALIZER``"
msgstr ""

#: ../../userguide/configuration.rst:145
msgid ":setting:`task_serializer`"
msgstr ""

#: ../../userguide/configuration.rst:146
msgid "``CELERYD_TASK_SOFT_TIME_LIMIT``"
msgstr ""

#: ../../userguide/configuration.rst:146
msgid ":setting:`task_soft_time_limit`"
msgstr ""

#: ../../userguide/configuration.rst:147
msgid "``CELERYD_TASK_TIME_LIMIT``"
msgstr ""

#: ../../userguide/configuration.rst:147
msgid ":setting:`task_time_limit`"
msgstr ""

#: ../../userguide/configuration.rst:148
msgid "``CELERY_TRACK_STARTED``"
msgstr ""

#: ../../userguide/configuration.rst:148
msgid ":setting:`task_track_started`"
msgstr ""

#: ../../userguide/configuration.rst:149
msgid "``CELERYD_AGENT``"
msgstr ""

#: ../../userguide/configuration.rst:149
msgid ":setting:`worker_agent`"
msgstr ""

#: ../../userguide/configuration.rst:150
msgid "``CELERYD_AUTOSCALER``"
msgstr ""

#: ../../userguide/configuration.rst:150
msgid ":setting:`worker_autoscaler`"
msgstr ""

#: ../../userguide/configuration.rst:151
msgid "``CELERYD_CONCURRENCY``"
msgstr ""

#: ../../userguide/configuration.rst:151
msgid ":setting:`worker_concurrency`"
msgstr ""

#: ../../userguide/configuration.rst:152
msgid "``CELERYD_CONSUMER``"
msgstr ""

#: ../../userguide/configuration.rst:152
msgid ":setting:`worker_consumer`"
msgstr ""

#: ../../userguide/configuration.rst:153
msgid "``CELERY_WORKER_DIRECT``"
msgstr ""

#: ../../userguide/configuration.rst:153
msgid ":setting:`worker_direct`"
msgstr ""

#: ../../userguide/configuration.rst:154
msgid "``CELERY_DISABLE_RATE_LIMITS``"
msgstr ""

#: ../../userguide/configuration.rst:154
msgid ":setting:`worker_disable_rate_limits`"
msgstr ""

#: ../../userguide/configuration.rst:155
msgid "``CELERY_ENABLE_REMOTE_CONTROL``"
msgstr ""

#: ../../userguide/configuration.rst:155
msgid ":setting:`worker_enable_remote_control`"
msgstr ""

#: ../../userguide/configuration.rst:156
msgid "``CELERYD_HIJACK_ROOT_LOGGER``"
msgstr ""

#: ../../userguide/configuration.rst:156
msgid ":setting:`worker_hijack_root_logger`"
msgstr ""

#: ../../userguide/configuration.rst:157
msgid "``CELERYD_LOG_COLOR``"
msgstr ""

#: ../../userguide/configuration.rst:157
msgid ":setting:`worker_log_color`"
msgstr ""

#: ../../userguide/configuration.rst:158
msgid "``CELERYD_LOG_FORMAT``"
msgstr ""

#: ../../userguide/configuration.rst:158
msgid ":setting:`worker_log_format`"
msgstr ""

#: ../../userguide/configuration.rst:159
msgid "``CELERYD_WORKER_LOST_WAIT``"
msgstr ""

#: ../../userguide/configuration.rst:159
msgid ":setting:`worker_lost_wait`"
msgstr ""

#: ../../userguide/configuration.rst:160
msgid "``CELERYD_MAX_TASKS_PER_CHILD``"
msgstr ""

#: ../../userguide/configuration.rst:160
msgid ":setting:`worker_max_tasks_per_child`"
msgstr ""

#: ../../userguide/configuration.rst:161
msgid "``CELERYD_POOL``"
msgstr ""

#: ../../userguide/configuration.rst:161
msgid ":setting:`worker_pool`"
msgstr ""

#: ../../userguide/configuration.rst:162
msgid "``CELERYD_POOL_PUTLOCKS``"
msgstr ""

#: ../../userguide/configuration.rst:162
msgid ":setting:`worker_pool_putlocks`"
msgstr ""

#: ../../userguide/configuration.rst:163
msgid "``CELERYD_POOL_RESTARTS``"
msgstr ""

#: ../../userguide/configuration.rst:163
msgid ":setting:`worker_pool_restarts`"
msgstr ""

#: ../../userguide/configuration.rst:164
msgid "``CELERYD_PREFETCH_MULTIPLIER``"
msgstr ""

#: ../../userguide/configuration.rst:164
msgid ":setting:`worker_prefetch_multiplier`"
msgstr ""

#: ../../userguide/configuration.rst:165
msgid "``CELERYD_REDIRECT_STDOUTS``"
msgstr ""

#: ../../userguide/configuration.rst:165
msgid ":setting:`worker_redirect_stdouts`"
msgstr ""

#: ../../userguide/configuration.rst:166
msgid "``CELERYD_REDIRECT_STDOUTS_LEVEL``"
msgstr ""

#: ../../userguide/configuration.rst:166
msgid ":setting:`worker_redirect_stdouts_level`"
msgstr ""

#: ../../userguide/configuration.rst:167
msgid "``CELERY_SEND_EVENTS``"
msgstr ""

#: ../../userguide/configuration.rst:167
msgid ":setting:`worker_send_task_events`"
msgstr ""

#: ../../userguide/configuration.rst:168
msgid "``CELERYD_STATE_DB``"
msgstr ""

#: ../../userguide/configuration.rst:168
msgid ":setting:`worker_state_db`"
msgstr ""

#: ../../userguide/configuration.rst:169
msgid "``CELERYD_TASK_LOG_FORMAT``"
msgstr ""

#: ../../userguide/configuration.rst:169
msgid ":setting:`worker_task_log_format`"
msgstr ""

#: ../../userguide/configuration.rst:170
msgid "``CELERYD_TIMER``"
msgstr ""

#: ../../userguide/configuration.rst:170
msgid ":setting:`worker_timer`"
msgstr ""

#: ../../userguide/configuration.rst:171
msgid "``CELERYD_TIMER_PRECISION``"
msgstr ""

#: ../../userguide/configuration.rst:171
msgid ":setting:`worker_timer_precision`"
msgstr ""

#: ../../userguide/configuration.rst:175
msgid "Configuration Directives"
msgstr ""

#: ../../userguide/configuration.rst:180
msgid "General settings"
msgstr ""

#: ../../userguide/configuration.rst:185
msgid "``accept_content``"
msgstr ""

#: ../../userguide/configuration.rst:187
msgid "Default: ``{'json'}``  (set, list, or tuple)."
msgstr ""

#: ../../userguide/configuration.rst:189
msgid "A white-list of content-types/serializers to allow."
msgstr ""

#: ../../userguide/configuration.rst:191 ../../userguide/configuration.rst:218
msgid ""
"If a message is received that's not in this list then the message will be"
" discarded with an error."
msgstr ""

#: ../../userguide/configuration.rst:194
msgid ""
"By default only json is enabled but any content type can be added, "
"including pickle and yaml; when this is the case make sure untrusted "
"parties don't have access to your broker. See :ref:`guide-security` for "
"more."
msgstr ""

#: ../../userguide/configuration.rst:199 ../../userguide/configuration.rst:228
#: ../../userguide/configuration.rst:2208
#: ../../userguide/configuration.rst:2227
msgid "Example::"
msgstr ""

#: ../../userguide/configuration.rst:210
msgid "``result_accept_content``"
msgstr ""

#: ../../userguide/configuration.rst:212
msgid "Default: ``None`` (can be set, list or tuple)."
msgstr ""

#: ../../userguide/configuration.rst:216
msgid "A white-list of content-types/serializers to allow for the result backend."
msgstr ""

#: ../../userguide/configuration.rst:221
msgid ""
"By default it is the same serializer as ``accept_content``. However, a "
"different serializer for accepted content of the result backend can be "
"specified. Usually this is needed if signed messaging is used and the "
"result is stored unsigned in the result backend. See :ref:`guide-"
"security` for more."
msgstr ""

#: ../../userguide/configuration.rst:237
msgid "Time and date settings"
msgstr ""

#: ../../userguide/configuration.rst:242
msgid "``enable_utc``"
msgstr ""

#: ../../userguide/configuration.rst:246
msgid "Default: Enabled by default since version 3.0."
msgstr ""

#: ../../userguide/configuration.rst:248
msgid ""
"If enabled dates and times in messages will be converted to use the UTC "
"timezone."
msgstr ""

#: ../../userguide/configuration.rst:251
msgid ""
"Note that workers running Celery versions below 2.5 will assume a local "
"timezone for all messages, so only enable if all workers have been "
"upgraded."
msgstr ""

#: ../../userguide/configuration.rst:258
msgid "``timezone``"
msgstr ""

#: ../../userguide/configuration.rst:262
msgid "Default: ``\"UTC\"``."
msgstr ""

#: ../../userguide/configuration.rst:264
msgid ""
"Configure Celery to use a custom time zone. The timezone value can be any"
" time zone supported by the :pypi:`pytz` library."
msgstr ""

#: ../../userguide/configuration.rst:268
msgid ""
"If not set the UTC timezone is used. For backwards compatibility there's "
"also a :setting:`enable_utc` setting, and when this is set to false the "
"system local timezone is used instead."
msgstr ""

#: ../../userguide/configuration.rst:275
msgid "Task settings"
msgstr ""

#: ../../userguide/configuration.rst:280
msgid "``task_annotations``"
msgstr ""

#: ../../userguide/configuration.rst:284 ../../userguide/configuration.rst:1174
#: ../../userguide/configuration.rst:1882
#: ../../userguide/configuration.rst:1992
#: ../../userguide/configuration.rst:2019
#: ../../userguide/configuration.rst:2029
#: ../../userguide/configuration.rst:2551
#: ../../userguide/configuration.rst:2829
#: ../../userguide/configuration.rst:2841
#: ../../userguide/configuration.rst:2853
msgid "Default: :const:`None`."
msgstr ""

#: ../../userguide/configuration.rst:286
msgid ""
"This setting can be used to rewrite any task attribute from the "
"configuration. The setting can be a dict, or a list of annotation objects"
" that filter for tasks and return a map of attributes to change."
msgstr ""

#: ../../userguide/configuration.rst:291
msgid "This will change the ``rate_limit`` attribute for the ``tasks.add`` task:"
msgstr ""

#: ../../userguide/configuration.rst:298
msgid "or change the same for all tasks:"
msgstr ""

#: ../../userguide/configuration.rst:304
msgid "You can change methods too, for example the ``on_failure`` handler:"
msgstr ""

#: ../../userguide/configuration.rst:313
msgid ""
"If you need more flexibility then you can use objects instead of a dict "
"to choose the tasks to annotate:"
msgstr ""

#: ../../userguide/configuration.rst:329
msgid "``task_compression``"
msgstr ""

#: ../../userguide/configuration.rst:331 ../../userguide/configuration.rst:1062
msgid "Default: :const:`None`"
msgstr ""

#: ../../userguide/configuration.rst:333
msgid ""
"Default compression used for task messages. Can be ``gzip``, ``bzip2`` "
"(if available), or any custom compression schemes registered in the Kombu"
" compression registry."
msgstr ""

#: ../../userguide/configuration.rst:337
msgid "The default is to send uncompressed messages."
msgstr ""

#: ../../userguide/configuration.rst:342
msgid "``task_protocol``"
msgstr ""

#: ../../userguide/configuration.rst:346
msgid "Default: 2 (since 4.0)."
msgstr ""

#: ../../userguide/configuration.rst:348
msgid ""
"Set the default task message protocol version used to send tasks. "
"Supports protocols: 1 and 2."
msgstr ""

#: ../../userguide/configuration.rst:351
msgid "Protocol 2 is supported by 3.1.24 and 4.x+."
msgstr ""

#: ../../userguide/configuration.rst:356
msgid "``task_serializer``"
msgstr ""

#: ../../userguide/configuration.rst:358
msgid "Default: ``\"json\"`` (since 4.0, earlier: pickle)."
msgstr ""

#: ../../userguide/configuration.rst:360
msgid ""
"A string identifying the default serialization method to use. Can be "
"`json` (default), `pickle`, `yaml`, `msgpack`, or any custom "
"serialization methods that have been registered with "
":mod:`kombu.serialization.registry`."
msgstr ""

#: ../../userguide/configuration.rst:366 ../../userguide/configuration.rst:2676
msgid ":ref:`calling-serializers`."
msgstr ""

#: ../../userguide/configuration.rst:371
msgid "``task_publish_retry``"
msgstr ""

#: ../../userguide/configuration.rst:375 ../../userguide/configuration.rst:2084
#: ../../userguide/configuration.rst:2375
msgid "Default: Enabled."
msgstr ""

#: ../../userguide/configuration.rst:377
msgid ""
"Decides if publishing task messages will be retried in the case of "
"connection loss or other connection errors. See also "
":setting:`task_publish_retry_policy`."
msgstr ""

#: ../../userguide/configuration.rst:384
msgid "``task_publish_retry_policy``"
msgstr ""

#: ../../userguide/configuration.rst:388
msgid "Default: See :ref:`calling-retry`."
msgstr ""

#: ../../userguide/configuration.rst:390
msgid ""
"Defines the default policy when retrying publishing a task message in the"
" case of connection loss or other connection errors."
msgstr ""

#: ../../userguide/configuration.rst:396
msgid "Task execution settings"
msgstr ""

#: ../../userguide/configuration.rst:401
msgid "``task_always_eager``"
msgstr ""

#: ../../userguide/configuration.rst:403 ../../userguide/configuration.rst:419
#: ../../userguide/configuration.rst:432 ../../userguide/configuration.rst:452
#: ../../userguide/configuration.rst:463 ../../userguide/configuration.rst:473
#: ../../userguide/configuration.rst:521 ../../userguide/configuration.rst:549
#: ../../userguide/configuration.rst:1038
#: ../../userguide/configuration.rst:2059
#: ../../userguide/configuration.rst:2281
msgid "Default: Disabled."
msgstr ""

#: ../../userguide/configuration.rst:405
msgid ""
"If this is :const:`True`, all tasks will be executed locally by blocking "
"until the task returns. ``apply_async()`` and ``Task.delay()`` will "
"return an :class:`~celery.result.EagerResult` instance, that emulates the"
" API and behavior of :class:`~celery.result.AsyncResult`, except the "
"result is already evaluated."
msgstr ""

#: ../../userguide/configuration.rst:411
msgid ""
"That is, tasks will be executed locally instead of being sent to the "
"queue."
msgstr ""

#: ../../userguide/configuration.rst:417
msgid "``task_eager_propagates``"
msgstr ""

#: ../../userguide/configuration.rst:421
msgid ""
"If this is :const:`True`, eagerly executed tasks (applied by "
"`task.apply()`, or when the :setting:`task_always_eager` setting is "
"enabled), will propagate exceptions."
msgstr ""

#: ../../userguide/configuration.rst:425
msgid "It's the same as always running ``apply()`` with ``throw=True``."
msgstr ""

#: ../../userguide/configuration.rst:430
msgid "``task_remote_tracebacks``"
msgstr ""

#: ../../userguide/configuration.rst:434
msgid ""
"If enabled task results will include the workers stack when re-raising "
"task errors."
msgstr ""

#: ../../userguide/configuration.rst:437
msgid ""
"This requires the :pypi:`tblib` library, that can be installed using "
":command:`pip`:"
msgstr ""

#: ../../userguide/configuration.rst:444 ../../userguide/configuration.rst:976
#: ../../userguide/configuration.rst:1092
#: ../../userguide/configuration.rst:1238
#: ../../userguide/configuration.rst:1431
#: ../../userguide/configuration.rst:1505
#: ../../userguide/configuration.rst:1781
msgid ""
"See :ref:`bundles` for information on combining multiple extension "
"requirements."
msgstr ""

#: ../../userguide/configuration.rst:450
msgid "``task_ignore_result``"
msgstr ""

#: ../../userguide/configuration.rst:454
msgid ""
"Whether to store the task return values or not (tombstones). If you still"
" want to store errors, just not successful return values, you can set "
":setting:`task_store_errors_even_if_ignored`."
msgstr ""

#: ../../userguide/configuration.rst:461
msgid "``task_store_errors_even_if_ignored``"
msgstr ""

#: ../../userguide/configuration.rst:465
msgid ""
"If set, the worker stores all task errors in the result store even if "
":attr:`Task.ignore_result <celery.task.base.Task.ignore_result>` is on."
msgstr ""

#: ../../userguide/configuration.rst:471
msgid "``task_track_started``"
msgstr ""

#: ../../userguide/configuration.rst:475
msgid ""
"If :const:`True` the task will report its status as 'started' when the "
"task is executed by a worker. The default value is :const:`False` as the "
"normal behavior is to not report that level of granularity. Tasks are "
"either pending, finished, or waiting to be retried. Having a 'started' "
"state can be useful for when there are long running tasks and there's a "
"need to report what task is currently running."
msgstr ""

#: ../../userguide/configuration.rst:485
msgid "``task_time_limit``"
msgstr ""

#: ../../userguide/configuration.rst:487
msgid "Default: No time limit."
msgstr ""

#: ../../userguide/configuration.rst:489
msgid ""
"Task hard time limit in seconds. The worker processing the task will be "
"killed and replaced with a new one when this is exceeded."
msgstr ""

#: ../../userguide/configuration.rst:495
msgid "``task_soft_time_limit``"
msgstr ""

#: ../../userguide/configuration.rst:497
msgid "Default: No soft time limit."
msgstr ""

#: ../../userguide/configuration.rst:499
msgid "Task soft time limit in seconds."
msgstr ""

#: ../../userguide/configuration.rst:501
msgid ""
"The :exc:`~@SoftTimeLimitExceeded` exception will be raised when this is "
"exceeded. For example, the task can catch this to clean up before the "
"hard time limit comes:"
msgstr ""

#: ../../userguide/configuration.rst:519
msgid "``task_acks_late``"
msgstr ""

#: ../../userguide/configuration.rst:523
msgid ""
"Late ack means the task messages will be acknowledged **after** the task "
"has been executed, not *just before* (the default behavior)."
msgstr ""

#: ../../userguide/configuration.rst:528
msgid "FAQ: :ref:`faq-acks_late-vs-retry`."
msgstr ""

#: ../../userguide/configuration.rst:533
msgid "``task_acks_on_failure_or_timeout``"
msgstr ""

#: ../../userguide/configuration.rst:535
msgid "Default: Enabled"
msgstr ""

#: ../../userguide/configuration.rst:537
msgid ""
"When enabled messages for all tasks will be acknowledged even if they "
"fail or time out."
msgstr ""

#: ../../userguide/configuration.rst:540
msgid ""
"Configuring this setting only applies to tasks that are acknowledged "
"**after** they have been executed and only if :setting:`task_acks_late` "
"is enabled."
msgstr ""

#: ../../userguide/configuration.rst:547
msgid "``task_reject_on_worker_lost``"
msgstr ""

#: ../../userguide/configuration.rst:551
msgid ""
"Even if :setting:`task_acks_late` is enabled, the worker will acknowledge"
" tasks when the worker process executing them abruptly exits or is "
"signaled (e.g., :sig:`KILL`/:sig:`INT`, etc)."
msgstr ""

#: ../../userguide/configuration.rst:555
msgid ""
"Setting this to true allows the message to be re-queued instead, so that "
"the task will execute again by the same worker, or another worker."
msgstr ""

#: ../../userguide/configuration.rst:561
msgid ""
"Enabling this can cause message loops; make sure you know what you're "
"doing."
msgstr ""

#: ../../userguide/configuration.rst:567
msgid "``task_default_rate_limit``"
msgstr ""

#: ../../userguide/configuration.rst:569
msgid "Default: No rate limit."
msgstr ""

#: ../../userguide/configuration.rst:571
msgid "The global default rate limit for tasks."
msgstr ""

#: ../../userguide/configuration.rst:573
msgid "This value is used for tasks that doesn't have a custom rate limit"
msgstr ""

#: ../../userguide/configuration.rst:577
msgid ""
"The setting:`worker_disable_rate_limits` setting can disable all rate "
"limits."
msgstr ""

#: ../../userguide/configuration.rst:583
msgid "Task result backend settings"
msgstr ""

#: ../../userguide/configuration.rst:588
msgid "``result_backend``"
msgstr ""

#: ../../userguide/configuration.rst:590
msgid "Default: No result backend enabled by default."
msgstr ""

#: ../../userguide/configuration.rst:592
msgid ""
"The backend used to store task results (tombstones). Can be one of the "
"following:"
msgstr ""

#: ../../userguide/configuration.rst:597
msgid "``rpc``"
msgstr ""

#: ../../userguide/configuration.rst:596
msgid "Send results back as AMQP messages See :ref:`conf-rpc-result-backend`."
msgstr ""

#: ../../userguide/configuration.rst:601 ../../userguide/configuration.rst:1686
msgid "``database``"
msgstr ""

#: ../../userguide/configuration.rst:600
msgid ""
"Use a relational database supported by `SQLAlchemy`_. See :ref:`conf-"
"database-result-backend`."
msgstr ""

#: ../../userguide/configuration.rst:605 ../../userguide/configuration.rst:2318
msgid "``redis``"
msgstr ""

#: ../../userguide/configuration.rst:604
msgid "Use `Redis`_ to store the results. See :ref:`conf-redis-result-backend`."
msgstr ""

#: ../../userguide/configuration.rst:609
msgid "``cache``"
msgstr ""

#: ../../userguide/configuration.rst:608
msgid ""
"Use `Memcached`_ to store the results. See :ref:`conf-cache-result-"
"backend`."
msgstr ""

#: ../../userguide/configuration.rst:613
msgid "``cassandra``"
msgstr ""

#: ../../userguide/configuration.rst:612
msgid ""
"Use `Cassandra`_ to store the results. See :ref:`conf-cassandra-result-"
"backend`."
msgstr ""

#: ../../userguide/configuration.rst:617
msgid "``elasticsearch``"
msgstr ""

#: ../../userguide/configuration.rst:616
msgid ""
"Use `Elasticsearch`_ to store the results. See :ref:`conf-elasticsearch-"
"result-backend`."
msgstr ""

#: ../../userguide/configuration.rst:621
msgid "``ironcache``"
msgstr ""

#: ../../userguide/configuration.rst:620
msgid ""
"Use `IronCache`_ to store the results. See :ref:`conf-ironcache-result-"
"backend`."
msgstr ""

#: ../../userguide/configuration.rst:625
msgid "``couchbase``"
msgstr ""

#: ../../userguide/configuration.rst:624
msgid ""
"Use `Couchbase`_ to store the results. See :ref:`conf-couchbase-result-"
"backend`."
msgstr ""

#: ../../userguide/configuration.rst:629
msgid "``arangodb``"
msgstr ""

#: ../../userguide/configuration.rst:628
msgid ""
"Use `ArangoDB`_ to store the results. See :ref:`conf-arangodb-result-"
"backend`."
msgstr ""

#: ../../userguide/configuration.rst:633
msgid "``couchdb``"
msgstr ""

#: ../../userguide/configuration.rst:632
msgid ""
"Use `CouchDB`_ to store the results. See :ref:`conf-couchdb-result-"
"backend`."
msgstr ""

#: ../../userguide/configuration.rst:637
msgid "``cosmosdbsql (experimental)``"
msgstr ""

#: ../../userguide/configuration.rst:636
msgid ""
"Use the `CosmosDB`_ PaaS to store the results. See :ref:`conf-"
"cosmosdbsql-result-backend`."
msgstr ""

#: ../../userguide/configuration.rst:641
msgid "``filesystem``"
msgstr ""

#: ../../userguide/configuration.rst:640
msgid ""
"Use a shared directory to store the results. See :ref:`conf-filesystem-"
"result-backend`."
msgstr ""

#: ../../userguide/configuration.rst:645
msgid "``consul``"
msgstr ""

#: ../../userguide/configuration.rst:644
msgid ""
"Use the `Consul`_ K/V store to store the results See :ref:`conf-consul-"
"result-backend`."
msgstr ""

#: ../../userguide/configuration.rst:649
msgid "``azureblockblob``"
msgstr ""

#: ../../userguide/configuration.rst:648
msgid ""
"Use the `AzureBlockBlob`_ PaaS store to store the results See :ref:`conf-"
"azureblockblob-result-backend`."
msgstr ""

#: ../../userguide/configuration.rst:653
msgid "``s3``"
msgstr ""

#: ../../userguide/configuration.rst:652
msgid "Use the `S3`_ to store the results See :ref:`conf-s3-result-backend`."
msgstr ""

#: ../../userguide/configuration.rst:678
msgid "``result_backend_transport_options``"
msgstr ""

#: ../../userguide/configuration.rst:680 ../../userguide/configuration.rst:827
#: ../../userguide/configuration.rst:854 ../../userguide/configuration.rst:938
#: ../../userguide/configuration.rst:1184
#: ../../userguide/configuration.rst:1200
#: ../../userguide/configuration.rst:1469
#: ../../userguide/configuration.rst:1619
#: ../../userguide/configuration.rst:1674
#: ../../userguide/configuration.rst:2411
#: ../../userguide/configuration.rst:2945
msgid "Default: ``{}`` (empty mapping)."
msgstr ""

#: ../../userguide/configuration.rst:682 ../../userguide/configuration.rst:2413
msgid "A dict of additional options passed to the underlying transport."
msgstr ""

#: ../../userguide/configuration.rst:684 ../../userguide/configuration.rst:2415
msgid "See your transport user manual for supported options (if any)."
msgstr ""

#: ../../userguide/configuration.rst:686 ../../userguide/configuration.rst:2417
msgid ""
"Example setting the visibility timeout (supported by Redis and SQS "
"transports):"
msgstr ""

#: ../../userguide/configuration.rst:698
msgid "``result_serializer``"
msgstr ""

#: ../../userguide/configuration.rst:700
msgid "Default: ``json`` since 4.0 (earlier: pickle)."
msgstr ""

#: ../../userguide/configuration.rst:702
msgid "Result serialization format."
msgstr ""

#: ../../userguide/configuration.rst:704
msgid ""
"See :ref:`calling-serializers` for information about supported "
"serialization formats."
msgstr ""

#: ../../userguide/configuration.rst:710
msgid "``result_compression``"
msgstr ""

#: ../../userguide/configuration.rst:712
msgid "Default: No compression."
msgstr ""

#: ../../userguide/configuration.rst:714
msgid ""
"Optional compression method used for task results. Supports the same "
"options as the :setting:`task_serializer` setting."
msgstr ""

#: ../../userguide/configuration.rst:720
msgid "``result_extended``"
msgstr ""

#: ../../userguide/configuration.rst:722
msgid "Default: ``False``"
msgstr ""

#: ../../userguide/configuration.rst:724
msgid ""
"Enables extended task result attributes (name, args, kwargs, worker, "
"retries, queue, delivery_info) to be written to backend."
msgstr ""

#: ../../userguide/configuration.rst:730
msgid "``result_expires``"
msgstr ""

#: ../../userguide/configuration.rst:732
msgid "Default: Expire after 1 day."
msgstr ""

#: ../../userguide/configuration.rst:734
msgid ""
"Time (in seconds, or a :class:`~datetime.timedelta` object) for when "
"after stored task tombstones will be deleted."
msgstr ""

#: ../../userguide/configuration.rst:737
msgid ""
"A built-in periodic task will delete the results after this time "
"(``celery.backend_cleanup``), assuming that ``celery beat`` is enabled. "
"The task runs daily at 4am."
msgstr ""

#: ../../userguide/configuration.rst:741
msgid ""
"A value of :const:`None` or 0 means results will never expire (depending "
"on backend specifications)."
msgstr ""

#: ../../userguide/configuration.rst:746
msgid ""
"For the moment this only works with the AMQP, database, cache, Couchbase,"
" and Redis backends."
msgstr ""

#: ../../userguide/configuration.rst:749
msgid ""
"When using the database backend, ``celery beat`` must be running for the "
"results to be expired."
msgstr ""

#: ../../userguide/configuration.rst:755
msgid "``result_cache_max``"
msgstr ""

#: ../../userguide/configuration.rst:757 ../../userguide/configuration.rst:840
#: ../../userguide/configuration.rst:2600
#: ../../userguide/configuration.rst:2613
#: ../../userguide/configuration.rst:2900
msgid "Default: Disabled by default."
msgstr ""

#: ../../userguide/configuration.rst:759
msgid "Enables client caching of results."
msgstr ""

#: ../../userguide/configuration.rst:761
msgid ""
"This can be useful for the old deprecated 'amqp' backend where the result"
" is unavailable as soon as one result instance consumes it."
msgstr ""

#: ../../userguide/configuration.rst:765
msgid ""
"This is the total number of results to cache before older results are "
"evicted. A value of 0 or None means no limit, and a value of :const:`-1` "
"will disable the cache."
msgstr ""

#: ../../userguide/configuration.rst:769
msgid "Disabled by default."
msgstr ""

#: ../../userguide/configuration.rst:774
msgid "``result_chord_join_timeout``"
msgstr ""

#: ../../userguide/configuration.rst:776
msgid "Default: 3.0."
msgstr ""

#: ../../userguide/configuration.rst:778
msgid ""
"The timeout in seconds (int/float) when joining a group's results within "
"a chord."
msgstr ""

#: ../../userguide/configuration.rst:783
msgid "Database backend settings"
msgstr ""

#: ../../userguide/configuration.rst:786
msgid "Database URL Examples"
msgstr ""

#: ../../userguide/configuration.rst:788
msgid ""
"To use the database backend you have to configure the "
":setting:`result_backend` setting with a connection URL and the ``db+`` "
"prefix:"
msgstr ""

#: ../../userguide/configuration.rst:796
msgid "Examples::"
msgstr ""

#: ../../userguide/configuration.rst:812
msgid ""
"Please see `Supported Databases`_ for a table of supported databases, and"
" `Connection String`_ for more information about connection strings (this"
" is the part of the URI that comes after the ``db+`` prefix)."
msgstr ""

#: ../../userguide/configuration.rst:825
msgid "``database_engine_options``"
msgstr ""

#: ../../userguide/configuration.rst:829
msgid ""
"To specify additional SQLAlchemy database engine options you can use the "
":setting:`sqlalchmey_engine_options` setting::"
msgstr ""

#: ../../userguide/configuration.rst:838
msgid "``database_short_lived_sessions``"
msgstr ""

#: ../../userguide/configuration.rst:842
msgid ""
"Short lived sessions are disabled by default. If enabled they can "
"drastically reduce performance, especially on systems processing lots of "
"tasks. This option is useful on low-traffic workers that experience "
"errors as a result of cached database connections going stale through "
"inactivity. For example, intermittent errors like `(OperationalError) "
"(2006, 'MySQL server has gone away')` can be fixed by enabling short "
"lived sessions. This option only affects the database backend."
msgstr ""

#: ../../userguide/configuration.rst:852
msgid "``database_table_names``"
msgstr ""

#: ../../userguide/configuration.rst:856
msgid ""
"When SQLAlchemy is configured as the result backend, Celery automatically"
" creates two tables to store result meta-data for tasks. This setting "
"allows you to customize the table names:"
msgstr ""

#: ../../userguide/configuration.rst:871
msgid "RPC backend settings"
msgstr ""

#: ../../userguide/configuration.rst:876
msgid "``result_persistent``"
msgstr ""

#: ../../userguide/configuration.rst:878
msgid "Default: Disabled by default (transient messages)."
msgstr ""

#: ../../userguide/configuration.rst:880
msgid ""
"If set to :const:`True`, result messages will be persistent. This means "
"the messages won't be lost after a broker restart."
msgstr ""

#: ../../userguide/configuration.rst:884 ../../userguide/configuration.rst:1212
#: ../../userguide/configuration.rst:1310
#: ../../userguide/configuration.rst:1333
#: ../../userguide/configuration.rst:1383
#: ../../userguide/configuration.rst:1713 ../../userguide/daemonizing.rst:90
#: ../../userguide/daemonizing.rst:248 ../../userguide/daemonizing.rst:437
msgid "Example configuration"
msgstr ""

#: ../../userguide/configuration.rst:891
msgid ""
"**Please note**: using this backend could trigger the raise of "
"``celery.backends.rpc.BacklogLimitExceeded`` if the task tombstone is too"
" *old*."
msgstr ""

#: ../../userguide/configuration.rst:893
msgid "E.g."
msgstr ""

#: ../../userguide/configuration.rst:905
msgid "Cache backend settings"
msgstr ""

#: ../../userguide/configuration.rst:909
msgid ""
"The cache backend supports the :pypi:`pylibmc` and :pypi:`python-"
"memcached` libraries. The latter is used only if :pypi:`pylibmc` isn't "
"installed."
msgstr ""

#: ../../userguide/configuration.rst:912
msgid "Using a single Memcached server:"
msgstr ""

#: ../../userguide/configuration.rst:918
msgid "Using multiple Memcached servers:"
msgstr ""

#: ../../userguide/configuration.rst:926
msgid "The \"memory\" backend stores the cache in memory only:"
msgstr ""

#: ../../userguide/configuration.rst:936
msgid "``cache_backend_options``"
msgstr ""

#: ../../userguide/configuration.rst:940
msgid ""
"You can set :pypi:`pylibmc` options using the "
":setting:`cache_backend_options` setting:"
msgstr ""

#: ../../userguide/configuration.rst:953
msgid "``cache_backend``"
msgstr ""

#: ../../userguide/configuration.rst:955
msgid ""
"This setting is no longer used as it's now possible to specify the cache "
"backend directly in the :setting:`result_backend` setting."
msgstr ""

#: ../../userguide/configuration.rst:961
msgid "Redis backend settings"
msgstr ""

#: ../../userguide/configuration.rst:964
msgid "Configuring the backend URL"
msgstr ""

#: ../../userguide/configuration.rst:968
msgid "The Redis backend requires the :pypi:`redis` library."
msgstr ""

#: ../../userguide/configuration.rst:970 ../../userguide/configuration.rst:1499
#: ../../userguide/configuration.rst:1573
#: ../../userguide/configuration.rst:1598
#: ../../userguide/configuration.rst:1653
msgid "To install this package use :command:`pip`:"
msgstr ""

#: ../../userguide/configuration.rst:979
msgid ""
"This backend requires the :setting:`result_backend` setting to be set to "
"a Redis or `Redis over TLS`_ URL::"
msgstr ""

#: ../../userguide/configuration.rst:987 ../../userguide/configuration.rst:1439
msgid "For example::"
msgstr ""

#: ../../userguide/configuration.rst:991 ../../userguide/configuration.rst:1443
msgid "is the same as::"
msgstr ""

#: ../../userguide/configuration.rst:995
msgid "Use the ``rediss://`` protocol to connect to redis over TLS::"
msgstr ""

#: ../../userguide/configuration.rst:999
msgid ""
"If a Unix socket connection should be used, the URL needs to be in the "
"format:::"
msgstr ""

#: ../../userguide/configuration.rst:1003
#: ../../userguide/configuration.rst:1447
msgid "The fields of the URL are defined as follows:"
msgstr ""

#: ../../userguide/configuration.rst:1005
#: ../../userguide/configuration.rst:1640
#: ../../userguide/configuration.rst:1700
#: ../../userguide/configuration.rst:1795
msgid "``password``"
msgstr ""

#: ../../userguide/configuration.rst:1007
msgid "Password used to connect to the database."
msgstr ""

#: ../../userguide/configuration.rst:1009
#: ../../userguide/configuration.rst:1449
#: ../../userguide/configuration.rst:1473
#: ../../userguide/configuration.rst:1623
#: ../../userguide/configuration.rst:1678
#: ../../userguide/configuration.rst:1799
msgid "``host``"
msgstr ""

#: ../../userguide/configuration.rst:1011
msgid "Host name or IP address of the Redis server (e.g., `localhost`)."
msgstr ""

#: ../../userguide/configuration.rst:1013
#: ../../userguide/configuration.rst:1453
#: ../../userguide/configuration.rst:1477
#: ../../userguide/configuration.rst:1547
#: ../../userguide/configuration.rst:1627
#: ../../userguide/configuration.rst:1682
#: ../../userguide/configuration.rst:1803 ../../userguide/workers.rst:888
msgid "``port``"
msgstr ""

#: ../../userguide/configuration.rst:1015
msgid "Port to the Redis server. Default is 6379."
msgstr ""

#: ../../userguide/configuration.rst:1017
msgid "``db``"
msgstr ""

#: ../../userguide/configuration.rst:1019
msgid ""
"Database number to use. Default is 0. The db can include an optional "
"leading slash."
msgstr ""

#: ../../userguide/configuration.rst:1022
msgid ""
"When using a TLS connection (protocol is ``rediss://``), you may pass in "
"all values in :setting:`broker_use_ssl` as query parameters. Paths to "
"certificates must be URL encoded, and ``ssl_cert_reqs`` is required. "
"Example:"
msgstr ""

#: ../../userguide/configuration.rst:1036
msgid "``redis_backend_use_ssl``"
msgstr ""

#: ../../userguide/configuration.rst:1040
msgid ""
"The Redis backend supports SSL. This value must be set in the form of a "
"dictionary. The valid key-value pairs are the same as the ones mentioned "
"in the ``redis`` sub-section under :setting:`broker_use_ssl`."
msgstr ""

#: ../../userguide/configuration.rst:1048
msgid "``redis_max_connections``"
msgstr ""

#: ../../userguide/configuration.rst:1050
msgid "Default: No limit."
msgstr ""

#: ../../userguide/configuration.rst:1052
msgid ""
"Maximum number of connections available in the Redis connection pool used"
" for sending and retrieving results."
msgstr ""

#: ../../userguide/configuration.rst:1058
msgid "``redis_socket_connect_timeout``"
msgstr ""

#: ../../userguide/configuration.rst:1064
msgid ""
"Socket timeout for connections to Redis from the result backend in "
"seconds (int/float)"
msgstr ""

#: ../../userguide/configuration.rst:1070
msgid "``redis_socket_timeout``"
msgstr ""

#: ../../userguide/configuration.rst:1072
msgid "Default: 120.0 seconds."
msgstr ""

#: ../../userguide/configuration.rst:1074
msgid ""
"Socket timeout for reading/writing operations to the Redis server in "
"seconds (int/float), used by the redis result backend."
msgstr ""

#: ../../userguide/configuration.rst:1080
msgid "Cassandra backend settings"
msgstr ""

#: ../../userguide/configuration.rst:1084
msgid "This Cassandra backend driver requires :pypi:`cassandra-driver`."
msgstr ""

#: ../../userguide/configuration.rst:1086
msgid "To install, use :command:`pip`:"
msgstr ""

#: ../../userguide/configuration.rst:1095
#: ../../userguide/configuration.rst:1241
msgid "This backend requires the following configuration directives to be set."
msgstr ""

#: ../../userguide/configuration.rst:1100
msgid "``cassandra_servers``"
msgstr ""

#: ../../userguide/configuration.rst:1102
#: ../../userguide/configuration.rst:2434
#: ../../userguide/configuration.rst:2448
msgid "Default: ``[]`` (empty list)."
msgstr ""

#: ../../userguide/configuration.rst:1104
msgid "List of ``host`` Cassandra servers. For example::"
msgstr ""

#: ../../userguide/configuration.rst:1111
msgid "``cassandra_port``"
msgstr ""

#: ../../userguide/configuration.rst:1113
msgid "Default: 9042."
msgstr ""

#: ../../userguide/configuration.rst:1115
msgid "Port to contact the Cassandra servers on."
msgstr ""

#: ../../userguide/configuration.rst:1120
msgid "``cassandra_keyspace``"
msgstr ""

#: ../../userguide/configuration.rst:1122
#: ../../userguide/configuration.rst:1133
#: ../../userguide/configuration.rst:1144
#: ../../userguide/configuration.rst:1154
#: ../../userguide/configuration.rst:1164
#: ../../userguide/configuration.rst:1248
#: ../../userguide/configuration.rst:1259
#: ../../userguide/configuration.rst:1270
#: ../../userguide/configuration.rst:1281
#: ../../userguide/configuration.rst:1292
#: ../../userguide/configuration.rst:1303
msgid "Default: None."
msgstr ""

#: ../../userguide/configuration.rst:1124
msgid "The key-space in which to store the results. For example::"
msgstr ""

#: ../../userguide/configuration.rst:1131
msgid "``cassandra_table``"
msgstr ""

#: ../../userguide/configuration.rst:1135
msgid "The table (column family) in which to store the results. For example::"
msgstr ""

#: ../../userguide/configuration.rst:1142
msgid "``cassandra_read_consistency``"
msgstr ""

#: ../../userguide/configuration.rst:1146
msgid ""
"The read consistency used. Values can be ``ONE``, ``TWO``, ``THREE``, "
"``QUORUM``, ``ALL``, ``LOCAL_QUORUM``, ``EACH_QUORUM``, ``LOCAL_ONE``."
msgstr ""

#: ../../userguide/configuration.rst:1152
msgid "``cassandra_write_consistency``"
msgstr ""

#: ../../userguide/configuration.rst:1156
msgid ""
"The write consistency used. Values can be ``ONE``, ``TWO``, ``THREE``, "
"``QUORUM``, ``ALL``, ``LOCAL_QUORUM``, ``EACH_QUORUM``, ``LOCAL_ONE``."
msgstr ""

#: ../../userguide/configuration.rst:1162
msgid "``cassandra_entry_ttl``"
msgstr ""

#: ../../userguide/configuration.rst:1166
msgid ""
"Time-to-live for status entries. They will expire and be removed after "
"that many seconds after adding. A value of :const:`None` (default) means "
"they will never expire."
msgstr ""

#: ../../userguide/configuration.rst:1172
msgid "``cassandra_auth_provider``"
msgstr ""

#: ../../userguide/configuration.rst:1176
msgid ""
"AuthProvider class within ``cassandra.auth`` module to use. Values can be"
" ``PlainTextAuthProvider`` or ``SaslAuthProvider``."
msgstr ""

#: ../../userguide/configuration.rst:1182
msgid "``cassandra_auth_kwargs``"
msgstr ""

#: ../../userguide/configuration.rst:1186
msgid "Named arguments to pass into the authentication provider. For example:"
msgstr ""

#: ../../userguide/configuration.rst:1198
msgid "``cassandra_options``"
msgstr ""

#: ../../userguide/configuration.rst:1202
msgid "Named arguments to pass into the ``cassandra.cluster`` class."
msgstr ""

#: ../../userguide/configuration.rst:1226
msgid "S3 backend settings"
msgstr ""

#: ../../userguide/configuration.rst:1230
msgid "This s3 backend driver requires :pypi:`s3`."
msgstr ""

#: ../../userguide/configuration.rst:1232
msgid "To install, use :command:`s3`:"
msgstr ""

#: ../../userguide/configuration.rst:1246
msgid "``s3_access_key_id``"
msgstr ""

#: ../../userguide/configuration.rst:1250
msgid "The s3 access key id. For example::"
msgstr ""

#: ../../userguide/configuration.rst:1257
msgid "``s3_secret_access_key``"
msgstr ""

#: ../../userguide/configuration.rst:1261
msgid "The s3 secret access key. For example::"
msgstr ""

#: ../../userguide/configuration.rst:1268
msgid "``s3_bucket``"
msgstr ""

#: ../../userguide/configuration.rst:1272
msgid "The s3 bucket name. For example::"
msgstr ""

#: ../../userguide/configuration.rst:1279
msgid "``s3_base_path``"
msgstr ""

#: ../../userguide/configuration.rst:1283
msgid "A base path in the s3 bucket to use to store result keys. For example::"
msgstr ""

#: ../../userguide/configuration.rst:1290
msgid "``s3_endpoint_url``"
msgstr ""

#: ../../userguide/configuration.rst:1294
msgid ""
"A custom s3 endpoint url. Use it to connect to a custom self-hosted s3 "
"compatible backend (Ceph, Scality...). For example::"
msgstr ""

#: ../../userguide/configuration.rst:1301
msgid "``s3_region``"
msgstr ""

#: ../../userguide/configuration.rst:1305
msgid "The s3 aws region. For example::"
msgstr ""

#: ../../userguide/configuration.rst:1323
msgid "Azure Block Blob backend settings"
msgstr ""

#: ../../userguide/configuration.rst:1325
msgid ""
"To use `AzureBlockBlob`_ as the result backend you simply need to "
"configure the :setting:`result_backend` setting with the correct URL."
msgstr ""

#: ../../userguide/configuration.rst:1328
msgid ""
"The required URL format is ``azureblockblob://`` followed by the storage "
"connection string. You can find the storage connection string in the "
"``Access Keys`` pane of your storage account resource in the Azure "
"Portal."
msgstr ""

#: ../../userguide/configuration.rst:1342
msgid "``azureblockblob_container_name``"
msgstr ""

#: ../../userguide/configuration.rst:1344
msgid "Default: celery."
msgstr ""

#: ../../userguide/configuration.rst:1346
msgid "The name for the storage container in which to store the results."
msgstr ""

#: ../../userguide/configuration.rst:1351
msgid "``azureblockblob_retry_initial_backoff_sec``"
msgstr ""

#: ../../userguide/configuration.rst:1353
#: ../../userguide/configuration.rst:1363
msgid "Default: 2."
msgstr ""

#: ../../userguide/configuration.rst:1355
msgid ""
"The initial backoff interval, in seconds, for the first retry. Subsequent"
" retries are attempted with an exponential strategy."
msgstr ""

#: ../../userguide/configuration.rst:1361
msgid "``azureblockblob_retry_increment_base``"
msgstr ""

#: ../../userguide/configuration.rst:1368
msgid "``azureblockblob_retry_max_attempts``"
msgstr ""

#: ../../userguide/configuration.rst:1370
#: ../../userguide/configuration.rst:1403
msgid "Default: 3."
msgstr ""

#: ../../userguide/configuration.rst:1372
msgid "The maximum number of retry attempts."
msgstr ""

#: ../../userguide/configuration.rst:1377
msgid "Elasticsearch backend settings"
msgstr ""

#: ../../userguide/configuration.rst:1379
msgid ""
"To use `Elasticsearch`_ as the result backend you simply need to "
"configure the :setting:`result_backend` setting with the correct URL."
msgstr ""

#: ../../userguide/configuration.rst:1392
msgid "``elasticsearch_retry_on_timeout``"
msgstr ""

#: ../../userguide/configuration.rst:1394
msgid "Default: :const:`False`"
msgstr ""

#: ../../userguide/configuration.rst:1396
msgid "Should timeout trigger a retry on different node?"
msgstr ""

#: ../../userguide/configuration.rst:1401
msgid "``elasticsearch_max_retries``"
msgstr ""

#: ../../userguide/configuration.rst:1405
msgid "Maximum number of retries before an exception is propagated."
msgstr ""

#: ../../userguide/configuration.rst:1410
msgid "``elasticsearch_timeout``"
msgstr ""

#: ../../userguide/configuration.rst:1412
#: ../../userguide/configuration.rst:2503
msgid "Default: 10.0 seconds."
msgstr ""

#: ../../userguide/configuration.rst:1414
msgid "Global timeout,used by the elasticsearch result backend."
msgstr ""

#: ../../userguide/configuration.rst:1419
msgid "Riak backend settings"
msgstr ""

#: ../../userguide/configuration.rst:1423
msgid "The Riak backend requires the :pypi:`riak` library."
msgstr ""

#: ../../userguide/configuration.rst:1425
msgid "To install the this package use :command:`pip`:"
msgstr ""

#: ../../userguide/configuration.rst:1434
msgid ""
"This backend requires the :setting:`result_backend` setting to be set to "
"a Riak URL::"
msgstr ""

#: ../../userguide/configuration.rst:1451
msgid "Host name or IP address of the Riak server (e.g., `'localhost'`)."
msgstr ""

#: ../../userguide/configuration.rst:1455
msgid "Port to the Riak server using the protobuf protocol. Default is 8087."
msgstr ""

#: ../../userguide/configuration.rst:1457
#: ../../userguide/configuration.rst:1481
#: ../../userguide/configuration.rst:1631
msgid "``bucket``"
msgstr ""

#: ../../userguide/configuration.rst:1459
msgid ""
"Bucket name to use. Default is `celery`. The bucket needs to be a string "
"with ASCII characters only."
msgstr ""

#: ../../userguide/configuration.rst:1462
msgid ""
"Alternatively, this backend can be configured with the following "
"configuration directives."
msgstr ""

#: ../../userguide/configuration.rst:1467
msgid "``riak_backend_settings``"
msgstr ""

#: ../../userguide/configuration.rst:1471
#: ../../userguide/configuration.rst:1621
#: ../../userguide/configuration.rst:1676
msgid "This is a dict supporting the following keys:"
msgstr ""

#: ../../userguide/configuration.rst:1475
msgid "The host name of the Riak server. Defaults to ``\"localhost\"``."
msgstr ""

#: ../../userguide/configuration.rst:1479
msgid "The port the Riak server is listening to. Defaults to 8087."
msgstr ""

#: ../../userguide/configuration.rst:1483
msgid "The bucket name to connect to. Defaults to \"celery\"."
msgstr ""

#: ../../userguide/configuration.rst:1485
msgid "``protocol``"
msgstr ""

#: ../../userguide/configuration.rst:1487
msgid ""
"The protocol to use to connect to the Riak server. This isn't "
"configurable via :setting:`result_backend`"
msgstr ""

#: ../../userguide/configuration.rst:1493
msgid "AWS DynamoDB backend settings"
msgstr ""

#: ../../userguide/configuration.rst:1497
msgid "The Dynamodb backend requires the :pypi:`boto3` library."
msgstr ""

#: ../../userguide/configuration.rst:1508
msgid ""
"This backend requires the :setting:`result_backend` setting to be set to "
"a DynamoDB URL::"
msgstr ""

#: ../../userguide/configuration.rst:1513
msgid "For example, specifying the AWS region and the table name::"
msgstr ""

#: ../../userguide/configuration.rst:1517
msgid ""
"or retrieving AWS configuration parameters from the environment, using "
"the default table name (``celery``) and specifying read and write "
"provisioned throughput::"
msgstr ""

#: ../../userguide/configuration.rst:1522
msgid ""
"or using the `downloadable version "
"<https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBLocal.html>`_"
" of DynamoDB `locally "
"<https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBLocal.Endpoint.html>`_::"
msgstr ""

#: ../../userguide/configuration.rst:1528
msgid ""
"or using downloadable version or other service with conforming API "
"deployed on any host::"
msgstr ""

#: ../../userguide/configuration.rst:1533
msgid ""
"The fields of the DynamoDB URL in ``result_backend`` are defined as "
"follows:"
msgstr ""

#: ../../userguide/configuration.rst:1535
msgid "``aws_access_key_id & aws_secret_access_key``"
msgstr ""

#: ../../userguide/configuration.rst:1537
msgid ""
"The credentials for accessing AWS API resources. These can also be "
"resolved by the :pypi:`boto3` library from various sources, as described "
"`here <http://boto3.readthedocs.io/en/latest/guide/configuration.html"
"#configuring-credentials>`_."
msgstr ""

#: ../../userguide/configuration.rst:1541
msgid "``region``"
msgstr ""

#: ../../userguide/configuration.rst:1543
msgid ""
"The AWS region, e.g. ``us-east-1`` or ``localhost`` for the `Downloadable"
" Version "
"<https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBLocal.html>`_."
" See the :pypi:`boto3` library `documentation "
"<http://boto3.readthedocs.io/en/latest/guide/configuration.html"
"#environment-variable-configuration>`_ for definition options."
msgstr ""

#: ../../userguide/configuration.rst:1549
msgid ""
"The listening port of the local DynamoDB instance, if you are using the "
"downloadable version. If you have not specified the ``region`` parameter "
"as ``localhost``, setting this parameter has **no effect**."
msgstr ""

#: ../../userguide/configuration.rst:1553
msgid "``table``"
msgstr ""

#: ../../userguide/configuration.rst:1555
msgid ""
"Table name to use. Default is ``celery``. See the `DynamoDB Naming Rules "
"<http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html"
"#limits-naming-rules>`_ for information on the allowed characters and "
"length."
msgstr ""

#: ../../userguide/configuration.rst:1559
msgid "``read & write``"
msgstr ""

#: ../../userguide/configuration.rst:1561
msgid ""
"The Read & Write Capacity Units for the created DynamoDB table. Default "
"is ``1`` for both read and write. More details can be found in the "
"`Provisioned Throughput documentation "
"<http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ProvisionedThroughput.html>`_."
msgstr ""

#: ../../userguide/configuration.rst:1567
msgid "IronCache backend settings"
msgstr ""

#: ../../userguide/configuration.rst:1571
msgid "The IronCache backend requires the :pypi:`iron_celery` library:"
msgstr ""

#: ../../userguide/configuration.rst:1579
msgid ""
"IronCache is configured via the URL provided in "
":setting:`result_backend`, for example::"
msgstr ""

#: ../../userguide/configuration.rst:1583
msgid "Or to change the cache name::"
msgstr ""

#: ../../userguide/configuration.rst:1587
msgid "For more information, see: https://github.com/iron-io/iron_celery"
msgstr ""

#: ../../userguide/configuration.rst:1592
msgid "Couchbase backend settings"
msgstr ""

#: ../../userguide/configuration.rst:1596
msgid "The Couchbase backend requires the :pypi:`couchbase` library."
msgstr ""

#: ../../userguide/configuration.rst:1604
#: ../../userguide/configuration.rst:1659
msgid ""
"See :ref:`bundles` for instructions how to combine multiple extension "
"requirements."
msgstr ""

#: ../../userguide/configuration.rst:1607
msgid ""
"This backend can be configured via the :setting:`result_backend` set to a"
" Couchbase URL:"
msgstr ""

#: ../../userguide/configuration.rst:1617
msgid "``couchbase_backend_settings``"
msgstr ""

#: ../../userguide/configuration.rst:1625
msgid "Host name of the Couchbase server. Defaults to ``localhost``."
msgstr ""

#: ../../userguide/configuration.rst:1629
msgid "The port the Couchbase server is listening to. Defaults to ``8091``."
msgstr ""

#: ../../userguide/configuration.rst:1633
msgid ""
"The default bucket the Couchbase server is writing to. Defaults to "
"``default``."
msgstr ""

#: ../../userguide/configuration.rst:1636
#: ../../userguide/configuration.rst:1696
#: ../../userguide/configuration.rst:1791
msgid "``username``"
msgstr ""

#: ../../userguide/configuration.rst:1638
msgid "User name to authenticate to the Couchbase server as (optional)."
msgstr ""

#: ../../userguide/configuration.rst:1642
msgid "Password to authenticate to the Couchbase server (optional)."
msgstr ""

#: ../../userguide/configuration.rst:1647
msgid "ArangoDB backend settings"
msgstr ""

#: ../../userguide/configuration.rst:1651
msgid "The ArangoDB backend requires the :pypi:`pyArango` library."
msgstr ""

#: ../../userguide/configuration.rst:1662
msgid ""
"This backend can be configured via the :setting:`result_backend` set to a"
" ArangoDB URL:"
msgstr ""

#: ../../userguide/configuration.rst:1672
msgid "``arangodb_backend_settings``"
msgstr ""

#: ../../userguide/configuration.rst:1680
msgid "Host name of the ArangoDB server. Defaults to ``localhost``."
msgstr ""

#: ../../userguide/configuration.rst:1684
msgid "The port the ArangoDB server is listening to. Defaults to ``8529``."
msgstr ""

#: ../../userguide/configuration.rst:1688
msgid ""
"The default database in the ArangoDB server is writing to. Defaults to "
"``celery``."
msgstr ""

#: ../../userguide/configuration.rst:1691
msgid "``collection``"
msgstr ""

#: ../../userguide/configuration.rst:1693
msgid ""
"The default collection in the ArangoDB servers database is writing to. "
"Defaults to ``celery``."
msgstr ""

#: ../../userguide/configuration.rst:1698
msgid "User name to authenticate to the ArangoDB server as (optional)."
msgstr ""

#: ../../userguide/configuration.rst:1702
msgid "Password to authenticate to the ArangoDB server (optional)."
msgstr ""

#: ../../userguide/configuration.rst:1707
msgid "CosmosDB backend settings (experimental)"
msgstr ""

#: ../../userguide/configuration.rst:1709
msgid ""
"To use `CosmosDB`_ as the result backend, you simply need to configure "
"the :setting:`result_backend` setting with the correct URL."
msgstr ""

#: ../../userguide/configuration.rst:1722
msgid "``cosmosdbsql_database_name``"
msgstr ""

#: ../../userguide/configuration.rst:1724
msgid "Default: celerydb."
msgstr ""

#: ../../userguide/configuration.rst:1726
msgid "The name for the database in which to store the results."
msgstr ""

#: ../../userguide/configuration.rst:1731
msgid "``cosmosdbsql_collection_name``"
msgstr ""

#: ../../userguide/configuration.rst:1733
msgid "Default: celerycol."
msgstr ""

#: ../../userguide/configuration.rst:1735
msgid "The name of the collection in which to store the results."
msgstr ""

#: ../../userguide/configuration.rst:1740
msgid "``cosmosdbsql_consistency_level``"
msgstr ""

#: ../../userguide/configuration.rst:1742
msgid "Default: Session."
msgstr ""

#: ../../userguide/configuration.rst:1744
msgid ""
"Represents the consistency levels supported for Azure Cosmos DB client "
"operations."
msgstr ""

#: ../../userguide/configuration.rst:1746
msgid ""
"Consistency levels by order of strength are: Strong, BoundedStaleness, "
"Session, ConsistentPrefix and Eventual."
msgstr ""

#: ../../userguide/configuration.rst:1751
msgid "``cosmosdbsql_max_retry_attempts``"
msgstr ""

#: ../../userguide/configuration.rst:1753
msgid "Default: 9."
msgstr ""

#: ../../userguide/configuration.rst:1755
msgid "Maximum number of retries to be performed for a request."
msgstr ""

#: ../../userguide/configuration.rst:1760
msgid "``cosmosdbsql_max_retry_wait_time``"
msgstr ""

#: ../../userguide/configuration.rst:1762
msgid "Default: 30."
msgstr ""

#: ../../userguide/configuration.rst:1764
msgid ""
"Maximum wait time in seconds to wait for a request while the retries are "
"happening."
msgstr ""

#: ../../userguide/configuration.rst:1769
msgid "CouchDB backend settings"
msgstr ""

#: ../../userguide/configuration.rst:1773
msgid "The CouchDB backend requires the :pypi:`pycouchdb` library:"
msgstr ""

#: ../../userguide/configuration.rst:1775
msgid "To install this Couchbase package use :command:`pip`:"
msgstr ""

#: ../../userguide/configuration.rst:1784
msgid ""
"This backend can be configured via the :setting:`result_backend` set to a"
" CouchDB URL::"
msgstr ""

#: ../../userguide/configuration.rst:1789
msgid "The URL is formed out of the following parts:"
msgstr ""

#: ../../userguide/configuration.rst:1793
msgid "User name to authenticate to the CouchDB server as (optional)."
msgstr ""

#: ../../userguide/configuration.rst:1797
msgid "Password to authenticate to the CouchDB server (optional)."
msgstr ""

#: ../../userguide/configuration.rst:1801
msgid "Host name of the CouchDB server. Defaults to ``localhost``."
msgstr ""

#: ../../userguide/configuration.rst:1805
msgid "The port the CouchDB server is listening to. Defaults to ``8091``."
msgstr ""

#: ../../userguide/configuration.rst:1807
msgid "``container``"
msgstr ""

#: ../../userguide/configuration.rst:1809
msgid ""
"The default container the CouchDB server is writing to. Defaults to "
"``default``."
msgstr ""

#: ../../userguide/configuration.rst:1815
msgid "File-system backend settings"
msgstr ""

#: ../../userguide/configuration.rst:1817
msgid "This backend can be configured using a file URL, for example::"
msgstr ""

#: ../../userguide/configuration.rst:1821
msgid ""
"The configured directory needs to be shared and writable by all servers "
"using the backend."
msgstr ""

#: ../../userguide/configuration.rst:1824
msgid ""
"If you're trying Celery on a single system you can simply use the backend"
" without any further configuration. For larger clusters you could use "
"NFS, `GlusterFS`_, CIFS, `HDFS`_ (using FUSE), or any other file-system."
msgstr ""

#: ../../userguide/configuration.rst:1834
msgid "Consul K/V store backend settings"
msgstr ""

#: ../../userguide/configuration.rst:1836
msgid "The Consul backend can be configured using a URL, for example:"
msgstr ""

#: ../../userguide/configuration.rst:1838
msgid "CELERY_RESULT_BACKEND = 'consul://localhost:8500/'"
msgstr ""

#: ../../userguide/configuration.rst:1840
msgid ""
"The backend will storage results in the K/V store of Consul as individual"
" keys."
msgstr ""

#: ../../userguide/configuration.rst:1843
msgid "The backend supports auto expire of results using TTLs in Consul."
msgstr ""

#: ../../userguide/configuration.rst:1848
msgid "Message Routing"
msgstr ""

#: ../../userguide/configuration.rst:1855
msgid "``task_queues``"
msgstr ""

#: ../../userguide/configuration.rst:1857
msgid "Default: :const:`None` (queue taken from default queue settings)."
msgstr ""

#: ../../userguide/configuration.rst:1859
msgid ""
"Most users will not want to specify this setting and should rather use "
"the :ref:`automatic routing facilities <routing-automatic>`."
msgstr ""

#: ../../userguide/configuration.rst:1862
msgid ""
"If you really want to configure advanced routing, this setting should be "
"a list of :class:`kombu.Queue` objects the worker will consume from."
msgstr ""

#: ../../userguide/configuration.rst:1865
msgid ""
"Note that workers can be overridden this setting via the :option:`-Q "
"<celery worker -Q>` option, or individual queues from this list (by name)"
" can be excluded using the :option:`-X <celery worker -X>` option."
msgstr ""

#: ../../userguide/configuration.rst:1870
msgid "Also see :ref:`routing-basics` for more information."
msgstr ""

#: ../../userguide/configuration.rst:1872
msgid ""
"The default is a queue/exchange/binding key of ``celery``, with exchange "
"type ``direct``."
msgstr ""

#: ../../userguide/configuration.rst:1875
msgid "See also :setting:`task_routes`"
msgstr ""

#: ../../userguide/configuration.rst:1880
msgid "``task_routes``"
msgstr ""

#: ../../userguide/configuration.rst:1884
msgid ""
"A list of routers, or a single router used to route tasks to queues. When"
" deciding the final destination of a task the routers are consulted in "
"order."
msgstr ""

#: ../../userguide/configuration.rst:1888
msgid "A router can be specified as either:"
msgstr ""

#: ../../userguide/configuration.rst:1890
msgid ""
"A function with the signature ``(name, args, kwargs, options, task=None, "
"**kwargs)``"
msgstr ""

#: ../../userguide/configuration.rst:1892
msgid "A string providing the path to a router function."
msgstr ""

#: ../../userguide/configuration.rst:1893
msgid "A dict containing router specification:"
msgstr ""

#: ../../userguide/configuration.rst:1894
#: ../../userguide/configuration.rst:1896
msgid "Will be converted to a :class:`celery.routes.MapRoute` instance."
msgstr ""

#: ../../userguide/configuration.rst:1896
msgid "A list of ``(pattern, route)`` tuples:"
msgstr ""

#: ../../userguide/configuration.rst:1898
msgid "Examples:"
msgstr ""

#: ../../userguide/configuration.rst:1916
msgid "Where ``myapp.tasks.route_task`` could be:"
msgstr ""

#: ../../userguide/configuration.rst:1924
msgid ""
"``route_task`` may return a string or a dict. A string then means it's a "
"queue name in :setting:`task_queues`, a dict means it's a custom route."
msgstr ""

#: ../../userguide/configuration.rst:1927
msgid ""
"When sending tasks, the routers are consulted in order. The first router "
"that doesn't return ``None`` is the route to use. The message options is "
"then merged with the found route settings, where the task's settings have"
" priority."
msgstr ""

#: ../../userguide/configuration.rst:1932
msgid "Example if :func:`~celery.execute.apply_async` has these arguments:"
msgstr ""

#: ../../userguide/configuration.rst:1939
msgid "and a router returns:"
msgstr ""

#: ../../userguide/configuration.rst:1945
msgid "the final message options will be:"
msgstr ""

#: ../../userguide/configuration.rst:1951
msgid ""
"(and any default message options defined in the "
":class:`~celery.task.base.Task` class)"
msgstr ""

#: ../../userguide/configuration.rst:1954
msgid ""
"Values defined in :setting:`task_routes` have precedence over values "
"defined in :setting:`task_queues` when merging the two."
msgstr ""

#: ../../userguide/configuration.rst:1957
msgid "With the follow settings:"
msgstr ""

#: ../../userguide/configuration.rst:1976
msgid "The final routing options for ``tasks.add`` will become:"
msgstr ""

#: ../../userguide/configuration.rst:1984
msgid "See :ref:`routers` for more examples."
msgstr ""

#: ../../userguide/configuration.rst:1989
msgid "``task_queue_ha_policy``"
msgstr ""

#: ../../userguide/configuration.rst
msgid "brokers"
msgstr ""

#: ../../userguide/configuration.rst:1990
#: ../../userguide/configuration.rst:2017
#: ../../userguide/configuration.rst:2037 ../../userguide/monitoring.rst:370
#: ../../userguide/routing.rst:224
msgid "RabbitMQ"
msgstr ""

#: ../../userguide/configuration.rst:1994
msgid ""
"This will set the default HA policy for a queue, and the value can either"
" be a string (usually ``all``):"
msgstr ""

#: ../../userguide/configuration.rst:2001
msgid ""
"Using 'all' will replicate the queue to all current nodes, Or you can "
"give it a list of nodes to replicate to:"
msgstr ""

#: ../../userguide/configuration.rst:2008
msgid ""
"Using a list will implicitly set ``x-ha-policy`` to 'nodes' and ``x-ha-"
"policy-params`` to the given list of nodes."
msgstr ""

#: ../../userguide/configuration.rst:2011
msgid "See http://www.rabbitmq.com/ha.html for more information."
msgstr ""

#: ../../userguide/configuration.rst:2016
msgid "``task_queue_max_priority``"
msgstr ""

#: ../../userguide/configuration.rst:2021
#: ../../userguide/configuration.rst:2031
#: ../../userguide/configuration.rst:2051
msgid "See :ref:`routing-options-rabbitmq-priorities`."
msgstr ""

#: ../../userguide/configuration.rst:2026
msgid "``task_default_priority``"
msgstr ""

#: ../../userguide/configuration.rst:2027
msgid "RabbitMQ, Redis"
msgstr ""

#: ../../userguide/configuration.rst:2036
msgid "``task_inherit_parent_priority``"
msgstr ""

#: ../../userguide/configuration.rst:2039
msgid "Default: :const:`False`."
msgstr ""

#: ../../userguide/configuration.rst:2041
msgid "If enabled, child tasks will inherit priority of the parent task."
msgstr ""

#: ../../userguide/configuration.rst:2048
msgid ""
"Priority inheritance also works when calling child tasks from a parent "
"task with `delay` or `apply_async`."
msgstr ""

#: ../../userguide/configuration.rst:2057
msgid "``worker_direct``"
msgstr ""

#: ../../userguide/configuration.rst:2061
msgid ""
"This option enables so that every worker has a dedicated queue, so that "
"tasks can be routed to specific workers."
msgstr ""

#: ../../userguide/configuration.rst:2064
msgid ""
"The queue name for each worker is automatically generated based on the "
"worker hostname and a ``.dq`` suffix, using the ``C.dq`` exchange."
msgstr ""

#: ../../userguide/configuration.rst:2067
msgid ""
"For example the queue name for the worker with node name "
"``w1@example.com`` becomes::"
msgstr ""

#: ../../userguide/configuration.rst:2072
msgid ""
"Then you can route the task to the task by specifying the hostname as the"
" routing key and the ``C.dq`` exchange::"
msgstr ""

#: ../../userguide/configuration.rst:2082
msgid "``task_create_missing_queues``"
msgstr ""

#: ../../userguide/configuration.rst:2086
msgid ""
"If enabled (default), any queues specified that aren't defined in "
":setting:`task_queues` will be automatically created. See :ref:`routing-"
"automatic`."
msgstr ""

#: ../../userguide/configuration.rst:2093
msgid "``task_default_queue``"
msgstr ""

#: ../../userguide/configuration.rst:2095
#: ../../userguide/configuration.rst:2722
msgid "Default: ``\"celery\"``."
msgstr ""

#: ../../userguide/configuration.rst:2097
msgid ""
"The name of the default queue used by `.apply_async` if the message has "
"no route or no custom queue has been specified."
msgstr ""

#: ../../userguide/configuration.rst:2100
msgid ""
"This queue must be listed in :setting:`task_queues`. If "
":setting:`task_queues` isn't specified then it's automatically created "
"containing one queue entry, where this name is used as the name of that "
"queue."
msgstr ""

#: ../../userguide/configuration.rst:2107
msgid ":ref:`routing-changing-default-queue`"
msgstr ""

#: ../../userguide/configuration.rst:2112
msgid "``task_default_exchange``"
msgstr ""

#: ../../userguide/configuration.rst:2114
#: ../../userguide/configuration.rst:2134
msgid "Default: Uses the value set for :setting:`task_default_queue`."
msgstr ""

#: ../../userguide/configuration.rst:2116
msgid ""
"Name of the default exchange to use when no custom exchange is specified "
"for a key in the :setting:`task_queues` setting."
msgstr ""

#: ../../userguide/configuration.rst:2122
msgid "``task_default_exchange_type``"
msgstr ""

#: ../../userguide/configuration.rst:2124
msgid "Default: ``\"direct\"``."
msgstr ""

#: ../../userguide/configuration.rst:2126
msgid ""
"Default exchange type used when no custom exchange type is specified for "
"a key in the :setting:`task_queues` setting."
msgstr ""

#: ../../userguide/configuration.rst:2132
msgid "``task_default_routing_key``"
msgstr ""

#: ../../userguide/configuration.rst:2136
msgid ""
"The default routing key used when no custom routing key is specified for "
"a key in the :setting:`task_queues` setting."
msgstr ""

#: ../../userguide/configuration.rst:2142
msgid "``task_default_delivery_mode``"
msgstr ""

#: ../../userguide/configuration.rst:2144
msgid "Default: ``\"persistent\"``."
msgstr ""

#: ../../userguide/configuration.rst:2146
msgid ""
"Can be `transient` (messages not written to disk) or `persistent` "
"(written to disk)."
msgstr ""

#: ../../userguide/configuration.rst:2152
msgid "Broker Settings"
msgstr ""

#: ../../userguide/configuration.rst:2157
msgid "``broker_url``"
msgstr ""

#: ../../userguide/configuration.rst:2159
msgid "Default: ``\"amqp://\"``"
msgstr ""

#: ../../userguide/configuration.rst:2161
msgid "Default broker URL. This must be a URL in the form of::"
msgstr ""

#: ../../userguide/configuration.rst:2165
msgid ""
"Only the scheme part (``transport://``) is required, the rest is "
"optional, and defaults to the specific transports default values."
msgstr ""

#: ../../userguide/configuration.rst:2168
msgid ""
"The transport part is the broker implementation to use, and the default "
"is ``amqp``, (uses ``librabbitmq`` if installed or falls back to "
"``pyamqp``). There are also other choices available, including; "
"``redis://``, ``sqs://``, and ``qpid://``."
msgstr ""

#: ../../userguide/configuration.rst:2173
msgid ""
"The scheme can also be a fully qualified path to your own transport "
"implementation::"
msgstr ""

#: ../../userguide/configuration.rst:2178
msgid ""
"More than one broker URL, of the same transport, can also be specified. "
"The broker URLs can be passed in as a single string that's semicolon "
"delimited::"
msgstr ""

#: ../../userguide/configuration.rst:2183
msgid "Or as a list::"
msgstr ""

#: ../../userguide/configuration.rst:2190
msgid "The brokers will then be used in the :setting:`broker_failover_strategy`."
msgstr ""

#: ../../userguide/configuration.rst:2192
msgid ""
"See :ref:`kombu:connection-urls` in the Kombu documentation for more "
"information."
msgstr ""

#: ../../userguide/configuration.rst:2200
msgid "``broker_read_url`` / ``broker_write_url``"
msgstr ""

#: ../../userguide/configuration.rst:2202
msgid "Default: Taken from :setting:`broker_url`."
msgstr ""

#: ../../userguide/configuration.rst:2204
msgid ""
"These settings can be configured, instead of :setting:`broker_url` to "
"specify different connection parameters for broker connections used for "
"consuming and producing."
msgstr ""

#: ../../userguide/configuration.rst:2213
msgid ""
"Both options can also be specified as a list for failover alternates, see"
" :setting:`broker_url` for more information."
msgstr ""

#: ../../userguide/configuration.rst:2219
msgid "``broker_failover_strategy``"
msgstr ""

#: ../../userguide/configuration.rst:2221
msgid "Default: ``\"round-robin\"``."
msgstr ""

#: ../../userguide/configuration.rst:2223
msgid ""
"Default failover strategy for the broker Connection object. If supplied, "
"may map to a key in 'kombu.connection.failover_strategies', or be a "
"reference to any method that yields a single item from a supplied list."
msgstr ""

#: ../../userguide/configuration.rst:2242
msgid "``broker_heartbeat``"
msgstr ""

#: ../../userguide/configuration.rst
msgid "transports supported"
msgstr ""

#: ../../userguide/configuration.rst:2243
#: ../../userguide/configuration.rst:2265
#: ../../userguide/configuration.rst:2288
msgid "``pyamqp``"
msgstr ""

#: ../../userguide/configuration.rst:2245
msgid "Default: ``120.0`` (negotiated by server)."
msgstr ""

#: ../../userguide/configuration.rst:2247
msgid ""
"Note: This value is only used by the worker, clients do not use a "
"heartbeat at the moment."
msgstr ""

#: ../../userguide/configuration.rst:2250
msgid ""
"It's not always possible to detect connection loss in a timely manner "
"using TCP/IP alone, so AMQP defines something called heartbeats that's is"
" used both by the client and the broker to detect if a connection was "
"closed."
msgstr ""

#: ../../userguide/configuration.rst:2255
msgid ""
"If the heartbeat value is 10 seconds, then the heartbeat will be "
"monitored at the interval specified by the "
":setting:`broker_heartbeat_checkrate` setting (by default this is set to "
"double the rate of the heartbeat value, so for the 10 seconds, the "
"heartbeat is checked every 5 seconds)."
msgstr ""

#: ../../userguide/configuration.rst:2264
msgid "``broker_heartbeat_checkrate``"
msgstr ""

#: ../../userguide/configuration.rst:2267
msgid "Default: 2.0."
msgstr ""

#: ../../userguide/configuration.rst:2269
msgid ""
"At intervals the worker will monitor that the broker hasn't missed too "
"many heartbeats. The rate at which this is checked is calculated by "
"dividing the :setting:`broker_heartbeat` value with this value, so if the"
" heartbeat is 10.0 and the rate is the default 2.0, the check will be "
"performed every 5 seconds (twice the heartbeat sending rate)."
msgstr ""

#: ../../userguide/configuration.rst:2278
msgid "``broker_use_ssl``"
msgstr ""

#: ../../userguide/configuration.rst:2279
msgid "``pyamqp``, ``redis``"
msgstr ""

#: ../../userguide/configuration.rst:2283
msgid "Toggles SSL usage on broker connection and SSL settings."
msgstr ""

#: ../../userguide/configuration.rst:2285
msgid "The valid values for this option vary by transport."
msgstr ""

#: ../../userguide/configuration.rst:2290
msgid ""
"If ``True`` the connection will use SSL with default SSL settings. If set"
" to a dict, will configure SSL connection according to the specified "
"policy. The format used is Python's :func:`ssl.wrap_socket` options."
msgstr ""

#: ../../userguide/configuration.rst:2294
msgid "Note that SSL socket is generally served on a separate port by the broker."
msgstr ""

#: ../../userguide/configuration.rst:2296
msgid ""
"Example providing a client cert and validating the server cert against a "
"custom certificate authority:"
msgstr ""

#: ../../userguide/configuration.rst:2312
msgid ""
"Be careful using ``broker_use_ssl=True``. It's possible that your default"
" configuration won't validate the server cert at all. Please read Python "
"`ssl module security considerations "
"<https://docs.python.org/3/library/ssl.html#ssl-security>`_."
msgstr ""

#: ../../userguide/configuration.rst:2321
msgid "The setting must be a dict with the following keys:"
msgstr ""

#: ../../userguide/configuration.rst:2325
msgid ""
"``ssl_cert_reqs`` (required): one of the ``SSLContext.verify_mode`` "
"values:"
msgstr ""

#: ../../userguide/configuration.rst:2324
msgid "``ssl.CERT_NONE``"
msgstr ""

#: ../../userguide/configuration.rst:2325
msgid "``ssl.CERT_OPTIONAL``"
msgstr ""

#: ../../userguide/configuration.rst:2326
msgid "``ssl.CERT_REQUIRED``"
msgstr ""

#: ../../userguide/configuration.rst:2327
msgid "``ssl_ca_certs`` (optional): path to the CA certificate"
msgstr ""

#: ../../userguide/configuration.rst:2328
msgid "``ssl_certfile`` (optional): path to the client certificate"
msgstr ""

#: ../../userguide/configuration.rst:2329
msgid "``ssl_keyfile`` (optional): path to the client key"
msgstr ""

#: ../../userguide/configuration.rst:2335
msgid "``broker_pool_limit``"
msgstr ""

#: ../../userguide/configuration.rst:2339
msgid "Default: 10."
msgstr ""

#: ../../userguide/configuration.rst:2341
msgid "The maximum number of connections that can be open in the connection pool."
msgstr ""

#: ../../userguide/configuration.rst:2343
msgid ""
"The pool is enabled by default since version 2.5, with a default limit of"
" ten connections. This number can be tweaked depending on the number of "
"threads/green-threads (eventlet/gevent) using a connection. For example "
"running eventlet with 1000 greenlets that use a connection to the broker,"
" contention can arise and you should consider increasing the limit."
msgstr ""

#: ../../userguide/configuration.rst:2349
msgid ""
"If set to :const:`None` or 0 the connection pool will be disabled and "
"connections will be established and closed for every use."
msgstr ""

#: ../../userguide/configuration.rst:2355
msgid "``broker_connection_timeout``"
msgstr ""

#: ../../userguide/configuration.rst:2357
#: ../../userguide/configuration.rst:2586
msgid "Default: 4.0."
msgstr ""

#: ../../userguide/configuration.rst:2359
msgid ""
"The default timeout in seconds before we give up establishing a "
"connection to the AMQP server. This setting is disabled when using "
"gevent."
msgstr ""

#: ../../userguide/configuration.rst:2365
msgid ""
"The broker connection timeout only applies to a worker attempting to "
"connect to the broker. It does not apply to producer sending a task, see "
":setting:`broker_transport_options` for how to provide a timeout for that"
" situation."
msgstr ""

#: ../../userguide/configuration.rst:2373
msgid "``broker_connection_retry``"
msgstr ""

#: ../../userguide/configuration.rst:2377
msgid ""
"Automatically try to re-establish the connection to the AMQP broker if "
"lost."
msgstr ""

#: ../../userguide/configuration.rst:2379
msgid ""
"The time between retries is increased for each retry, and is not "
"exhausted before :setting:`broker_connection_max_retries` is exceeded."
msgstr ""

#: ../../userguide/configuration.rst:2386
msgid "``broker_connection_max_retries``"
msgstr ""

#: ../../userguide/configuration.rst:2388
msgid "Default: 100."
msgstr ""

#: ../../userguide/configuration.rst:2390
msgid ""
"Maximum number of retries before we give up re-establishing a connection "
"to the AMQP broker."
msgstr ""

#: ../../userguide/configuration.rst:2393
msgid "If this is set to :const:`0` or :const:`None`, we'll retry forever."
msgstr ""

#: ../../userguide/configuration.rst:2398
msgid "``broker_login_method``"
msgstr ""

#: ../../userguide/configuration.rst:2400
msgid "Default: ``\"AMQPLAIN\"``."
msgstr ""

#: ../../userguide/configuration.rst:2402
msgid "Set custom amqp login method."
msgstr ""

#: ../../userguide/configuration.rst:2407
msgid "``broker_transport_options``"
msgstr ""

#: ../../userguide/configuration.rst:2427 ../../userguide/extending.rst:111
#: ../../userguide/security.rst:64
msgid "Worker"
msgstr ""

#: ../../userguide/configuration.rst:2432
msgid "``imports``"
msgstr ""

#: ../../userguide/configuration.rst:2436
msgid "A sequence of modules to import when the worker starts."
msgstr ""

#: ../../userguide/configuration.rst:2438
msgid ""
"This is used to specify the task modules to import, but also to import "
"signal handlers and additional remote control commands, etc."
msgstr ""

#: ../../userguide/configuration.rst:2441
msgid "The modules will be imported in the original order."
msgstr ""

#: ../../userguide/configuration.rst:2446
msgid "``include``"
msgstr ""

#: ../../userguide/configuration.rst:2450
msgid ""
"Exact same semantics as :setting:`imports`, but can be used as a means to"
" have different import categories."
msgstr ""

#: ../../userguide/configuration.rst:2453
msgid ""
"The modules in this setting are imported after the modules in "
":setting:`imports`."
msgstr ""

#: ../../userguide/configuration.rst:2461
msgid "``worker_concurrency``"
msgstr ""

#: ../../userguide/configuration.rst:2463
msgid "Default: Number of CPU cores."
msgstr ""

#: ../../userguide/configuration.rst:2465
msgid ""
"The number of concurrent worker processes/threads/green threads executing"
" tasks."
msgstr ""

#: ../../userguide/configuration.rst:2468
msgid ""
"If you're doing mostly I/O you can have more processes, but if mostly "
"CPU-bound, try to keep it close to the number of CPUs on your machine. If"
" not set, the number of CPUs/cores on the host will be used."
msgstr ""

#: ../../userguide/configuration.rst:2476
msgid "``worker_prefetch_multiplier``"
msgstr ""

#: ../../userguide/configuration.rst:2478
msgid "Default: 4."
msgstr ""

#: ../../userguide/configuration.rst:2480
msgid ""
"How many messages to prefetch at a time multiplied by the number of "
"concurrent processes. The default is 4 (four messages for each process). "
"The default setting is usually a good choice, however -- if you have very"
" long running tasks waiting in the queue and you have to start the "
"workers, note that the first worker to start will receive four times the "
"number of messages initially. Thus the tasks may not be fairly "
"distributed to the workers."
msgstr ""

#: ../../userguide/configuration.rst:2488
msgid ""
"To disable prefetching, set :setting:`worker_prefetch_multiplier` to 1. "
"Changing that setting to 0 will allow the worker to keep consuming as "
"many messages as it wants."
msgstr ""

#: ../../userguide/configuration.rst:2492
msgid "For more on prefetching, read :ref:`optimizing-prefetch-limit`"
msgstr ""

#: ../../userguide/configuration.rst:2496
msgid "Tasks with ETA/countdown aren't affected by prefetch limits."
msgstr ""

#: ../../userguide/configuration.rst:2501
msgid "``worker_lost_wait``"
msgstr ""

#: ../../userguide/configuration.rst:2505
msgid ""
"In some cases a worker may be killed without proper cleanup, and the "
"worker may have published a result before terminating. This value "
"specifies how long we wait for any missing results before raising a "
":exc:`@WorkerLostError` exception."
msgstr ""

#: ../../userguide/configuration.rst:2513
msgid "``worker_max_tasks_per_child``"
msgstr ""

#: ../../userguide/configuration.rst:2515
msgid ""
"Maximum number of tasks a pool worker process can execute before it's "
"replaced with a new one. Default is no limit."
msgstr ""

#: ../../userguide/configuration.rst:2521
msgid "``worker_max_memory_per_child``"
msgstr ""

#: ../../userguide/configuration.rst:2523
msgid "Default: No limit. Type: int (kilobytes)"
msgstr ""

#: ../../userguide/configuration.rst:2526
msgid ""
"Maximum amount of resident memory, in kilobytes, that may be consumed by "
"a worker before it will be replaced by a new worker. If a single task "
"causes a worker to exceed this limit, the task will be completed, and the"
" worker will be replaced afterwards."
msgstr ""

#: ../../userguide/configuration.rst:2531 ../../userguide/tasks.rst:895
#: ../../userguide/testing.rst:136 ../../userguide/testing.rst:154
#: ../../userguide/testing.rst:186 ../../userguide/testing.rst:208
#: ../../userguide/testing.rst:230 ../../userguide/testing.rst:247
#: ../../userguide/testing.rst:262 ../../userguide/testing.rst:278
#: ../../userguide/testing.rst:297 ../../userguide/testing.rst:330
msgid "Example:"
msgstr ""

#: ../../userguide/configuration.rst:2540
msgid "``worker_disable_rate_limits``"
msgstr ""

#: ../../userguide/configuration.rst:2542
msgid "Default: Disabled (rate limits enabled)."
msgstr ""

#: ../../userguide/configuration.rst:2544
msgid "Disable all rate limits, even if tasks has explicit rate limits set."
msgstr ""

#: ../../userguide/configuration.rst:2549
msgid "``worker_state_db``"
msgstr ""

#: ../../userguide/configuration.rst:2553
msgid ""
"Name of the file used to stores persistent worker state (like revoked "
"tasks). Can be a relative or absolute path, but be aware that the suffix "
"`.db` may be appended to the file name (depending on Python version)."
msgstr ""

#: ../../userguide/configuration.rst:2557
msgid "Can also be set via the :option:`celery worker --statedb` argument."
msgstr ""

#: ../../userguide/configuration.rst:2562
msgid "``worker_timer_precision``"
msgstr ""

#: ../../userguide/configuration.rst:2564
msgid "Default: 1.0 seconds."
msgstr ""

#: ../../userguide/configuration.rst:2566
msgid ""
"Set the maximum time in seconds that the ETA scheduler can sleep between "
"rechecking the schedule."
msgstr ""

#: ../../userguide/configuration.rst:2569
msgid ""
"Setting this value to 1 second means the schedulers precision will be 1 "
"second. If you need near millisecond precision you can set this to 0.1."
msgstr ""

#: ../../userguide/configuration.rst:2575
msgid "``worker_enable_remote_control``"
msgstr ""

#: ../../userguide/configuration.rst:2577
#: ../../userguide/configuration.rst:2801
msgid "Default: Enabled by default."
msgstr ""

#: ../../userguide/configuration.rst:2579
msgid "Specify if remote control of the workers is enabled."
msgstr ""

#: ../../userguide/configuration.rst:2584
msgid "``worker_proc_alive_timeout``"
msgstr ""

#: ../../userguide/configuration.rst:2588
msgid ""
"The timeout in seconds (int/float) when waiting for a new worker process "
"to start up."
msgstr ""

#: ../../userguide/configuration.rst:2593 ../../userguide/monitoring.rst:491
msgid "Events"
msgstr ""

#: ../../userguide/configuration.rst:2598
msgid "``worker_send_task_events``"
msgstr ""

#: ../../userguide/configuration.rst:2602
msgid ""
"Send task-related events so that tasks can be monitored using tools like "
"`flower`. Sets the default value for the workers :option:`-E <celery "
"worker -E>` argument."
msgstr ""

#: ../../userguide/configuration.rst:2609
msgid "``task_send_sent_event``"
msgstr ""

#: ../../userguide/configuration.rst:2615
msgid ""
"If enabled, a :event:`task-sent` event will be sent for every task so "
"tasks can be tracked before they're consumed by a worker."
msgstr ""

#: ../../userguide/configuration.rst:2621
msgid "``event_queue_ttl``"
msgstr ""

#: ../../userguide/configuration.rst:2622
#: ../../userguide/configuration.rst:2636
msgid "``amqp``"
msgstr ""

#: ../../userguide/configuration.rst:2624
msgid "Default: 5.0 seconds."
msgstr ""

#: ../../userguide/configuration.rst:2626
msgid ""
"Message expiry time in seconds (int/float) for when messages sent to a "
"monitor clients event queue is deleted (``x-message-ttl``)"
msgstr ""

#: ../../userguide/configuration.rst:2629
msgid ""
"For example, if this value is set to 10 then a message delivered to this "
"queue will be deleted after 10 seconds."
msgstr ""

#: ../../userguide/configuration.rst:2635
msgid "``event_queue_expires``"
msgstr ""

#: ../../userguide/configuration.rst:2638
msgid "Default: 60.0 seconds."
msgstr ""

#: ../../userguide/configuration.rst:2640
msgid ""
"Expiry time in seconds (int/float) for when after a monitor clients event"
" queue will be deleted (``x-expires``)."
msgstr ""

#: ../../userguide/configuration.rst:2646
msgid "``event_queue_prefix``"
msgstr ""

#: ../../userguide/configuration.rst:2648
#: ../../userguide/configuration.rst:2657
msgid "Default: ``\"celeryev\"``."
msgstr ""

#: ../../userguide/configuration.rst:2650
msgid "The prefix to use for event receiver queue names."
msgstr ""

#: ../../userguide/configuration.rst:2655
msgid "``event_exchange``"
msgstr ""

#: ../../userguide/configuration.rst:2659
msgid "Name of the event exchange."
msgstr ""

#: ../../userguide/configuration.rst:2663
#: ../../userguide/configuration.rst:2728
msgid "This option is in experimental stage, please use it with caution."
msgstr ""

#: ../../userguide/configuration.rst:2668
msgid "``event_serializer``"
msgstr ""

#: ../../userguide/configuration.rst:2670
msgid "Default: ``\"json\"``."
msgstr ""

#: ../../userguide/configuration.rst:2672
msgid "Message serialization format used when sending event messages."
msgstr ""

#: ../../userguide/configuration.rst:2682
msgid "Remote Control Commands"
msgstr ""

#: ../../userguide/configuration.rst:2686
msgid ""
"To disable remote control commands see the "
":setting:`worker_enable_remote_control` setting."
msgstr ""

#: ../../userguide/configuration.rst:2692
msgid "``control_queue_ttl``"
msgstr ""

#: ../../userguide/configuration.rst:2694
msgid "Default: 300.0"
msgstr ""

#: ../../userguide/configuration.rst:2696
msgid ""
"Time in seconds, before a message in a remote control command queue will "
"expire."
msgstr ""

#: ../../userguide/configuration.rst:2699
msgid ""
"If using the default of 300 seconds, this means that if a remote control "
"command is sent and no worker picks it up within 300 seconds, the command"
" is discarded."
msgstr ""

#: ../../userguide/configuration.rst:2703
#: ../../userguide/configuration.rst:2715
msgid "This setting also applies to remote control reply queues."
msgstr ""

#: ../../userguide/configuration.rst:2708
msgid "``control_queue_expires``"
msgstr ""

#: ../../userguide/configuration.rst:2710
msgid "Default: 10.0"
msgstr ""

#: ../../userguide/configuration.rst:2712
msgid ""
"Time in seconds, before an unused remote control command queue is deleted"
" from the broker."
msgstr ""

#: ../../userguide/configuration.rst:2720
msgid "``control_exchange``"
msgstr ""

#: ../../userguide/configuration.rst:2724
msgid "Name of the control command exchange."
msgstr ""

#: ../../userguide/configuration.rst:2733 ../../userguide/tasks.rst:479
msgid "Logging"
msgstr ""

#: ../../userguide/configuration.rst:2738
msgid "``worker_hijack_root_logger``"
msgstr ""

#: ../../userguide/configuration.rst:2742
msgid "Default: Enabled by default (hijack root logger)."
msgstr ""

#: ../../userguide/configuration.rst:2744
msgid ""
"By default any previously configured handlers on the root logger will be "
"removed. If you want to customize your own logging handlers, then you can"
" disable this behavior by setting `worker_hijack_root_logger = False`."
msgstr ""

#: ../../userguide/configuration.rst:2751
msgid ""
"Logging can also be customized by connecting to the "
":signal:`celery.signals.setup_logging` signal."
msgstr ""

#: ../../userguide/configuration.rst:2757
msgid "``worker_log_color``"
msgstr ""

#: ../../userguide/configuration.rst:2759
msgid "Default: Enabled if app is logging to a terminal."
msgstr ""

#: ../../userguide/configuration.rst:2761
msgid "Enables/disables colors in logging output by the Celery apps."
msgstr ""

#: ../../userguide/configuration.rst:2766
msgid "``worker_log_format``"
msgstr ""

#: ../../userguide/configuration.rst:2768
#: ../../userguide/configuration.rst:2784
msgid "Default:"
msgstr ""

#: ../../userguide/configuration.rst:2774
msgid "The format to use for log messages."
msgstr ""

#: ../../userguide/configuration.rst:2776
#: ../../userguide/configuration.rst:2793
msgid ""
"See the Python :mod:`logging` module for more information about log "
"formats."
msgstr ""

#: ../../userguide/configuration.rst:2782
msgid "``worker_task_log_format``"
msgstr ""

#: ../../userguide/configuration.rst:2791
msgid "The format to use for log messages logged in tasks."
msgstr ""

#: ../../userguide/configuration.rst:2799
msgid "``worker_redirect_stdouts``"
msgstr ""

#: ../../userguide/configuration.rst:2803
msgid "If enabled `stdout` and `stderr` will be redirected to the current logger."
msgstr ""

#: ../../userguide/configuration.rst:2806
msgid "Used by :program:`celery worker` and :program:`celery beat`."
msgstr ""

#: ../../userguide/configuration.rst:2811
msgid "``worker_redirect_stdouts_level``"
msgstr ""

#: ../../userguide/configuration.rst:2813
msgid "Default: :const:`WARNING`."
msgstr ""

#: ../../userguide/configuration.rst:2815
msgid ""
"The log level output to `stdout` and `stderr` is logged as. Can be one of"
" :const:`DEBUG`, :const:`INFO`, :const:`WARNING`, :const:`ERROR`, or "
":const:`CRITICAL`."
msgstr ""

#: ../../userguide/configuration.rst:2827
msgid "``security_key``"
msgstr ""

#: ../../userguide/configuration.rst:2833
msgid ""
"The relative or absolute path to a file containing the private key used "
"to sign messages when :ref:`message-signing` is used."
msgstr ""

#: ../../userguide/configuration.rst:2839
msgid "``security_certificate``"
msgstr ""

#: ../../userguide/configuration.rst:2845
msgid ""
"The relative or absolute path to an X.509 certificate file used to sign "
"messages when :ref:`message-signing` is used."
msgstr ""

#: ../../userguide/configuration.rst:2851
msgid "``security_cert_store``"
msgstr ""

#: ../../userguide/configuration.rst:2857
msgid ""
"The directory containing X.509 certificates used for :ref:`message-"
"signing`. Can be a glob with wild-cards, (for example "
":file:`/etc/certs/*.pem`)."
msgstr ""

#: ../../userguide/configuration.rst:2864
msgid "``security_digest``"
msgstr ""

#: ../../userguide/configuration.rst:2866
msgid "Default: :const:`sha256`."
msgstr ""

#: ../../userguide/configuration.rst:2870
msgid ""
"A cryptography digest used to sign messages when :ref:`message-signing` "
"is used. https://cryptography.io/en/latest/hazmat/primitives"
"/cryptographic-hashes/#module-cryptography.hazmat.primitives.hashes"
msgstr ""

#: ../../userguide/configuration.rst:2877
msgid "Custom Component Classes (advanced)"
msgstr ""

#: ../../userguide/configuration.rst:2882
msgid "``worker_pool``"
msgstr ""

#: ../../userguide/configuration.rst:2884
msgid "Default: ``\"prefork\"`` (``celery.concurrency.prefork:TaskPool``)."
msgstr ""

#: ../../userguide/configuration.rst:2886
msgid "Name of the pool class used by the worker."
msgstr ""

#: ../../userguide/configuration.rst:2888
msgid "Eventlet/Gevent"
msgstr ""

#: ../../userguide/configuration.rst:2890
msgid ""
"Never use this option to select the eventlet or gevent pool. You must use"
" the :option:`-P <celery worker -P>` option to :program:`celery worker` "
"instead, to ensure the monkey patches aren't applied too late, causing "
"things to break in strange ways."
msgstr ""

#: ../../userguide/configuration.rst:2898
msgid "``worker_pool_restarts``"
msgstr ""

#: ../../userguide/configuration.rst:2902
msgid ""
"If enabled the worker pool can be restarted using the "
":control:`pool_restart` remote control command."
msgstr ""

#: ../../userguide/configuration.rst:2908
msgid "``worker_autoscaler``"
msgstr ""

#: ../../userguide/configuration.rst:2912
msgid "Default: ``\"celery.worker.autoscale:Autoscaler\"``."
msgstr ""

#: ../../userguide/configuration.rst:2914
msgid "Name of the autoscaler class to use."
msgstr ""

#: ../../userguide/configuration.rst:2919
msgid "``worker_consumer``"
msgstr ""

#: ../../userguide/configuration.rst:2921
msgid "Default: ``\"celery.worker.consumer:Consumer\"``."
msgstr ""

#: ../../userguide/configuration.rst:2923
msgid "Name of the consumer class used by the worker."
msgstr ""

#: ../../userguide/configuration.rst:2928
msgid "``worker_timer``"
msgstr ""

#: ../../userguide/configuration.rst:2930
msgid "Default: ``\"kombu.asynchronous.hub.timer:Timer\"``."
msgstr ""

#: ../../userguide/configuration.rst:2932
msgid ""
"Name of the ETA scheduler class used by the worker. Default is or set by "
"the pool implementation."
msgstr ""

#: ../../userguide/configuration.rst:2938
msgid "Beat Settings (:program:`celery beat`)"
msgstr ""

#: ../../userguide/configuration.rst:2943
msgid "``beat_schedule``"
msgstr ""

#: ../../userguide/configuration.rst:2947
msgid ""
"The periodic task schedule used by :mod:`~celery.bin.beat`. See :ref"
":`beat-entries`."
msgstr ""

#: ../../userguide/configuration.rst:2953
msgid "``beat_scheduler``"
msgstr ""

#: ../../userguide/configuration.rst:2955
msgid "Default: ``\"celery.beat:PersistentScheduler\"``."
msgstr ""

#: ../../userguide/configuration.rst:2957
msgid ""
"The default scheduler class. May be set to "
"``\"django_celery_beat.schedulers:DatabaseScheduler\"`` for instance, if "
"used alongside `django-celery-beat` extension."
msgstr ""

#: ../../userguide/configuration.rst:2961
msgid "Can also be set via the :option:`celery beat -S` argument."
msgstr ""

#: ../../userguide/configuration.rst:2966
msgid "``beat_schedule_filename``"
msgstr ""

#: ../../userguide/configuration.rst:2968
msgid "Default: ``\"celerybeat-schedule\"``."
msgstr ""

#: ../../userguide/configuration.rst:2970
msgid ""
"Name of the file used by `PersistentScheduler` to store the last run "
"times of periodic tasks. Can be a relative or absolute path, but be aware"
" that the suffix `.db` may be appended to the file name (depending on "
"Python version)."
msgstr ""

#: ../../userguide/configuration.rst:2974
msgid "Can also be set via the :option:`celery beat --schedule` argument."
msgstr ""

#: ../../userguide/configuration.rst:2979
msgid "``beat_sync_every``"
msgstr ""

#: ../../userguide/configuration.rst:2981
#: ../../userguide/configuration.rst:2994
msgid "Default: 0."
msgstr ""

#: ../../userguide/configuration.rst:2983
msgid ""
"The number of periodic tasks that can be called before another database "
"sync is issued. A value of 0 (default) means sync based on timing - "
"default of 3 minutes as determined by scheduler.sync_every. If set to 1, "
"beat will call sync after every task message sent."
msgstr ""

#: ../../userguide/configuration.rst:2992
msgid "``beat_max_loop_interval``"
msgstr ""

#: ../../userguide/configuration.rst:2996
msgid ""
"The maximum number of seconds :mod:`~celery.bin.beat` can sleep between "
"checking the schedule."
msgstr ""

#: ../../userguide/configuration.rst:2999
msgid ""
"The default for this value is scheduler specific. For the default Celery "
"beat scheduler the value is 300 (5 minutes), but for the :pypi:`django-"
"celery-beat` database scheduler it's 5 seconds because the schedule may "
"be changed externally, and so it must take changes to the schedule into "
"account."
msgstr ""

#: ../../userguide/configuration.rst:3005
msgid ""
"Also when running Celery beat embedded (:option:`-B <celery worker -B>`) "
"on Jython as a thread the max interval is overridden and set to 1 so that"
" it's possible to shut down in a timely manner."
msgstr ""

#: ../../userguide/daemonizing.rst:5
msgid "Daemonization"
msgstr ""

#: ../../userguide/daemonizing.rst:10
msgid ""
"Most Linux distributions these days use systemd for managing the "
"lifecycle of system and user services."
msgstr ""

#: ../../userguide/daemonizing.rst:13
msgid "You can check if your Linux distribution uses systemd by typing:"
msgstr ""

#: ../../userguide/daemonizing.rst:21
msgid ""
"If you have output similar to the above, please refer to :ref:`our "
"systemd documentation <daemon-systemd-generic>` for guidance."
msgstr ""

#: ../../userguide/daemonizing.rst:24
msgid ""
"However, the init.d script should still work in those Linux distributions"
" as well since systemd provides the systemd-sysv compatiblity layer which"
" generates services automatically from the init.d scripts we provide."
msgstr ""

#: ../../userguide/daemonizing.rst:28
msgid ""
"If you package Celery for multiple Linux distributions and some do not "
"support systemd or to other Unix systems as well, you may want to refer "
"to :ref:`our init.d documentation <daemon-generic>`."
msgstr ""

#: ../../userguide/daemonizing.rst:35
msgid "Generic init-scripts"
msgstr ""

#: ../../userguide/daemonizing.rst:37
msgid "See the `extra/generic-init.d/`_ directory Celery distribution."
msgstr ""

#: ../../userguide/daemonizing.rst:39
msgid ""
"This directory contains generic bash init-scripts for the "
":program:`celery worker` program, these should run on Linux, FreeBSD, "
"OpenBSD, and other Unix-like platforms."
msgstr ""

#: ../../userguide/daemonizing.rst:49
msgid "Init-script: ``celeryd``"
msgstr ""

#: ../../userguide/daemonizing.rst ../../userguide/monitoring.rst:277
#: celery.contrib.sphinx:7 of
msgid "Usage"
msgstr ""

#: ../../userguide/daemonizing.rst:51
msgid "`/etc/init.d/celeryd {start|stop|restart|status}`"
msgstr ""

#: ../../userguide/daemonizing.rst
msgid "Configuration file"
msgstr ""

#: ../../userguide/daemonizing.rst:52
msgid ":file:`/etc/default/celeryd`"
msgstr ""

#: ../../userguide/daemonizing.rst:54
msgid ""
"To configure this script to run the worker properly you probably need to "
"at least tell it where to change directory to when it starts (to find the"
" module containing your app, or your configuration module)."
msgstr ""

#: ../../userguide/daemonizing.rst:59
msgid ""
"The daemonization script is configured by the file "
":file:`/etc/default/celeryd`. This is a shell (:command:`sh`) script "
"where you can add environment variables like the configuration options "
"below.  To add real environment variables affecting the worker you must "
"also export them (e.g., :command:`export DISPLAY=\":0\"`)"
msgstr ""

#: ../../userguide/daemonizing.rst:64
msgid "Superuser privileges required"
msgstr ""

#: ../../userguide/daemonizing.rst:66
msgid ""
"The init-scripts can only be used by root, and the shell configuration "
"file must also be owned by root."
msgstr ""

#: ../../userguide/daemonizing.rst:69
msgid ""
"Unprivileged users don't need to use the init-script, instead they can "
"use the :program:`celery multi` utility (or :program:`celery worker "
"--detach`):"
msgstr ""

#: ../../userguide/daemonizing.rst:92
msgid "This is an example configuration for a Python project."
msgstr ""

#: ../../userguide/daemonizing.rst:94
msgid ":file:`/etc/default/celeryd`:"
msgstr ""

#: ../../userguide/daemonizing.rst:143
msgid "Using a login shell"
msgstr ""

#: ../../userguide/daemonizing.rst:145
msgid ""
"You can inherit the environment of the ``CELERYD_USER`` by using a login "
"shell:"
msgstr ""

#: ../../userguide/daemonizing.rst:152
msgid ""
"Note that this isn't recommended, and that you should only use this "
"option when absolutely necessary."
msgstr ""

#: ../../userguide/daemonizing.rst:158 ../../userguide/daemonizing.rst:275
msgid "Example Django configuration"
msgstr ""

#: ../../userguide/daemonizing.rst:160
msgid ""
"Django users now uses the exact same template as above, but make sure "
"that the module that defines your Celery app instance also sets a default"
" value for :envvar:`DJANGO_SETTINGS_MODULE` as shown in the example "
"Django project in :ref:`django-first-steps`."
msgstr ""

#: ../../userguide/daemonizing.rst:168 ../../userguide/daemonizing.rst:289
msgid "Available options"
msgstr ""

#: ../../userguide/daemonizing.rst:170 ../../userguide/daemonizing.rst:291
msgid "``CELERY_APP``"
msgstr ""

#: ../../userguide/daemonizing.rst:172 ../../userguide/daemonizing.rst:293
msgid "App instance to use (value for :option:`--app <celery --app>` argument)."
msgstr ""

#: ../../userguide/daemonizing.rst:174
msgid "``CELERY_BIN``"
msgstr ""

#: ../../userguide/daemonizing.rst:176
msgid "Absolute or relative path to the :program:`celery` program. Examples:"
msgstr ""

#: ../../userguide/daemonizing.rst:179
msgid ":file:`celery`"
msgstr ""

#: ../../userguide/daemonizing.rst:180
msgid ":file:`/usr/local/bin/celery`"
msgstr ""

#: ../../userguide/daemonizing.rst:181
msgid ":file:`/virtualenvs/proj/bin/celery`"
msgstr ""

#: ../../userguide/daemonizing.rst:182
msgid ":file:`/virtualenvs/proj/bin/python -m celery`"
msgstr ""

#: ../../userguide/daemonizing.rst:184
msgid "``CELERYD_NODES``"
msgstr ""

#: ../../userguide/daemonizing.rst:186
msgid "List of node names to start (separated by space)."
msgstr ""

#: ../../userguide/daemonizing.rst:188
msgid "``CELERYD_OPTS``"
msgstr ""

#: ../../userguide/daemonizing.rst:190
msgid ""
"Additional command-line arguments for the worker, see `celery worker "
"--help` for a list. This also supports the extended syntax used by "
"`multi` to configure settings for individual nodes. See `celery multi "
"--help` for some multi-node configuration examples."
msgstr ""

#: ../../userguide/daemonizing.rst:195
msgid "``CELERYD_CHDIR``"
msgstr ""

#: ../../userguide/daemonizing.rst:197
msgid ""
"Path to change directory to at start. Default is to stay in the current "
"directory."
msgstr ""

#: ../../userguide/daemonizing.rst:200
msgid "``CELERYD_PID_FILE``"
msgstr ""

#: ../../userguide/daemonizing.rst:202
msgid "Full path to the PID file. Default is /var/run/celery/%n.pid"
msgstr ""

#: ../../userguide/daemonizing.rst:204
msgid "``CELERYD_LOG_FILE``"
msgstr ""

#: ../../userguide/daemonizing.rst:206
msgid ""
"Full path to the worker log file. Default is /var/log/celery/%n%I.log "
"**Note**: Using `%I` is important when using the prefork pool as having "
"multiple processes share the same log file will lead to race conditions."
msgstr ""

#: ../../userguide/daemonizing.rst:210
msgid "``CELERYD_LOG_LEVEL``"
msgstr ""

#: ../../userguide/daemonizing.rst:212
msgid "Worker log level. Default is INFO."
msgstr ""

#: ../../userguide/daemonizing.rst:214
msgid "``CELERYD_USER``"
msgstr ""

#: ../../userguide/daemonizing.rst:216
msgid "User to run the worker as. Default is current user."
msgstr ""

#: ../../userguide/daemonizing.rst:218
msgid "``CELERYD_GROUP``"
msgstr ""

#: ../../userguide/daemonizing.rst:220
msgid "Group to run worker as. Default is current user."
msgstr ""

#: ../../userguide/daemonizing.rst:222 ../../userguide/daemonizing.rst:320
msgid "``CELERY_CREATE_DIRS``"
msgstr ""

#: ../../userguide/daemonizing.rst:224 ../../userguide/daemonizing.rst:322
msgid ""
"Always create directories (log directory and pid file directory). Default"
" is to only create directories when no custom logfile/pidfile set."
msgstr ""

#: ../../userguide/daemonizing.rst:227 ../../userguide/daemonizing.rst:325
msgid "``CELERY_CREATE_RUNDIR``"
msgstr ""

#: ../../userguide/daemonizing.rst:229 ../../userguide/daemonizing.rst:327
msgid ""
"Always create pidfile directory. By default only enabled when no custom "
"pidfile location set."
msgstr ""

#: ../../userguide/daemonizing.rst:232 ../../userguide/daemonizing.rst:330
msgid "``CELERY_CREATE_LOGDIR``"
msgstr ""

#: ../../userguide/daemonizing.rst:234 ../../userguide/daemonizing.rst:332
msgid ""
"Always create logfile directory. By default only enable when no custom "
"logfile location set."
msgstr ""

#: ../../userguide/daemonizing.rst:240
msgid "Init-script: ``celerybeat``"
msgstr ""

#: ../../userguide/daemonizing.rst:241
msgid "`/etc/init.d/celerybeat {start|stop|restart}`"
msgstr ""

#: ../../userguide/daemonizing.rst:242
msgid ":file:`/etc/default/celerybeat` or :file:`/etc/default/celeryd`."
msgstr ""

#: ../../userguide/daemonizing.rst:250 ../../userguide/daemonizing.rst:439
msgid "This is an example configuration for a Python project:"
msgstr ""

#: ../../userguide/daemonizing.rst:252
msgid "`/etc/default/celerybeat`:"
msgstr ""

#: ../../userguide/daemonizing.rst:277
msgid ""
"You should use the same template as above, but make sure the "
"``DJANGO_SETTINGS_MODULE`` variable is set (and exported), and that "
"``CELERYD_CHDIR`` is set to the projects directory:"
msgstr ""

#: ../../userguide/daemonizing.rst:295
msgid "``CELERYBEAT_OPTS``"
msgstr ""

#: ../../userguide/daemonizing.rst:297
msgid ""
"Additional arguments to :program:`celery beat`, see :command:`celery beat"
" --help` for a list of available options."
msgstr ""

#: ../../userguide/daemonizing.rst:300
msgid "``CELERYBEAT_PID_FILE``"
msgstr ""

#: ../../userguide/daemonizing.rst:302
msgid "Full path to the PID file. Default is :file:`/var/run/celeryd.pid`."
msgstr ""

#: ../../userguide/daemonizing.rst:304
msgid "``CELERYBEAT_LOG_FILE``"
msgstr ""

#: ../../userguide/daemonizing.rst:306
msgid "Full path to the log file. Default is :file:`/var/log/celeryd.log`."
msgstr ""

#: ../../userguide/daemonizing.rst:308
msgid "``CELERYBEAT_LOG_LEVEL``"
msgstr ""

#: ../../userguide/daemonizing.rst:310
msgid "Log level to use. Default is ``INFO``."
msgstr ""

#: ../../userguide/daemonizing.rst:312
msgid "``CELERYBEAT_USER``"
msgstr ""

#: ../../userguide/daemonizing.rst:314
msgid "User to run beat as. Default is the current user."
msgstr ""

#: ../../userguide/daemonizing.rst:316
msgid "``CELERYBEAT_GROUP``"
msgstr ""

#: ../../userguide/daemonizing.rst:318
msgid "Group to run beat as. Default is the current user."
msgstr ""

#: ../../userguide/daemonizing.rst:338
msgid "Troubleshooting"
msgstr ""

#: ../../userguide/daemonizing.rst:340
msgid ""
"If you can't get the init-scripts to work, you should try running them in"
" *verbose mode*:"
msgstr ""

#: ../../userguide/daemonizing.rst:347
msgid "This can reveal hints as to why the service won't start."
msgstr ""

#: ../../userguide/daemonizing.rst:349
msgid ""
"If the worker starts with *\"OK\"* but exits almost immediately "
"afterwards and there's no evidence in the log file, then there's probably"
" an error but as the daemons standard outputs are already closed you'll "
"not be able to see them anywhere. For this situation you can use the "
":envvar:`C_FAKEFORK` environment variable to skip the daemonization step:"
msgstr ""

#: ../../userguide/daemonizing.rst:361
msgid "and now you should be able to see the errors."
msgstr ""

#: ../../userguide/daemonizing.rst:363
msgid ""
"Commonly such errors are caused by insufficient permissions to read from,"
" or write to a file, and also by syntax errors in configuration modules, "
"user modules, third-party libraries, or even from Celery itself (if "
"you've found a bug you should :ref:`report it <reporting-bugs>`)."
msgstr ""

#: ../../userguide/daemonizing.rst:373
msgid "Usage ``systemd``"
msgstr ""

#: ../../userguide/daemonizing.rst:375
msgid "`extra/systemd/`_"
msgstr ""

#: ../../userguide/daemonizing.rst:382
msgid "`systemctl {start|stop|restart|status} celery.service`"
msgstr ""

#: ../../userguide/daemonizing.rst:383
msgid "/etc/conf.d/celery"
msgstr ""

#: ../../userguide/daemonizing.rst:386
msgid "Service file: celery.service"
msgstr ""

#: ../../userguide/daemonizing.rst:388
msgid "This is an example systemd file:"
msgstr ""

#: ../../userguide/daemonizing.rst:390
msgid ":file:`/etc/systemd/system/celery.service`:"
msgstr ""

#: ../../userguide/daemonizing.rst:416
msgid ""
"Once you've put that file in :file:`/etc/systemd/system`, you should run "
":command:`systemctl daemon-reload` in order that Systemd acknowledges "
"that file. You should also run that command each time you modify it."
msgstr ""

#: ../../userguide/daemonizing.rst:420
msgid ""
"To configure user, group, :command:`chdir` change settings: ``User``, "
"``Group``, and ``WorkingDirectory`` defined in "
":file:`/etc/systemd/system/celery.service`."
msgstr ""

#: ../../userguide/daemonizing.rst:424
msgid ""
"You can also use systemd-tmpfiles in order to create working directories "
"(for logs and pid)."
msgstr ""

#: ../../userguide/daemonizing.rst
msgid "file"
msgstr ""

#: ../../userguide/daemonizing.rst:426
msgid "`/etc/tmpfiles.d/celery.conf`"
msgstr ""

#: ../../userguide/daemonizing.rst:441
msgid ":file:`/etc/conf.d/celery`:"
msgstr ""

#: ../../userguide/daemonizing.rst:479
msgid "Service file: celerybeat.service"
msgstr ""

#: ../../userguide/daemonizing.rst:481
msgid "This is an example systemd file for Celery Beat:"
msgstr ""

#: ../../userguide/daemonizing.rst:483
msgid ":file:`/etc/systemd/system/celerybeat.service`:"
msgstr ""

#: ../../userguide/daemonizing.rst:506
msgid "Running the worker with superuser privileges (root)"
msgstr ""

#: ../../userguide/daemonizing.rst:508
msgid ""
"Running the worker with superuser privileges is a very dangerous "
"practice. There should always be a workaround to avoid running as root. "
"Celery may run arbitrary code in messages serialized with pickle - this "
"is dangerous, especially when run as root."
msgstr ""

#: ../../userguide/daemonizing.rst:513
msgid ""
"By default Celery won't run workers as root. The associated error message"
" may not be visible in the logs but may be seen if :envvar:`C_FAKEFORK` "
"is used."
msgstr ""

#: ../../userguide/daemonizing.rst:517
msgid "To force Celery to run workers as root use :envvar:`C_FORCE_ROOT`."
msgstr ""

#: ../../userguide/daemonizing.rst:519
msgid ""
"When running as root without :envvar:`C_FORCE_ROOT` the worker will "
"appear to start with *\"OK\"* but exit immediately after with no apparent"
" errors. This problem may appear when running the project in a new "
"development or production environment (inadvertently) as root."
msgstr ""

#: ../../userguide/daemonizing.rst:527
msgid ":pypi:`supervisor`"
msgstr ""

#: ../../userguide/daemonizing.rst:529
msgid "`extra/supervisord/`_"
msgstr ""

#: ../../userguide/daemonizing.rst:537
msgid "``launchd`` (macOS)"
msgstr ""

#: ../../userguide/daemonizing.rst:539
msgid "`extra/macOS`_"
msgstr ""

#: ../../userguide/debugging.rst:5
msgid "Debugging"
msgstr ""

#: ../../userguide/debugging.rst:10
msgid "Debugging Tasks Remotely (using pdb)"
msgstr ""

#: ../../userguide/debugging.rst:15
msgid ""
":mod:`celery.contrib.rdb` is an extended version of :mod:`pdb` that "
"enables remote debugging of processes that doesn't have terminal access."
msgstr ""

#: ../../userguide/debugging.rst:19
msgid "Example usage:"
msgstr ""

#: ../../userguide/debugging.rst:33
msgid ""
":func:`~celery.contrib.rdb.set_trace` sets a break-point at the current "
"location and creates a socket you can telnet into to remotely debug your "
"task."
msgstr ""

#: ../../userguide/debugging.rst:37
msgid ""
"The debugger may be started by multiple processes at the same time, so "
"rather than using a fixed port the debugger will search for an available "
"port, starting from the base port (6900 by default). The base port can be"
" changed using the environment variable :envvar:`CELERY_RDB_PORT`."
msgstr ""

#: ../../userguide/debugging.rst:43
msgid ""
"By default the debugger will only be available from the local host, to "
"enable access from the outside you have to set the environment variable "
":envvar:`CELERY_RDB_HOST`."
msgstr ""

#: ../../userguide/debugging.rst:47
msgid ""
"When the worker encounters your break-point it'll log the following "
"information:"
msgstr ""

#: ../../userguide/debugging.rst:59
msgid "If you telnet the port specified you'll be presented with a `pdb` shell:"
msgstr ""

#: ../../userguide/debugging.rst:71
msgid ""
"Enter ``help`` to get a list of available commands, It may be a good idea"
" to read the `Python Debugger Manual`_ if you have never used `pdb` "
"before."
msgstr ""

#: ../../userguide/debugging.rst:75
msgid ""
"To demonstrate, we'll read the value of the ``result`` variable, change "
"it and continue execution of the task:"
msgstr ""

#: ../../userguide/debugging.rst:86
msgid "The result of our vandalism can be seen in the worker logs:"
msgstr ""

#: ../../userguide/debugging.rst:98
msgid "Tips"
msgstr ""

#: ../../userguide/debugging.rst:103
msgid "Enabling the break-point signal"
msgstr ""

#: ../../userguide/debugging.rst:105
msgid ""
"If the environment variable :envvar:`CELERY_RDBSIG` is set, the worker "
"will open up an rdb instance whenever the `SIGUSR2` signal is sent. This "
"is the case for both main and worker processes."
msgstr ""

#: ../../userguide/debugging.rst:109
msgid "For example starting the worker with:"
msgstr ""

#: ../../userguide/debugging.rst:115
msgid "You can start an rdb session for any of the worker processes by executing:"
msgstr ""

#: ../../userguide/extending.rst:5
msgid "Extensions and Bootsteps"
msgstr ""

#: ../../userguide/extending.rst:14
msgid "Custom Message Consumers"
msgstr ""

#: ../../userguide/extending.rst:16
msgid ""
"You may want to embed custom Kombu consumers to manually process your "
"messages."
msgstr ""

#: ../../userguide/extending.rst:18
msgid ""
"For that purpose a special :class:`~celery.bootstep.ConsumerStep` "
"bootstep class exists, where you only need to define the "
"``get_consumers`` method, that must return a list of "
":class:`kombu.Consumer` objects to start whenever the connection is "
"established:"
msgstr ""

#: ../../userguide/extending.rst:64
msgid ""
"Kombu Consumers can take use of two different message callback "
"dispatching mechanisms. The first one is the ``callbacks`` argument that "
"accepts a list of callbacks with a ``(body, message)`` signature, the "
"second one is the ``on_message`` argument that takes a single callback "
"with a ``(message,)`` signature. The latter won't automatically decode "
"and deserialize the payload."
msgstr ""

#: ../../userguide/extending.rst:89
msgid "Blueprints"
msgstr ""

#: ../../userguide/extending.rst:91
msgid ""
"Bootsteps is a technique to add functionality to the workers. A bootstep "
"is a custom class that defines hooks to do custom actions at different "
"stages in the worker. Every bootstep belongs to a blueprint, and the "
"worker currently defines two blueprints: **Worker**, and **Consumer**"
msgstr ""

#: ../../userguide/extending.rst:102
msgid "**Figure A:** Bootsteps in the Worker and Consumer blueprints. Starting"
msgstr ""

#: ../../userguide/extending.rst:99
msgid ""
"from the bottom up the first step in the worker blueprint is the Timer, "
"and the last step is to start the Consumer blueprint, that then "
"establishes the broker connection and starts consuming messages."
msgstr ""

#: ../../userguide/extending.rst:113
msgid ""
"The Worker is the first blueprint to start, and with it starts major "
"components like the event loop, processing pool, and the timer used for "
"ETA tasks and other timed events."
msgstr ""

#: ../../userguide/extending.rst:117
msgid ""
"When the worker is fully started it continues with the Consumer "
"blueprint, that sets up how tasks are executed, connects to the broker "
"and starts the message consumers."
msgstr ""

#: ../../userguide/extending.rst:121
msgid ""
"The :class:`~celery.worker.WorkController` is the core worker "
"implementation, and contains several methods and attributes that you can "
"use in your bootstep."
msgstr ""

#: ../../userguide/extending.rst:127 ../../userguide/extending.rst:322
msgid "Attributes"
msgstr ""

#: ../../userguide/extending.rst:133 ../../userguide/extending.rst:328
msgid "The current app instance."
msgstr ""

#: ../../userguide/extending.rst:139 ../../userguide/extending.rst:340
msgid "The workers node name (e.g., `worker1@example.com`)"
msgstr ""

#: ../../userguide/extending.rst:145 ../../userguide/extending.rst:346
msgid "This is the worker :class:`~celery.bootsteps.Blueprint`."
msgstr ""

#: ../../userguide/extending.rst:151 ../../userguide/extending.rst:352
msgid ""
"Event loop object (:class:`~kombu.asynchronous.Hub`). You can use this to"
" register callbacks in the event loop."
msgstr ""

#: ../../userguide/extending.rst:154 ../../userguide/extending.rst:355
msgid ""
"This is only supported by async I/O enabled transports (amqp, redis), in "
"which case the `worker.use_eventloop` attribute should be set."
msgstr ""

#: ../../userguide/extending.rst:157 ../../userguide/extending.rst:358
msgid "Your worker bootstep must require the Hub bootstep to use this:"
msgstr ""

#: ../../userguide/extending.rst:168 ../../userguide/extending.rst:457
msgid ""
"The current process/eventlet/gevent/thread pool. See "
":class:`celery.concurrency.base.BasePool`."
msgstr ""

#: ../../userguide/extending.rst:171
msgid "Your worker bootstep must require the Pool bootstep to use this:"
msgstr ""

#: ../../userguide/extending.rst:182
msgid ":class:`~kombu.asynchronous.timer.Timer` used to schedule functions."
msgstr ""

#: ../../userguide/extending.rst:184
msgid "Your worker bootstep must require the Timer bootstep to use this:"
msgstr ""

#: ../../userguide/extending.rst:195
msgid ""
":class:`Database <celery.worker.state.Persistent>`` to persist state "
"between worker restarts."
msgstr ""

#: ../../userguide/extending.rst:198
msgid "This is only defined if the ``statedb`` argument is enabled."
msgstr ""

#: ../../userguide/extending.rst:200
msgid "Your worker bootstep must require the ``Statedb`` bootstep to use this:"
msgstr ""

#: ../../userguide/extending.rst:211
msgid ""
":class:`~celery.worker.autoscaler.Autoscaler` used to automatically grow "
"and shrink the number of processes in the pool."
msgstr ""

#: ../../userguide/extending.rst:214
msgid "This is only defined if the ``autoscale`` argument is enabled."
msgstr ""

#: ../../userguide/extending.rst:216
msgid "Your worker bootstep must require the `Autoscaler` bootstep to use this:"
msgstr ""

#: ../../userguide/extending.rst:227
msgid ""
":class:`~celery.worker.autoreloder.Autoreloader` used to automatically "
"reload use code when the file-system changes."
msgstr ""

#: ../../userguide/extending.rst:230
msgid ""
"This is only defined if the ``autoreload`` argument is enabled. Your "
"worker bootstep must require the `Autoreloader` bootstep to use this;"
msgstr ""

#: ../../userguide/extending.rst:239
msgid "Example worker bootstep"
msgstr ""

#: ../../userguide/extending.rst:241
msgid "An example Worker bootstep could be:"
msgstr ""

#: ../../userguide/extending.rst:269
msgid ""
"Every method is passed the current ``WorkController`` instance as the "
"first argument."
msgstr ""

#: ../../userguide/extending.rst:272
msgid "Another example could use the timer to wake up at regular intervals:"
msgstr ""

#: ../../userguide/extending.rst:307
msgid "Consumer"
msgstr ""

#: ../../userguide/extending.rst:309
msgid ""
"The Consumer blueprint establishes a connection to the broker, and is "
"restarted every time this connection is lost. Consumer bootsteps include "
"the worker heartbeat, the remote control command consumer, and "
"importantly, the task consumer."
msgstr ""

#: ../../userguide/extending.rst:314
msgid ""
"When you create consumer bootsteps you must take into account that it "
"must be possible to restart your blueprint. An additional 'shutdown' "
"method is defined for consumer bootsteps, this method is called when the "
"worker is shutdown."
msgstr ""

#: ../../userguide/extending.rst:334
msgid "The parent :class:`~@WorkController` object that created this consumer."
msgstr ""

#: ../../userguide/extending.rst:369
msgid "The current broker connection (:class:`kombu.Connection`)."
msgstr ""

#: ../../userguide/extending.rst:371
msgid "A consumer bootstep must require the 'Connection' bootstep to use this:"
msgstr ""

#: ../../userguide/extending.rst:383
msgid "A :class:`@events.Dispatcher` object that can be used to send events."
msgstr ""

#: ../../userguide/extending.rst:385
msgid "A consumer bootstep must require the `Events` bootstep to use this."
msgstr ""

#: ../../userguide/extending.rst:396
msgid ""
"Worker to worker broadcast communication "
"(:class:`~celery.worker.consumer.gossip.Gossip`)."
msgstr ""

#: ../../userguide/extending.rst:399
msgid "A consumer bootstep must require the `Gossip` bootstep to use this."
msgstr ""

#: ../../userguide/extending.rst:432
msgid "**Callbacks**"
msgstr ""

#: ../../userguide/extending.rst:434
msgid "``<set> gossip.on.node_join``"
msgstr ""

#: ../../userguide/extending.rst:436
msgid ""
"Called whenever a new node joins the cluster, providing a "
":class:`~celery.events.state.Worker` instance."
msgstr ""

#: ../../userguide/extending.rst:439
msgid "``<set> gossip.on.node_leave``"
msgstr ""

#: ../../userguide/extending.rst:441
msgid ""
"Called whenever a new node leaves the cluster (shuts down), providing a "
":class:`~celery.events.state.Worker` instance."
msgstr ""

#: ../../userguide/extending.rst:444
msgid "``<set> gossip.on.node_lost``"
msgstr ""

#: ../../userguide/extending.rst:446
msgid ""
"Called whenever heartbeat was missed for a worker instance in the cluster"
" (heartbeat not received or processed in time), providing a "
":class:`~celery.events.state.Worker` instance."
msgstr ""

#: ../../userguide/extending.rst:450
msgid ""
"This doesn't necessarily mean the worker is actually offline, so use a "
"time out mechanism if the default heartbeat timeout isn't sufficient."
msgstr ""

#: ../../userguide/extending.rst:464
msgid ":class:`Timer <celery.utils.timer2.Schedule` used to schedule functions."
msgstr ""

#: ../../userguide/extending.rst:470
msgid ""
"Responsible for sending worker event heartbeats "
"(:class:`~celery.worker.heartbeat.Heart`)."
msgstr ""

#: ../../userguide/extending.rst:473
msgid "Your consumer bootstep must require the `Heart` bootstep to use this:"
msgstr ""

#: ../../userguide/extending.rst:484
msgid "The :class:`kombu.Consumer` object used to consume task messages."
msgstr ""

#: ../../userguide/extending.rst:486 ../../userguide/extending.rst:510
msgid "Your consumer bootstep must require the `Tasks` bootstep to use this:"
msgstr ""

#: ../../userguide/extending.rst:497
msgid ""
"Every registered task type has an entry in this mapping, where the value "
"is used to execute an incoming message of this task type (the task "
"execution strategy). This mapping is generated by the Tasks bootstep when"
" the consumer starts:"
msgstr ""

#: ../../userguide/extending.rst:521
msgid ""
"A :class:`~collections.defaultdict` used to look-up the rate limit for a "
"task by type. Entries in this dict may be None (for no limit) or a "
":class:`~kombu.utils.limits.TokenBucket` instance implementing "
"``consume(tokens)`` and ``expected_time(tokens)``."
msgstr ""

#: ../../userguide/extending.rst:527
msgid ""
"TokenBucket implements the `token bucket algorithm`_, but any algorithm "
"may be used as long as it conforms to the same interface and defines the "
"two methods above."
msgstr ""

#: ../../userguide/extending.rst:537
msgid ""
"The :class:`~kombu.common.QoS` object can be used to change the task "
"channels current prefetch_count value:"
msgstr ""

#: ../../userguide/extending.rst:550
msgid "Methods"
msgstr ""

#: ../../userguide/extending.rst:554
msgid "Updates the ``task_buckets`` mapping for all registered task types."
msgstr ""

#: ../../userguide/extending.rst:558
msgid ""
"Creates rate limit bucket for a task using its ``task.rate_limit`` "
"attribute."
msgstr ""

#: ../../userguide/extending.rst:564
msgid "Adds new queue to consume from. This will persist on connection restart."
msgstr ""

#: ../../userguide/extending.rst:568
msgid ""
"Stop consuming from queue by name. This will persist on connection "
"restart."
msgstr ""

#: ../../userguide/extending.rst:573
msgid ""
"Schedule ETA task to execute based on the ``request.eta`` attribute. "
"(:class:`~celery.worker.request.Request`)"
msgstr ""

#: ../../userguide/extending.rst:581
msgid "Installing Bootsteps"
msgstr ""

#: ../../userguide/extending.rst:583
msgid ""
"``app.steps['worker']`` and ``app.steps['consumer']`` can be modified to "
"add new bootsteps:"
msgstr ""

#: ../../userguide/extending.rst:597
msgid ""
"The order of steps isn't important here as the order is decided by the "
"resulting dependency graph (``Step.requires``)."
msgstr ""

#: ../../userguide/extending.rst:600
msgid ""
"To illustrate how you can install bootsteps and how they work, this is an"
" example step that prints some useless debugging information. It can be "
"added both as a worker and consumer bootstep:"
msgstr ""

#: ../../userguide/extending.rst:637
msgid ""
"Starting the worker with this step installed will give us the following "
"logs:"
msgstr ""

#: ../../userguide/extending.rst:652
msgid ""
"The ``print`` statements will be redirected to the logging subsystem "
"after the worker has been initialized, so the \"is starting\" lines are "
"time-stamped. You may notice that this does no longer happen at shutdown,"
" this is because the ``stop`` and ``shutdown`` methods are called inside "
"a *signal handler*, and it's not safe to use logging inside such a "
"handler. Logging with the Python logging module isn't :term:`reentrant`: "
"meaning you cannot interrupt the function then call it again later. It's "
"important that the ``stop`` and ``shutdown`` methods you write is also "
":term:`reentrant`."
msgstr ""

#: ../../userguide/extending.rst:662
msgid ""
"Starting the worker with :option:`--loglevel=debug <celery worker "
"--loglevel>` will show us more information about the boot process:"
msgstr ""

#: ../../userguide/extending.rst:716
msgid "Command-line programs"
msgstr ""

#: ../../userguide/extending.rst:721
msgid "Adding new command-line options"
msgstr ""

#: ../../userguide/extending.rst:726
msgid "Command-specific options"
msgstr ""

#: ../../userguide/extending.rst:728
msgid ""
"You can add additional command-line options to the ``worker``, ``beat``, "
"and ``events`` commands by modifying the :attr:`~@user_options` attribute"
" of the application instance."
msgstr ""

#: ../../userguide/extending.rst:732
msgid ""
"Celery commands uses the :mod:`argparse` module to parse command-line "
"arguments, and so to add custom arguments you need to specify a callback "
"that takes a :class:`argparse.ArgumentParser` instance - and adds "
"arguments. Please see the :mod:`argparse` documentation to read about the"
" fields supported."
msgstr ""

#: ../../userguide/extending.rst:737
msgid "Example adding a custom option to the :program:`celery worker` command:"
msgstr ""

#: ../../userguide/extending.rst:753
msgid ""
"All bootsteps will now receive this argument as a keyword argument to "
"``Bootstep.__init__``:"
msgstr ""

#: ../../userguide/extending.rst:771
msgid "Preload options"
msgstr ""

#: ../../userguide/extending.rst:773
msgid ""
"The :program:`celery` umbrella command supports the concept of 'preload "
"options'.  These are special options passed to all sub-commands and "
"parsed outside of the main parsing step."
msgstr ""

#: ../../userguide/extending.rst:777
msgid ""
"The list of default preload options can be found in the API reference: "
":mod:`celery.bin.base`."
msgstr ""

#: ../../userguide/extending.rst:780
msgid ""
"You can add new preload options too, for example to specify a "
"configuration template:"
msgstr ""

#: ../../userguide/extending.rst:805
msgid "Adding new :program:`celery` sub-commands"
msgstr ""

#: ../../userguide/extending.rst:807
msgid ""
"New commands can be added to the :program:`celery` umbrella command by "
"using `setuptools entry-points`_."
msgstr ""

#: ../../userguide/extending.rst:814
msgid ""
"Entry-points is special meta-data that can be added to your packages "
"``setup.py`` program, and then after installation, read from the system "
"using the :mod:`pkg_resources` module."
msgstr ""

#: ../../userguide/extending.rst:817
msgid ""
"Celery recognizes ``celery.commands`` entry-points to install additional "
"sub-commands, where the value of the entry-point must point to a valid "
"subclass of :class:`celery.bin.base.Command`. There's limited "
"documentation, unfortunately, but you can find inspiration from the "
"various commands in the :mod:`celery.bin` package."
msgstr ""

#: ../../userguide/extending.rst:823
msgid ""
"This is how the :pypi:`Flower` monitoring extension adds the "
":program:`celery flower` command, by adding an entry-point in "
":file:`setup.py`:"
msgstr ""

#: ../../userguide/extending.rst:837
msgid ""
"The command definition is in two parts separated by the equal sign, where"
" the first part is the name of the sub-command (flower), then the second "
"part is the fully qualified symbol path to the class that implements the "
"command:"
msgstr ""

#: ../../userguide/extending.rst:845
msgid ""
"The module path and the name of the attribute should be separated by "
"colon as above."
msgstr ""

#: ../../userguide/extending.rst:849
msgid ""
"In the module :file:`flower/command.py`, the command class is defined "
"something like this:"
msgstr ""

#: ../../userguide/extending.rst:873
msgid "Worker API"
msgstr ""

#: ../../userguide/extending.rst:877
msgid ":class:`~kombu.asynchronous.Hub` - The workers async event loop"
msgstr ""

#: ../../userguide/extending.rst ../../userguide/routing.rst
msgid "supported transports"
msgstr ""

#: ../../userguide/extending.rst:878
msgid "amqp, redis"
msgstr ""

#: ../../userguide/extending.rst:882
msgid ""
"The worker uses asynchronous I/O when the amqp or redis broker transports"
" are used. The eventual goal is for all transports to use the event-loop,"
" but that will take some time so other transports still use a threading-"
"based solution."
msgstr ""

#: ../../userguide/extending.rst:891
msgid "Add callback to be called when ``fd`` is readable."
msgstr ""

#: ../../userguide/extending.rst:893
msgid ""
"The callback will stay registered until explicitly removed using "
":meth:`hub.remove(fd) <hub.remove>`, or the file descriptor is "
"automatically discarded because it's no longer valid."
msgstr ""

#: ../../userguide/extending.rst:897
msgid ""
"Note that only one callback can be registered for any given file "
"descriptor at a time, so calling ``add`` a second time will remove any "
"callback that was previously registered for that file descriptor."
msgstr ""

#: ../../userguide/extending.rst:901
msgid ""
"A file descriptor is any file-like object that supports the ``fileno`` "
"method, or it can be the file descriptor number (int)."
msgstr ""

#: ../../userguide/extending.rst:906
msgid ""
"Add callback to be called when ``fd`` is writable. See also notes for "
":meth:`hub.add_reader` above."
msgstr ""

#: ../../userguide/extending.rst:911
msgid "Remove all callbacks for file descriptor ``fd`` from the loop."
msgstr ""

#: ../../userguide/extending.rst:914
msgid "Timer - Scheduling events"
msgstr ""

#: ../../userguide/index.rst:5
msgid "User Guide"
msgstr ""

#: ../../userguide/monitoring.rst:5
msgid "Monitoring and Management Guide"
msgstr ""

#: ../../userguide/monitoring.rst:13
msgid "There are several tools available to monitor and inspect Celery clusters."
msgstr ""

#: ../../userguide/monitoring.rst:15
msgid ""
"This document describes some of these, as as well as features related to "
"monitoring, like events and broadcast commands."
msgstr ""

#: ../../userguide/monitoring.rst:21
msgid "Workers"
msgstr ""

#: ../../userguide/monitoring.rst:26
msgid "Management Command-line Utilities (``inspect``/``control``)"
msgstr ""

#: ../../userguide/monitoring.rst:29
msgid ""
":program:`celery` can also be used to inspect and manage worker nodes "
"(and to some degree tasks)."
msgstr ""

#: ../../userguide/monitoring.rst:32
msgid "To list all the commands available do:"
msgstr ""

#: ../../userguide/monitoring.rst:38
msgid "or to get help for a specific command do:"
msgstr ""

#: ../../userguide/monitoring.rst:45 ../../userguide/workers.rst:321
msgid "Commands"
msgstr ""

#: ../../userguide/monitoring.rst:47
msgid "**shell**: Drop into a Python shell."
msgstr ""

#: ../../userguide/monitoring.rst:49
msgid ""
"The locals will include the ``celery`` variable: this is the current app."
" Also all known tasks will be automatically added to locals (unless the "
":option:`--without-tasks <celery shell --without-tasks>` flag is set)."
msgstr ""

#: ../../userguide/monitoring.rst:53
msgid ""
"Uses :pypi:`Ipython`, :pypi:`bpython`, or regular :program:`python` in "
"that order if installed. You can force an implementation using "
":option:`--ipython <celery shell --ipython>`, :option:`--bpython <celery "
"shell --bpython>`, or :option:`--python <celery shell --python>`."
msgstr ""

#: ../../userguide/monitoring.rst:59
msgid "**status**: List active nodes in this cluster"
msgstr ""

#: ../../userguide/monitoring.rst:65
msgid "**result**: Show the result of a task"
msgstr ""

#: ../../userguide/monitoring.rst:71
msgid ""
"Note that you can omit the name of the task as long as the task doesn't "
"use a custom result backend."
msgstr ""

#: ../../userguide/monitoring.rst:74
msgid "**purge**: Purge messages from all configured task queues."
msgstr ""

#: ../../userguide/monitoring.rst:76
msgid ""
"This command will remove all messages from queues configured in the "
":setting:`CELERY_QUEUES` setting:"
msgstr ""

#: ../../userguide/monitoring.rst:81
msgid ""
"There's no undo for this operation, and messages will be permanently "
"deleted!"
msgstr ""

#: ../../userguide/monitoring.rst:89
msgid "You can also specify the queues to purge using the `-Q` option:"
msgstr ""

#: ../../userguide/monitoring.rst:95
msgid "and exclude queues from being purged using the `-X` option:"
msgstr ""

#: ../../userguide/monitoring.rst:101
msgid "**inspect active**: List active tasks"
msgstr ""

#: ../../userguide/monitoring.rst:107
msgid "These are all the tasks that are currently being executed."
msgstr ""

#: ../../userguide/monitoring.rst:109
msgid "**inspect scheduled**: List scheduled ETA tasks"
msgstr ""

#: ../../userguide/monitoring.rst:115
msgid ""
"These are tasks reserved by the worker when they have an `eta` or "
"`countdown` argument set."
msgstr ""

#: ../../userguide/monitoring.rst:118
msgid "**inspect reserved**: List reserved tasks"
msgstr ""

#: ../../userguide/monitoring.rst:124
msgid ""
"This will list all tasks that have been prefetched by the worker, and is "
"currently waiting to be executed (doesn't include tasks with an ETA value"
" set)."
msgstr ""

#: ../../userguide/monitoring.rst:128
msgid "**inspect revoked**: List history of revoked tasks"
msgstr ""

#: ../../userguide/monitoring.rst:134
msgid "**inspect registered**: List registered tasks"
msgstr ""

#: ../../userguide/monitoring.rst:140
msgid "**inspect stats**: Show worker statistics (see :ref:`worker-statistics`)"
msgstr ""

#: ../../userguide/monitoring.rst:146
msgid "**inspect query_task**: Show information about task(s) by id."
msgstr ""

#: ../../userguide/monitoring.rst:148
msgid ""
"Any worker having a task in this set of ids reserved/active will respond "
"with status and information."
msgstr ""

#: ../../userguide/monitoring.rst:155
msgid "You can also query for information about multiple tasks:"
msgstr ""

#: ../../userguide/monitoring.rst:161
msgid "**control enable_events**: Enable events"
msgstr ""

#: ../../userguide/monitoring.rst:167
msgid "**control disable_events**: Disable events"
msgstr ""

#: ../../userguide/monitoring.rst:173
msgid "**migrate**: Migrate tasks from one broker to another (**EXPERIMENTAL**)."
msgstr ""

#: ../../userguide/monitoring.rst:179
msgid ""
"This command will migrate all the tasks on one broker to another. As this"
" command is new and experimental you should be sure to have a backup of "
"the data before proceeding."
msgstr ""

#: ../../userguide/monitoring.rst:185
msgid ""
"All ``inspect`` and ``control`` commands supports a :option:`--timeout "
"<celery inspect --timeout>` argument, This is the number of seconds to "
"wait for responses. You may have to increase this timeout if you're not "
"getting a response due to latency."
msgstr ""

#: ../../userguide/monitoring.rst:194
msgid "Specifying destination nodes"
msgstr ""

#: ../../userguide/monitoring.rst:196
msgid ""
"By default the inspect and control commands operates on all workers. You "
"can specify a single, or a list of workers by using the "
":option:`--destination <celery inspect --destination>` argument:"
msgstr ""

#: ../../userguide/monitoring.rst:210
msgid "Flower: Real-time Celery web-monitor"
msgstr ""

#: ../../userguide/monitoring.rst:212
msgid ""
"Flower is a real-time web based monitor and administration tool for "
"Celery. It's under active development, but is already an essential tool. "
"Being the recommended monitor for Celery, it obsoletes the Django-Admin "
"monitor, ``celerymon`` and the ``ncurses`` based monitor."
msgstr ""

#: ../../userguide/monitoring.rst:217
msgid ""
"Flower is pronounced like \"flow\", but you can also use the botanical "
"version if you prefer."
msgstr ""

#: ../../userguide/monitoring.rst:221
msgid "Features"
msgstr ""

#: ../../userguide/monitoring.rst:223
msgid "Real-time monitoring using Celery Events"
msgstr ""

#: ../../userguide/monitoring.rst:225
msgid "Task progress and history"
msgstr ""

#: ../../userguide/monitoring.rst:226
msgid "Ability to show task details (arguments, start time, run-time, and more)"
msgstr ""

#: ../../userguide/monitoring.rst:227
msgid "Graphs and statistics"
msgstr ""

#: ../../userguide/monitoring.rst:229
msgid "Remote Control"
msgstr ""

#: ../../userguide/monitoring.rst:231
msgid "View worker status and statistics"
msgstr ""

#: ../../userguide/monitoring.rst:232
msgid "Shutdown and restart worker instances"
msgstr ""

#: ../../userguide/monitoring.rst:233
msgid "Control worker pool size and autoscale settings"
msgstr ""

#: ../../userguide/monitoring.rst:234
msgid "View and modify the queues a worker instance consumes from"
msgstr ""

#: ../../userguide/monitoring.rst:235
msgid "View currently running tasks"
msgstr ""

#: ../../userguide/monitoring.rst:236
msgid "View scheduled tasks (ETA/countdown)"
msgstr ""

#: ../../userguide/monitoring.rst:237
msgid "View reserved and revoked tasks"
msgstr ""

#: ../../userguide/monitoring.rst:238
msgid "Apply time and rate limits"
msgstr ""

#: ../../userguide/monitoring.rst:239
msgid "Configuration viewer"
msgstr ""

#: ../../userguide/monitoring.rst:240
msgid "Revoke or terminate tasks"
msgstr ""

#: ../../userguide/monitoring.rst:242
msgid "HTTP API"
msgstr ""

#: ../../userguide/monitoring.rst:244
msgid "List workers"
msgstr ""

#: ../../userguide/monitoring.rst:245
msgid "Shut down a worker"
msgstr ""

#: ../../userguide/monitoring.rst:246
msgid "Restart worker’s pool"
msgstr ""

#: ../../userguide/monitoring.rst:247
msgid "Grow worker’s pool"
msgstr ""

#: ../../userguide/monitoring.rst:248
msgid "Shrink worker’s pool"
msgstr ""

#: ../../userguide/monitoring.rst:249
msgid "Autoscale worker pool"
msgstr ""

#: ../../userguide/monitoring.rst:250
msgid "Start consuming from a queue"
msgstr ""

#: ../../userguide/monitoring.rst:251
msgid "Stop consuming from a queue"
msgstr ""

#: ../../userguide/monitoring.rst:252
msgid "List tasks"
msgstr ""

#: ../../userguide/monitoring.rst:253
msgid "List (seen) task types"
msgstr ""

#: ../../userguide/monitoring.rst:254
msgid "Get a task info"
msgstr ""

#: ../../userguide/monitoring.rst:255
msgid "Execute a task"
msgstr ""

#: ../../userguide/monitoring.rst:256
msgid "Execute a task by name"
msgstr ""

#: ../../userguide/monitoring.rst:257
msgid "Get a task result"
msgstr ""

#: ../../userguide/monitoring.rst:258
msgid "Change soft and hard time limits for a task"
msgstr ""

#: ../../userguide/monitoring.rst:259
msgid "Change rate limit for a task"
msgstr ""

#: ../../userguide/monitoring.rst:260
msgid "Revoke a task"
msgstr ""

#: ../../userguide/monitoring.rst:262
msgid "OpenID authentication"
msgstr ""

#: ../../userguide/monitoring.rst:264
msgid "**Screenshots**"
msgstr ""

#: ../../userguide/monitoring.rst:272
msgid "More screenshots_:"
msgstr ""

#: ../../userguide/monitoring.rst:279
msgid "You can use pip to install Flower:"
msgstr ""

#: ../../userguide/monitoring.rst:285
msgid "Running the flower command will start a web-server that you can visit:"
msgstr ""

#: ../../userguide/monitoring.rst:291
msgid ""
"The default port is http://localhost:5555, but you can change this using "
"the `--port`_ argument:"
msgstr ""

#: ../../userguide/monitoring.rst:300
msgid ""
"Broker URL can also be passed through the :option:`--broker <celery "
"--broker>` argument :"
msgstr ""

#: ../../userguide/monitoring.rst:309
msgid "Then, you can visit flower in your web browser :"
msgstr ""

#: ../../userguide/monitoring.rst:315
msgid ""
"Flower has many more features than are detailed here, including "
"authorization options. Check out the `official documentation`_ for more "
"information."
msgstr ""

#: ../../userguide/monitoring.rst:325
msgid "celery events: Curses Monitor"
msgstr ""

#: ../../userguide/monitoring.rst:329
msgid ""
"`celery events` is a simple curses monitor displaying task and worker "
"history. You can inspect the result and traceback of tasks, and it also "
"supports some management commands like rate limiting and shutting down "
"workers. This monitor was started as a proof of concept, and you probably"
" want to use Flower instead."
msgstr ""

#: ../../userguide/monitoring.rst:335
msgid "Starting:"
msgstr ""

#: ../../userguide/monitoring.rst:341
msgid "You should see a screen like:"
msgstr ""

#: ../../userguide/monitoring.rst:346
msgid ""
"`celery events` is also used to start snapshot cameras (see :ref"
":`monitoring-snapshots`:"
msgstr ""

#: ../../userguide/monitoring.rst:353
msgid "and it includes a tool to dump events to :file:`stdout`:"
msgstr ""

#: ../../userguide/monitoring.rst:359
msgid "For a complete list of options use :option:`--help <celery --help>`:"
msgstr ""

#: ../../userguide/monitoring.rst:372
msgid ""
"To manage a Celery cluster it is important to know how RabbitMQ can be "
"monitored."
msgstr ""

#: ../../userguide/monitoring.rst:375
msgid ""
"RabbitMQ ships with the `rabbitmqctl(1)`_ command, with this you can list"
" queues, exchanges, bindings, queue lengths, the memory usage of each "
"queue, as well as manage users, virtual hosts and their permissions."
msgstr ""

#: ../../userguide/monitoring.rst:382
msgid ""
"The default virtual host (``\"/\"``) is used in these examples, if you "
"use a custom virtual host you have to add the ``-p`` argument to the "
"command, for example: ``rabbitmqctl list_queues -p my_vhost …``"
msgstr ""

#: ../../userguide/monitoring.rst:392 ../../userguide/monitoring.rst:436
msgid "Inspecting queues"
msgstr ""

#: ../../userguide/monitoring.rst:394 ../../userguide/monitoring.rst:438
msgid "Finding the number of tasks in a queue:"
msgstr ""

#: ../../userguide/monitoring.rst:402
msgid ""
"Here `messages_ready` is the number of messages ready for delivery (sent "
"but not received), `messages_unacknowledged` is the number of messages "
"that's been received by a worker but not acknowledged yet (meaning it is "
"in progress, or has been reserved). `messages` is the sum of ready and "
"unacknowledged messages."
msgstr ""

#: ../../userguide/monitoring.rst:409
msgid "Finding the number of workers currently consuming from a queue:"
msgstr ""

#: ../../userguide/monitoring.rst:415
msgid "Finding the amount of memory allocated to a queue:"
msgstr ""

#: ../../userguide/monitoring.rst:421
msgid ""
"Adding the ``-q`` option to `rabbitmqctl(1)`_ makes the output easier to "
"parse."
msgstr ""

#: ../../userguide/monitoring.rst:428 ../../userguide/routing.rst:259
msgid "Redis"
msgstr ""

#: ../../userguide/monitoring.rst:430
msgid ""
"If you're using Redis as the broker, you can monitor the Celery cluster "
"using the `redis-cli(1)` command to list lengths of queues."
msgstr ""

#: ../../userguide/monitoring.rst:444
msgid "The default queue is named `celery`. To get all available queues, invoke:"
msgstr ""

#: ../../userguide/monitoring.rst:452
msgid ""
"Queue keys only exists when there are tasks in them, so if a key doesn't "
"exist it simply means there are no messages in that queue. This is "
"because in Redis a list with no elements in it is automatically removed, "
"and hence it won't show up in the `keys` command output, and `llen` for "
"that list returns 0."
msgstr ""

#: ../../userguide/monitoring.rst:458
msgid ""
"Also, if you're using Redis for other purposes, the output of the `keys` "
"command will include unrelated values stored in the database. The "
"recommended way around this is to use a dedicated `DATABASE_NUMBER` for "
"Celery, you can also use database numbers to separate Celery applications"
" from each other (virtual hosts), but this won't affect the monitoring "
"events used by for example Flower as Redis pub/sub commands are global "
"rather than database based."
msgstr ""

#: ../../userguide/monitoring.rst:469
msgid "Munin"
msgstr ""

#: ../../userguide/monitoring.rst:471
msgid ""
"This is a list of known Munin plug-ins that can be useful when "
"maintaining a Celery cluster."
msgstr ""

#: ../../userguide/monitoring.rst:474
msgid "``rabbitmq-munin``: Munin plug-ins for RabbitMQ."
msgstr ""

#: ../../userguide/monitoring.rst:476
msgid "https://github.com/ask/rabbitmq-munin"
msgstr ""

#: ../../userguide/monitoring.rst:478
msgid ""
"``celery_tasks``: Monitors the number of times each task type has been "
"executed (requires `celerymon`)."
msgstr ""

#: ../../userguide/monitoring.rst:481
msgid ""
"https://github.com/munin-"
"monitoring/contrib/blob/master/plugins/celery/celery_tasks"
msgstr ""

#: ../../userguide/monitoring.rst:483
msgid ""
"``celery_tasks_states``: Monitors the number of tasks in each state "
"(requires `celerymon`)."
msgstr ""

#: ../../userguide/monitoring.rst:486
msgid ""
"https://github.com/munin-"
"monitoring/contrib/blob/master/plugins/celery/celery_tasks_states"
msgstr ""

#: ../../userguide/monitoring.rst:493
msgid ""
"The worker has the ability to send a message whenever some event happens."
" These events are then captured by tools like Flower, and "
":program:`celery events` to monitor the cluster."
msgstr ""

#: ../../userguide/monitoring.rst:500
msgid "Snapshots"
msgstr ""

#: ../../userguide/monitoring.rst:504
msgid ""
"Even a single worker can produce a huge amount of events, so storing the "
"history of all events on disk may be very expensive."
msgstr ""

#: ../../userguide/monitoring.rst:507
msgid ""
"A sequence of events describes the cluster state in that time period, by "
"taking periodic snapshots of this state you can keep all history, but "
"still only periodically write it to disk."
msgstr ""

#: ../../userguide/monitoring.rst:511
msgid ""
"To take snapshots you need a Camera class, with this you can define what "
"should happen every time the state is captured;  You can write it to a "
"database, send it by email or something else entirely."
msgstr ""

#: ../../userguide/monitoring.rst:515
msgid ""
":program:`celery events` is then used to take snapshots with the camera, "
"for example if you want to capture state every 2 seconds using the camera"
" ``myapp.Camera`` you run :program:`celery events` with the following "
"arguments:"
msgstr ""

#: ../../userguide/monitoring.rst:528
msgid "Custom Camera"
msgstr ""

#: ../../userguide/monitoring.rst:530
msgid ""
"Cameras can be useful if you need to capture events and do something with"
" those events at an interval. For real-time event processing you should "
"use :class:`@events.Receiver` directly, like in :ref:`event-real-time-"
"example`."
msgstr ""

#: ../../userguide/monitoring.rst:535
msgid "Here is an example camera, dumping the snapshot to screen:"
msgstr ""

#: ../../userguide/monitoring.rst:555
msgid ""
"See the API reference for :mod:`celery.events.state` to read more about "
"state objects."
msgstr ""

#: ../../userguide/monitoring.rst:558
msgid ""
"Now you can use this cam with :program:`celery events` by specifying it "
"with the :option:`-c <celery events -c>` option:"
msgstr ""

#: ../../userguide/monitoring.rst:565
msgid "Or you can use it programmatically like this:"
msgstr ""

#: ../../userguide/monitoring.rst:586
msgid "Real-time processing"
msgstr ""

#: ../../userguide/monitoring.rst:588
msgid "To process events in real-time you need the following"
msgstr ""

#: ../../userguide/monitoring.rst:590
msgid "An event consumer (this is the ``Receiver``)"
msgstr ""

#: ../../userguide/monitoring.rst:592
msgid "A set of handlers called when events come in."
msgstr ""

#: ../../userguide/monitoring.rst:594
msgid ""
"You can have different handlers for each event type, or a catch-all "
"handler can be used ('*')"
msgstr ""

#: ../../userguide/monitoring.rst:597
msgid "State (optional)"
msgstr ""

#: ../../userguide/monitoring.rst:599
msgid ""
":class:`@events.State` is a convenient in-memory representation of tasks "
"and workers in the cluster that's updated as events come in."
msgstr ""

#: ../../userguide/monitoring.rst:602
msgid ""
"It encapsulates solutions for many common things, like checking if a "
"worker is still alive (by verifying heartbeats), merging event fields "
"together as events come in, making sure time-stamps are in sync, and so "
"on."
msgstr ""

#: ../../userguide/monitoring.rst:607
msgid "Combining these you can easily process events in real-time:"
msgstr ""

#: ../../userguide/monitoring.rst:640
msgid ""
"The ``wakeup`` argument to ``capture`` sends a signal to all workers to "
"force them to send a heartbeat. This way you can immediately see workers "
"when the monitor starts."
msgstr ""

#: ../../userguide/monitoring.rst:645
msgid "You can listen to specific events by specifying the handlers:"
msgstr ""

#: ../../userguide/monitoring.rst:676
msgid "Event Reference"
msgstr ""

#: ../../userguide/monitoring.rst:678
msgid "This list contains the events sent by the worker, and their arguments."
msgstr ""

#: ../../userguide/monitoring.rst:683
msgid "Task Events"
msgstr ""

#: ../../userguide/monitoring.rst:688
msgid "task-sent"
msgstr ""

#: ../../userguide/monitoring.rst
msgid "signature"
msgstr ""

#: ../../userguide/monitoring.rst:690
msgid ""
"``task-sent(uuid, name, args, kwargs, retries, eta, expires, queue, "
"exchange, routing_key, root_id, parent_id)``"
msgstr ""

#: ../../userguide/monitoring.rst:693
msgid ""
"Sent when a task message is published and the "
":setting:`task_send_sent_event` setting is enabled."
msgstr ""

#: ../../userguide/monitoring.rst:699
msgid "task-received"
msgstr ""

#: ../../userguide/monitoring.rst:701
msgid ""
"``task-received(uuid, name, args, kwargs, retries, eta, hostname, "
"timestamp, root_id, parent_id)``"
msgstr ""

#: ../../userguide/monitoring.rst:704
msgid "Sent when the worker receives a task."
msgstr ""

#: ../../userguide/monitoring.rst:709
msgid "task-started"
msgstr ""

#: ../../userguide/monitoring.rst:711
msgid "``task-started(uuid, hostname, timestamp, pid)``"
msgstr ""

#: ../../userguide/monitoring.rst:713
msgid "Sent just before the worker executes the task."
msgstr ""

#: ../../userguide/monitoring.rst:718
msgid "task-succeeded"
msgstr ""

#: ../../userguide/monitoring.rst:720
msgid "``task-succeeded(uuid, result, runtime, hostname, timestamp)``"
msgstr ""

#: ../../userguide/monitoring.rst:722
msgid "Sent if the task executed successfully."
msgstr ""

#: ../../userguide/monitoring.rst:724
msgid ""
"Run-time is the time it took to execute the task using the pool. "
"(Starting from the task is sent to the worker pool, and ending when the "
"pool result handler callback is called)."
msgstr ""

#: ../../userguide/monitoring.rst:731
msgid "task-failed"
msgstr ""

#: ../../userguide/monitoring.rst:733
msgid "``task-failed(uuid, exception, traceback, hostname, timestamp)``"
msgstr ""

#: ../../userguide/monitoring.rst:735
msgid "Sent if the execution of the task failed."
msgstr ""

#: ../../userguide/monitoring.rst:740
msgid "task-rejected"
msgstr ""

#: ../../userguide/monitoring.rst:742
msgid "``task-rejected(uuid, requeued)``"
msgstr ""

#: ../../userguide/monitoring.rst:744
msgid ""
"The task was rejected by the worker, possibly to be re-queued or moved to"
" a dead letter queue."
msgstr ""

#: ../../userguide/monitoring.rst:750
msgid "task-revoked"
msgstr ""

#: ../../userguide/monitoring.rst:752
msgid "``task-revoked(uuid, terminated, signum, expired)``"
msgstr ""

#: ../../userguide/monitoring.rst:754
msgid ""
"Sent if the task has been revoked (Note that this is likely to be sent by"
" more than one worker)."
msgstr ""

#: ../../userguide/monitoring.rst:758
msgid "``terminated`` is set to true if the task process was terminated,"
msgstr ""

#: ../../userguide/monitoring.rst:758
msgid "and the ``signum`` field set to the signal used."
msgstr ""

#: ../../userguide/monitoring.rst:760
msgid "``expired`` is set to true if the task expired."
msgstr ""

#: ../../userguide/monitoring.rst:765
msgid "task-retried"
msgstr ""

#: ../../userguide/monitoring.rst:767
msgid "``task-retried(uuid, exception, traceback, hostname, timestamp)``"
msgstr ""

#: ../../userguide/monitoring.rst:769
msgid "Sent if the task failed, but will be retried in the future."
msgstr ""

#: ../../userguide/monitoring.rst:774
msgid "Worker Events"
msgstr ""

#: ../../userguide/monitoring.rst:779
msgid "worker-online"
msgstr ""

#: ../../userguide/monitoring.rst:781
msgid "``worker-online(hostname, timestamp, freq, sw_ident, sw_ver, sw_sys)``"
msgstr ""

#: ../../userguide/monitoring.rst:783
msgid "The worker has connected to the broker and is online."
msgstr ""

#: ../../userguide/monitoring.rst:785 ../../userguide/monitoring.rst:803
msgid "`hostname`: Nodename of the worker."
msgstr ""

#: ../../userguide/monitoring.rst:786 ../../userguide/monitoring.rst:804
msgid "`timestamp`: Event time-stamp."
msgstr ""

#: ../../userguide/monitoring.rst:787 ../../userguide/monitoring.rst:805
msgid "`freq`: Heartbeat frequency in seconds (float)."
msgstr ""

#: ../../userguide/monitoring.rst:788 ../../userguide/monitoring.rst:806
msgid "`sw_ident`: Name of worker software (e.g., ``py-celery``)."
msgstr ""

#: ../../userguide/monitoring.rst:789 ../../userguide/monitoring.rst:807
msgid "`sw_ver`: Software version (e.g., 2.2.0)."
msgstr ""

#: ../../userguide/monitoring.rst:790 ../../userguide/monitoring.rst:808
msgid "`sw_sys`: Operating System (e.g., Linux/Darwin)."
msgstr ""

#: ../../userguide/monitoring.rst:795
msgid "worker-heartbeat"
msgstr ""

#: ../../userguide/monitoring.rst:797
msgid ""
"``worker-heartbeat(hostname, timestamp, freq, sw_ident, sw_ver, sw_sys, "
"active, processed)``"
msgstr ""

#: ../../userguide/monitoring.rst:800
msgid ""
"Sent every minute, if the worker hasn't sent a heartbeat in 2 minutes, it"
" is considered to be offline."
msgstr ""

#: ../../userguide/monitoring.rst:809
msgid "`active`: Number of currently executing tasks."
msgstr ""

#: ../../userguide/monitoring.rst:810
msgid "`processed`: Total number of tasks processed by this worker."
msgstr ""

#: ../../userguide/monitoring.rst:815
msgid "worker-offline"
msgstr ""

#: ../../userguide/monitoring.rst:817
msgid "``worker-offline(hostname, timestamp, freq, sw_ident, sw_ver, sw_sys)``"
msgstr ""

#: ../../userguide/monitoring.rst:819
msgid "The worker has disconnected from the broker."
msgstr ""

#: ../../userguide/optimizing.rst:5
msgid "Optimizing"
msgstr ""

#: ../../userguide/optimizing.rst:9
msgid ""
"The default configuration makes a lot of compromises. It's not optimal "
"for any single case, but works well enough for most situations."
msgstr ""

#: ../../userguide/optimizing.rst:12
msgid "There are optimizations that can be applied based on specific use cases."
msgstr ""

#: ../../userguide/optimizing.rst:14
msgid ""
"Optimizations can apply to different properties of the running "
"environment, be it the time tasks take to execute, the amount of memory "
"used, or responsiveness at times of high load."
msgstr ""

#: ../../userguide/optimizing.rst:19
msgid "Ensuring Operations"
msgstr ""

#: ../../userguide/optimizing.rst:21
msgid ""
"In the book `Programming Pearls`_, Jon Bentley presents the concept of "
"back-of-the-envelope calculations by asking the question;"
msgstr ""

#: ../../userguide/optimizing.rst:24
msgid "❝ How much water flows out of the Mississippi River in a day? ❞"
msgstr ""

#: ../../userguide/optimizing.rst:26
msgid ""
"The point of this exercise [*]_ is to show that there's a limit to how "
"much data a system can process in a timely manner. Back of the envelope "
"calculations can be used as a means to plan for this ahead of time."
msgstr ""

#: ../../userguide/optimizing.rst:31
msgid ""
"In Celery; If a task takes 10 minutes to complete, and there are 10 new "
"tasks coming in every minute, the queue will never be empty. This is why "
"it's very important that you monitor queue lengths!"
msgstr ""

#: ../../userguide/optimizing.rst:36
msgid ""
"A way to do this is by :ref:`using Munin <monitoring-munin>`. You should "
"set up alerts, that'll notify you as soon as any queue has reached an "
"unacceptable size. This way you can take appropriate action like adding "
"new worker nodes, or revoking unnecessary tasks."
msgstr ""

#: ../../userguide/optimizing.rst:49
msgid "General Settings"
msgstr ""

#: ../../userguide/optimizing.rst:54
msgid "librabbitmq"
msgstr ""

#: ../../userguide/optimizing.rst:56
msgid ""
"If you're using RabbitMQ (AMQP) as the broker then you can install the "
":pypi:`librabbitmq` module to use an optimized client written in C:"
msgstr ""

#: ../../userguide/optimizing.rst:63
msgid ""
"The 'amqp' transport will automatically use the librabbitmq module if "
"it's installed, or you can also specify the transport you want directly "
"by using the ``pyamqp://`` or ``librabbitmq://`` prefixes."
msgstr ""

#: ../../userguide/optimizing.rst:70
msgid "Broker Connection Pools"
msgstr ""

#: ../../userguide/optimizing.rst:72
msgid "The broker connection pool is enabled by default since version 2.5."
msgstr ""

#: ../../userguide/optimizing.rst:74
msgid ""
"You can tweak the :setting:`broker_pool_limit` setting to minimize "
"contention, and the value should be based on the number of active threads"
"/green-threads using broker connections."
msgstr ""

#: ../../userguide/optimizing.rst:81
msgid "Using Transient Queues"
msgstr ""

#: ../../userguide/optimizing.rst:83
msgid ""
"Queues created by Celery are persistent by default. This means that the "
"broker will write messages to disk to ensure that the tasks will be "
"executed even if the broker is restarted."
msgstr ""

#: ../../userguide/optimizing.rst:87
msgid ""
"But in some cases it's fine that the message is lost, so not all tasks "
"require durability. You can create a *transient* queue for these tasks to"
" improve performance:"
msgstr ""

#: ../../userguide/optimizing.rst:102
msgid "or by using :setting:`task_routes`:"
msgstr ""

#: ../../userguide/optimizing.rst:111
msgid ""
"The ``delivery_mode`` changes how the messages to this queue are "
"delivered. A value of one means that the message won't be written to "
"disk, and a value of two (default) means that the message can be written "
"to disk."
msgstr ""

#: ../../userguide/optimizing.rst:115
msgid ""
"To direct a task to your new transient queue you can specify the queue "
"argument (or use the :setting:`task_routes` setting):"
msgstr ""

#: ../../userguide/optimizing.rst:122
msgid "For more information see the :ref:`routing guide <guide-routing>`."
msgstr ""

#: ../../userguide/optimizing.rst:127
msgid "Worker Settings"
msgstr ""

#: ../../userguide/optimizing.rst:132
msgid "Prefetch Limits"
msgstr ""

#: ../../userguide/optimizing.rst:134
msgid ""
"*Prefetch* is a term inherited from AMQP that's often misunderstood by "
"users."
msgstr ""

#: ../../userguide/optimizing.rst:137
msgid ""
"The prefetch limit is a **limit** for the number of tasks (messages) a "
"worker can reserve for itself. If it is zero, the worker will keep "
"consuming messages, not respecting that there may be other available "
"worker nodes that may be able to process them sooner [*]_, or that the "
"messages may not even fit in memory."
msgstr ""

#: ../../userguide/optimizing.rst:143
msgid ""
"The workers' default prefetch count is the "
":setting:`worker_prefetch_multiplier` setting multiplied by the number of"
" concurrency slots [*]_ (processes/threads/green-threads)."
msgstr ""

#: ../../userguide/optimizing.rst:147
msgid ""
"If you have many tasks with a long duration you want the multiplier value"
" to be *one*: meaning it'll only reserve one task per worker process at a"
" time."
msgstr ""

#: ../../userguide/optimizing.rst:151
msgid ""
"However -- If you have many short-running tasks, and throughput/round "
"trip latency is important to you, this number should be large. The worker"
" is able to process more tasks per second if the messages have already "
"been prefetched, and is available in memory. You may have to experiment "
"to find the best value that works for you. Values like 50 or 150 might "
"make sense in these circumstances. Say 64, or 128."
msgstr ""

#: ../../userguide/optimizing.rst:158
msgid ""
"If you have a combination of long- and short-running tasks, the best "
"option is to use two worker nodes that are configured separately, and "
"route the tasks according to the run-time (see :ref:`guide-routing`)."
msgstr ""

#: ../../userguide/optimizing.rst:163
msgid "Reserve one task at a time"
msgstr ""

#: ../../userguide/optimizing.rst:165
msgid ""
"The task message is only deleted from the queue after the task is "
":term:`acknowledged`, so if the worker crashes before acknowledging the "
"task, it can be redelivered to another worker (or the same after "
"recovery)."
msgstr ""

#: ../../userguide/optimizing.rst:169
msgid ""
"When using the default of early acknowledgment, having a prefetch "
"multiplier setting of *one*, means the worker will reserve at most one "
"extra task for every worker process: or in other words, if the worker is "
"started with :option:`-c 10 <celery worker -c>`, the worker may reserve "
"at most 20 tasks (10 acknowledged tasks executing, and 10 unacknowledged "
"reserved tasks) at any time."
msgstr ""

#: ../../userguide/optimizing.rst:176
msgid ""
"Often users ask if disabling \"prefetching of tasks\" is possible, but "
"what they really mean by that, is to have a worker only reserve as many "
"tasks as there are worker processes (10 unacknowledged tasks for "
":option:`-c 10 <celery worker -c>`)"
msgstr ""

#: ../../userguide/optimizing.rst:181
msgid ""
"That's possible, but not without also enabling :term:`late "
"acknowledgment`. Using this option over the default behavior means a task"
" that's already started executing will be retried in the event of a power"
" failure or the worker instance being killed abruptly, so this also means"
" the task must be :term:`idempotent`"
msgstr ""

#: ../../userguide/optimizing.rst:189
msgid "Notes at :ref:`faq-acks_late-vs-retry`."
msgstr ""

#: ../../userguide/optimizing.rst:191
msgid "You can enable this behavior by using the following configuration options:"
msgstr ""

#: ../../userguide/optimizing.rst:201
msgid "Prefork pool prefetch settings"
msgstr ""

#: ../../userguide/optimizing.rst:203
msgid ""
"The prefork pool will asynchronously send as many tasks to the processes "
"as it can and this means that the processes are, in effect, prefetching "
"tasks."
msgstr ""

#: ../../userguide/optimizing.rst:207
msgid ""
"This benefits performance but it also means that tasks may be stuck "
"waiting for long running tasks to complete::"
msgstr ""

#: ../../userguide/optimizing.rst:222
msgid ""
"The worker will send tasks to the process as long as the pipe buffer is "
"writable. The pipe buffer size varies based on the operating system: some"
" may have a buffer as small as 64KB but on recent Linux versions the "
"buffer size is 1MB (can only be changed system wide)."
msgstr ""

#: ../../userguide/optimizing.rst:227
msgid ""
"You can disable this prefetching behavior by enabling the :option:`-O "
"fair <celery worker -O>` worker option:"
msgstr ""

#: ../../userguide/optimizing.rst:234
msgid ""
"With this option enabled the worker will only write to processes that are"
" available for work, disabling the prefetch behavior::"
msgstr ""

#: ../../userguide/optimizing.rst:250 ../../userguide/security.rst:256
msgid "Footnotes"
msgstr ""

#: ../../userguide/optimizing.rst:251
msgid ""
"The chapter is available to read for free here: `The back of the "
"envelope`_. The book is a classic text. Highly recommended."
msgstr ""

#: ../../userguide/optimizing.rst:255
msgid ""
"RabbitMQ and other brokers deliver messages round-robin, so this doesn't "
"apply to an active system. If there's no prefetch limit and you restart "
"the cluster, there will be timing delays between nodes starting. If there"
" are 3 offline nodes and one active node, all messages will be delivered "
"to the active node."
msgstr ""

#: ../../userguide/optimizing.rst:261
msgid ""
"This is the concurrency setting; :setting:`worker_concurrency` or the "
":option:`celery worker -c` option."
msgstr ""

#: ../../userguide/periodic-tasks.rst:5
msgid "Periodic Tasks"
msgstr ""

#: ../../userguide/periodic-tasks.rst:13
msgid ""
":program:`celery beat` is a scheduler; It kicks off tasks at regular "
"intervals, that are then executed by available worker nodes in the "
"cluster."
msgstr ""

#: ../../userguide/periodic-tasks.rst:16
msgid ""
"By default the entries are taken from the :setting:`beat_schedule` "
"setting, but custom stores can also be used, like storing the entries in "
"a SQL database."
msgstr ""

#: ../../userguide/periodic-tasks.rst:19
msgid ""
"You have to ensure only a single scheduler is running for a schedule at a"
" time, otherwise you'd end up with duplicate tasks. Using a centralized "
"approach means the schedule doesn't have to be synchronized, and the "
"service can operate without using locks."
msgstr ""

#: ../../userguide/periodic-tasks.rst:27
msgid "Time Zones"
msgstr ""

#: ../../userguide/periodic-tasks.rst:29
msgid ""
"The periodic task schedules uses the UTC time zone by default, but you "
"can change the time zone used using the :setting:`timezone` setting."
msgstr ""

#: ../../userguide/periodic-tasks.rst:33
msgid "An example time zone could be `Europe/London`:"
msgstr ""

#: ../../userguide/periodic-tasks.rst:39
msgid ""
"This setting must be added to your app, either by configuring it directly"
" using (``app.conf.timezone = 'Europe/London'``), or by adding it to your"
" configuration module if you have set one up using "
"``app.config_from_object``. See :ref:`celerytut-configuration` for more "
"information about configuration options."
msgstr ""

#: ../../userguide/periodic-tasks.rst:45
msgid ""
"The default scheduler (storing the schedule in the :file:`celerybeat-"
"schedule` file) will automatically detect that the time zone has changed,"
" and so will reset the schedule itself, but other schedulers may not be "
"so smart (e.g., the Django database scheduler, see below) and in that "
"case you'll have to reset the schedule manually."
msgstr ""

#: ../../userguide/periodic-tasks.rst:51
msgid "Django Users"
msgstr ""

#: ../../userguide/periodic-tasks.rst:53
msgid ""
"Celery recommends and is compatible with the new ``USE_TZ`` setting "
"introduced in Django 1.4."
msgstr ""

#: ../../userguide/periodic-tasks.rst:56
msgid ""
"For Django users the time zone specified in the ``TIME_ZONE`` setting "
"will be used, or you can specify a custom time zone for Celery alone by "
"using the :setting:`timezone` setting."
msgstr ""

#: ../../userguide/periodic-tasks.rst:60
msgid ""
"The database scheduler won't reset when timezone related settings change,"
" so you must do this manually:"
msgstr ""

#: ../../userguide/periodic-tasks.rst:69
msgid ""
"Django-Celery only supports Celery 4.0 and below, for Celery 4.0 and "
"above, do as follow:"
msgstr ""

#: ../../userguide/periodic-tasks.rst:80
msgid "Entries"
msgstr ""

#: ../../userguide/periodic-tasks.rst:82
msgid ""
"To call a task periodically you have to add an entry to the beat schedule"
" list."
msgstr ""

#: ../../userguide/periodic-tasks.rst:111
msgid ""
"Setting these up from within the :data:`~@on_after_configure` handler "
"means that we'll not evaluate the app at module level when using "
"``test.s()``."
msgstr ""

#: ../../userguide/periodic-tasks.rst:114
msgid ""
"The :meth:`~@add_periodic_task` function will add the entry to the "
":setting:`beat_schedule` setting behind the scenes, and the same setting "
"can also be used to set up periodic tasks manually:"
msgstr ""

#: ../../userguide/periodic-tasks.rst:118
msgid "Example: Run the `tasks.add` task every 30 seconds."
msgstr ""

#: ../../userguide/periodic-tasks.rst:134
msgid ""
"If you're wondering where these settings should go then please see :ref"
":`celerytut-configuration`. You can either set these options on your app "
"directly or you can keep a separate module for configuration."
msgstr ""

#: ../../userguide/periodic-tasks.rst:139
msgid ""
"If you want to use a single item tuple for `args`, don't forget that the "
"constructor is a comma, and not a pair of parentheses."
msgstr ""

#: ../../userguide/periodic-tasks.rst:142
msgid ""
"Using a :class:`~datetime.timedelta` for the schedule means the task will"
" be sent in 30 second intervals (the first task will be sent 30 seconds "
"after `celery beat` starts, and then every 30 seconds after the last "
"run)."
msgstr ""

#: ../../userguide/periodic-tasks.rst:147
msgid ""
"A Crontab like schedule also exists, see the section on `Crontab "
"schedules`_."
msgstr ""

#: ../../userguide/periodic-tasks.rst:149
msgid ""
"Like with :command:`cron`, the tasks may overlap if the first task "
"doesn't complete before the next. If that's a concern you should use a "
"locking strategy to ensure only one instance can run at a time (see for "
"example :ref:`cookbook-task-serial`)."
msgstr ""

#: ../../userguide/periodic-tasks.rst:157
msgid "Available Fields"
msgstr ""

#: ../../userguide/periodic-tasks.rst:159
msgid "`task`"
msgstr ""

#: ../../userguide/periodic-tasks.rst:161
msgid "The name of the task to execute."
msgstr ""

#: ../../userguide/periodic-tasks.rst:163
msgid "`schedule`"
msgstr ""

#: ../../userguide/periodic-tasks.rst:165
msgid "The frequency of execution."
msgstr ""

#: ../../userguide/periodic-tasks.rst:167
msgid ""
"This can be the number of seconds as an integer, a "
":class:`~datetime.timedelta`, or a :class:`~celery.schedules.crontab`. "
"You can also define your own custom schedule types, by extending the "
"interface of :class:`~celery.schedules.schedule`."
msgstr ""

#: ../../userguide/periodic-tasks.rst:172
msgid "`args`"
msgstr ""

#: ../../userguide/periodic-tasks.rst:174
msgid "Positional arguments (:class:`list` or :class:`tuple`)."
msgstr ""

#: ../../userguide/periodic-tasks.rst:176
msgid "`kwargs`"
msgstr ""

#: ../../userguide/periodic-tasks.rst:178
msgid "Keyword arguments (:class:`dict`)."
msgstr ""

#: ../../userguide/periodic-tasks.rst:180
msgid "`options`"
msgstr ""

#: ../../userguide/periodic-tasks.rst:182
msgid "Execution options (:class:`dict`)."
msgstr ""

#: ../../userguide/periodic-tasks.rst:184
msgid ""
"This can be any argument supported by "
":meth:`~celery.task.base.Task.apply_async` -- `exchange`, `routing_key`, "
"`expires`, and so on."
msgstr ""

#: ../../userguide/periodic-tasks.rst:188
msgid "`relative`"
msgstr ""

#: ../../userguide/periodic-tasks.rst:190
msgid ""
"If `relative` is true :class:`~datetime.timedelta` schedules are "
"scheduled \"by the clock.\" This means the frequency is rounded to the "
"nearest second, minute, hour or day depending on the period of the "
":class:`~datetime.timedelta`."
msgstr ""

#: ../../userguide/periodic-tasks.rst:195
msgid ""
"By default `relative` is false, the frequency isn't rounded and will be "
"relative to the time when :program:`celery beat` was started."
msgstr ""

#: ../../userguide/periodic-tasks.rst:201
msgid "Crontab schedules"
msgstr ""

#: ../../userguide/periodic-tasks.rst:203
msgid ""
"If you want more control over when the task is executed, for example, a "
"particular time of day or day of the week, you can use the "
":class:`~celery.schedules.crontab` schedule type:"
msgstr ""

#: ../../userguide/periodic-tasks.rst:220
msgid "The syntax of these Crontab expressions are very flexible."
msgstr ""

#: ../../userguide/periodic-tasks.rst:222
msgid "Some examples:"
msgstr ""

#: ../../userguide/periodic-tasks.rst:225 ../../userguide/workers.rst:355
#: ../../userguide/workers.rst:383
msgid "**Example**"
msgstr ""

#: ../../userguide/periodic-tasks.rst:225
#: ../../userguide/periodic-tasks.rst:309
#: ../../userguide/periodic-tasks.rst:323
msgid "**Meaning**"
msgstr ""

#: ../../userguide/periodic-tasks.rst:227
msgid "``crontab()``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:227
msgid "Execute every minute."
msgstr ""

#: ../../userguide/periodic-tasks.rst:229
msgid "``crontab(minute=0, hour=0)``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:229
msgid "Execute daily at midnight."
msgstr ""

#: ../../userguide/periodic-tasks.rst:231
msgid "``crontab(minute=0, hour='*/3')``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:231
msgid "Execute every three hours: midnight, 3am, 6am, 9am, noon, 3pm, 6pm, 9pm."
msgstr ""

#: ../../userguide/periodic-tasks.rst:235
msgid "``crontab(minute=0,``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:236
msgid "``hour='0,3,6,9,12,15,18,21')``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:235
#: ../../userguide/periodic-tasks.rst:242
msgid "Same as previous."
msgstr ""

#: ../../userguide/periodic-tasks.rst:238
msgid "``crontab(minute='*/15')``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:238
msgid "Execute every 15 minutes."
msgstr ""

#: ../../userguide/periodic-tasks.rst:240
msgid "``crontab(day_of_week='sunday')``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:240
msgid "Execute every minute (!) at Sundays."
msgstr ""

#: ../../userguide/periodic-tasks.rst:243
msgid "``crontab(minute='*',``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:243
msgid "``hour='*',`` ``day_of_week='sun')``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:247
msgid "``crontab(minute='*/10',``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:247
msgid "``hour='3,17,22',`` ``day_of_week='thu,fri')``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:246
msgid ""
"Execute every ten minutes, but only between 3-4 am, 5-6 pm, and 10-11 pm "
"on Thursdays or Fridays."
msgstr ""

#: ../../userguide/periodic-tasks.rst:250
msgid "``crontab(minute=0, hour='*/2,*/3')``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:250
msgid ""
"Execute every even hour, and every hour divisible by three. This means: "
"at every hour *except*: 1am, 5am, 7am, 11am, 1pm, 5pm, 7pm, 11pm"
msgstr ""

#: ../../userguide/periodic-tasks.rst:256
msgid "``crontab(minute=0, hour='*/5')``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:256
msgid ""
"Execute hour divisible by 5. This means that it is triggered at 3pm, not "
"5pm (since 3pm equals the 24-hour clock value of \"15\", which is "
"divisible by 5)."
msgstr ""

#: ../../userguide/periodic-tasks.rst:261
msgid "``crontab(minute=0, hour='*/3,8-17')``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:261
msgid ""
"Execute every hour divisible by 3, and every hour during office hours "
"(8am-5pm)."
msgstr ""

#: ../../userguide/periodic-tasks.rst:264
msgid "``crontab(0, 0, day_of_month='2')``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:264
msgid "Execute on the second day of every month."
msgstr ""

#: ../../userguide/periodic-tasks.rst:267
#: ../../userguide/periodic-tasks.rst:270
#: ../../userguide/periodic-tasks.rst:276
msgid "``crontab(0, 0,``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:268
msgid "``day_of_month='2-30/2')``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:267
msgid "Execute on every even numbered day."
msgstr ""

#: ../../userguide/periodic-tasks.rst:271
msgid "``day_of_month='1-7,15-21')``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:270
msgid "Execute on the first and third weeks of the month."
msgstr ""

#: ../../userguide/periodic-tasks.rst:273
msgid "``crontab(0, 0, day_of_month='11',``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:274
msgid "``month_of_year='5')``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:273
msgid "Execute on the eleventh of May every year."
msgstr ""

#: ../../userguide/periodic-tasks.rst:277
msgid "``month_of_year='*/3')``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:276
msgid "Execute every day on the first month of every quarter."
msgstr ""

#: ../../userguide/periodic-tasks.rst:280
msgid "See :class:`celery.schedules.crontab` for more documentation."
msgstr ""

#: ../../userguide/periodic-tasks.rst:285
msgid "Solar schedules"
msgstr ""

#: ../../userguide/periodic-tasks.rst:287
msgid ""
"If you have a task that should be executed according to sunrise, sunset, "
"dawn or dusk, you can use the :class:`~celery.schedules.solar` schedule "
"type:"
msgstr ""

#: ../../userguide/periodic-tasks.rst:304
msgid "The arguments are simply: ``solar(event, latitude, longitude)``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:306
msgid "Be sure to use the correct sign for latitude and longitude:"
msgstr ""

#: ../../userguide/periodic-tasks.rst:309
msgid "**Sign**"
msgstr ""

#: ../../userguide/periodic-tasks.rst:309
msgid "**Argument**"
msgstr ""

#: ../../userguide/periodic-tasks.rst:311
#: ../../userguide/periodic-tasks.rst:315
msgid "``+``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:311
#: ../../userguide/periodic-tasks.rst:313
msgid "``latitude``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:311
msgid "North"
msgstr ""

#: ../../userguide/periodic-tasks.rst:313
#: ../../userguide/periodic-tasks.rst:317
msgid "``-``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:313
msgid "South"
msgstr ""

#: ../../userguide/periodic-tasks.rst:315
#: ../../userguide/periodic-tasks.rst:317
msgid "``longitude``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:315
msgid "East"
msgstr ""

#: ../../userguide/periodic-tasks.rst:317
msgid "West"
msgstr ""

#: ../../userguide/periodic-tasks.rst:320
msgid "Possible event types are:"
msgstr ""

#: ../../userguide/periodic-tasks.rst:323
msgid "**Event**"
msgstr ""

#: ../../userguide/periodic-tasks.rst:325
msgid "``dawn_astronomical``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:325
msgid ""
"Execute at the moment after which the sky is no longer completely dark. "
"This is when the sun is 18 degrees below the horizon."
msgstr ""

#: ../../userguide/periodic-tasks.rst:329
msgid "``dawn_nautical``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:329
msgid ""
"Execute when there's enough sunlight for the horizon and some objects to "
"be distinguishable; formally, when the sun is 12 degrees below the "
"horizon."
msgstr ""

#: ../../userguide/periodic-tasks.rst:334
msgid "``dawn_civil``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:334
msgid ""
"Execute when there's enough light for objects to be distinguishable so "
"that outdoor activities can commence; formally, when the Sun is 6 degrees"
" below the horizon."
msgstr ""

#: ../../userguide/periodic-tasks.rst:340
msgid "``sunrise``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:340
msgid ""
"Execute when the upper edge of the sun appears over the eastern horizon "
"in the morning."
msgstr ""

#: ../../userguide/periodic-tasks.rst:344
msgid "``solar_noon``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:344
msgid "Execute when the sun is highest above the horizon on that day."
msgstr ""

#: ../../userguide/periodic-tasks.rst:347
msgid "``sunset``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:347
msgid ""
"Execute when the trailing edge of the sun disappears over the western "
"horizon in the evening."
msgstr ""

#: ../../userguide/periodic-tasks.rst:351
msgid "``dusk_civil``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:351
msgid ""
"Execute at the end of civil twilight, when objects are still "
"distinguishable and some stars and planets are visible. Formally, when "
"the sun is 6 degrees below the horizon."
msgstr ""

#: ../../userguide/periodic-tasks.rst:357
msgid "``dusk_nautical``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:357
msgid ""
"Execute when the sun is 12 degrees below the horizon. Objects are no "
"longer distinguishable, and the horizon is no longer visible to the naked"
" eye."
msgstr ""

#: ../../userguide/periodic-tasks.rst:362
msgid "``dusk_astronomical``"
msgstr ""

#: ../../userguide/periodic-tasks.rst:362
msgid ""
"Execute at the moment after which the sky becomes completely dark; "
"formally, when the sun is 18 degrees below the horizon."
msgstr ""

#: ../../userguide/periodic-tasks.rst:367
msgid ""
"All solar events are calculated using UTC, and are therefore unaffected "
"by your timezone setting."
msgstr ""

#: ../../userguide/periodic-tasks.rst:370
msgid ""
"In polar regions, the sun may not rise or set every day. The scheduler is"
" able to handle these cases (i.e., a ``sunrise`` event won't run on a day"
" when the sun doesn't rise). The one exception is ``solar_noon``, which "
"is formally defined as the moment the sun transits the celestial "
"meridian, and will occur every day even if the sun is below the horizon."
msgstr ""

#: ../../userguide/periodic-tasks.rst:376
msgid ""
"Twilight is defined as the period between dawn and sunrise; and between "
"sunset and dusk. You can schedule an event according to \"twilight\" "
"depending on your definition of twilight (civil, nautical, or "
"astronomical), and whether you want the event to take place at the "
"beginning or end of twilight, using the appropriate event from the list "
"above."
msgstr ""

#: ../../userguide/periodic-tasks.rst:382
msgid "See :class:`celery.schedules.solar` for more documentation."
msgstr ""

#: ../../userguide/periodic-tasks.rst:387
msgid "Starting the Scheduler"
msgstr ""

#: ../../userguide/periodic-tasks.rst:389
msgid "To start the :program:`celery beat` service:"
msgstr ""

#: ../../userguide/periodic-tasks.rst:395
msgid ""
"You can also embed `beat` inside the worker by enabling the workers "
":option:`-B <celery worker -B>` option, this is convenient if you'll "
"never run more than one worker node, but it's not commonly used and for "
"that reason isn't recommended for production use:"
msgstr ""

#: ../../userguide/periodic-tasks.rst:404
msgid ""
"Beat needs to store the last run times of the tasks in a local database "
"file (named `celerybeat-schedule` by default), so it needs access to "
"write in the current directory, or alternatively you can specify a custom"
" location for this file:"
msgstr ""

#: ../../userguide/periodic-tasks.rst:416
msgid "To daemonize beat see :ref:`daemonizing`."
msgstr ""

#: ../../userguide/periodic-tasks.rst:421
msgid "Using custom scheduler classes"
msgstr ""

#: ../../userguide/periodic-tasks.rst:423
msgid ""
"Custom scheduler classes can be specified on the command-line (the "
":option:`--scheduler <celery beat --scheduler>` argument)."
msgstr ""

#: ../../userguide/periodic-tasks.rst:426
msgid ""
"The default scheduler is the :class:`celery.beat.PersistentScheduler`, "
"that simply keeps track of the last run times in a local :mod:`shelve` "
"database file."
msgstr ""

#: ../../userguide/periodic-tasks.rst:430
msgid ""
"There's also the :pypi:`django-celery-beat` extension that stores the "
"schedule in the Django database, and presents a convenient admin "
"interface to manage periodic tasks at runtime."
msgstr ""

#: ../../userguide/periodic-tasks.rst:434
msgid "To install and use this extension:"
msgstr ""

#: ../../userguide/periodic-tasks.rst:436
msgid "Use :command:`pip` to install the package:"
msgstr ""

#: ../../userguide/periodic-tasks.rst:442
msgid ""
"Add the ``django_celery_beat`` module to ``INSTALLED_APPS`` in your "
"Django project' :file:`settings.py`::"
msgstr ""

#: ../../userguide/periodic-tasks.rst:450
msgid "Note that there is no dash in the module name, only underscores."
msgstr ""

#: ../../userguide/periodic-tasks.rst:452
msgid "Apply Django database migrations so that the necessary tables are created:"
msgstr ""

#: ../../userguide/periodic-tasks.rst:458
msgid ""
"Start the :program:`celery beat` service using the "
"``django_celery_beat.schedulers:DatabaseScheduler`` scheduler:"
msgstr ""

#: ../../userguide/periodic-tasks.rst:464
msgid "Note:  You may also add this as an settings option directly."
msgstr ""

#: ../../userguide/periodic-tasks.rst:466
msgid "Visit the Django-Admin interface to set up some periodic tasks."
msgstr ""

#: ../../userguide/routing.rst:5 ../../userguide/routing.rst:559
msgid "Routing Tasks"
msgstr ""

#: ../../userguide/routing.rst:9
msgid ""
"Alternate routing concepts like topic and fanout is not available for all"
" transports, please consult the :ref:`transport comparison table <kombu"
":transport-comparison>`."
msgstr ""

#: ../../userguide/routing.rst:25
msgid "Automatic routing"
msgstr ""

#: ../../userguide/routing.rst:27
msgid ""
"The simplest way to do routing is to use the "
":setting:`task_create_missing_queues` setting (on by default)."
msgstr ""

#: ../../userguide/routing.rst:30
msgid ""
"With this setting on, a named queue that's not already defined in "
":setting:`task_queues` will be created automatically. This makes it easy "
"to perform simple routing tasks."
msgstr ""

#: ../../userguide/routing.rst:34
msgid ""
"Say you have two servers, `x`, and `y` that handle regular tasks, and one"
" server `z`, that only handles feed related tasks. You can use this "
"configuration::"
msgstr ""

#: ../../userguide/routing.rst:40
msgid ""
"With this route enabled import feed tasks will be routed to the "
"`\"feeds\"` queue, while all other tasks will be routed to the default "
"queue (named `\"celery\"` for historical reasons)."
msgstr ""

#: ../../userguide/routing.rst:44
msgid ""
"Alternatively, you can use glob pattern matching, or even regular "
"expressions, to match all tasks in the ``feed.tasks`` name-space:"
msgstr ""

#: ../../userguide/routing.rst:51
msgid ""
"If the order of matching patterns is important you should specify the "
"router in *items* format instead:"
msgstr ""

#: ../../userguide/routing.rst:64
msgid ""
"The :setting:`task_routes` setting can either be a dictionary, or a list "
"of router objects, so in this case we need to specify the setting as a "
"tuple containing a list."
msgstr ""

#: ../../userguide/routing.rst:68
msgid ""
"After installing the router, you can start server `z` to only process the"
" feeds queue like this:"
msgstr ""

#: ../../userguide/routing.rst:75
msgid ""
"You can specify as many queues as you want, so you can make this server "
"process the default queue as well:"
msgstr ""

#: ../../userguide/routing.rst:85
msgid "Changing the name of the default queue"
msgstr ""

#: ../../userguide/routing.rst:87
msgid ""
"You can change the name of the default queue by using the following "
"configuration:"
msgstr ""

#: ../../userguide/routing.rst:97
msgid "How the queues are defined"
msgstr ""

#: ../../userguide/routing.rst:99
msgid ""
"The point with this feature is to hide the complex AMQP protocol for "
"users with only basic needs. However -- you may still be interested in "
"how these queues are declared."
msgstr ""

#: ../../userguide/routing.rst:103
msgid "A queue named `\"video\"` will be created with the following settings:"
msgstr ""

#: ../../userguide/routing.rst:111
msgid ""
"The non-AMQP backends like `Redis` or `SQS` don't support exchanges, so "
"they require the exchange to have the same name as the queue. Using this "
"design ensures it will work for them as well."
msgstr ""

#: ../../userguide/routing.rst:118
msgid "Manual routing"
msgstr ""

#: ../../userguide/routing.rst:120
msgid ""
"Say you have two servers, `x`, and `y` that handle regular tasks, and one"
" server `z`, that only handles feed related tasks, you can use this "
"configuration:"
msgstr ""

#: ../../userguide/routing.rst:137
msgid ""
":setting:`task_queues` is a list of :class:`~kombu.entitity.Queue` "
"instances. If you don't set the exchange or exchange type values for a "
"key, these will be taken from the :setting:`task_default_exchange` and "
":setting:`task_default_exchange_type` settings."
msgstr ""

#: ../../userguide/routing.rst:143
msgid ""
"To route a task to the `feed_tasks` queue, you can add an entry in the "
":setting:`task_routes` setting:"
msgstr ""

#: ../../userguide/routing.rst:156
msgid ""
"You can also override this using the `routing_key` argument to "
":meth:`Task.apply_async`, or :func:`~celery.execute.send_task`:"
msgstr ""

#: ../../userguide/routing.rst:165
msgid ""
"To make server `z` consume from the feed queue exclusively you can start "
"it with the :option:`celery worker -Q` option:"
msgstr ""

#: ../../userguide/routing.rst:172
msgid "Servers `x` and `y` must be configured to consume from the default queue:"
msgstr ""

#: ../../userguide/routing.rst:179
msgid ""
"If you want, you can even have your feed processing worker handle regular"
" tasks as well, maybe in times when there's a lot of work to do:"
msgstr ""

#: ../../userguide/routing.rst:186
msgid ""
"If you have another queue but on another exchange you want to add, just "
"specify a custom exchange and exchange type:"
msgstr ""

#: ../../userguide/routing.rst:200
msgid "If you're confused about these terms, you should read up on AMQP."
msgstr ""

#: ../../userguide/routing.rst:204
msgid ""
"In addition to the :ref:`amqp-primer` below, there's `Rabbits and "
"Warrens`_, an excellent blog post describing queues and exchanges. "
"There's also The `CloudAMQP tutorial`, For users of RabbitMQ the "
"`RabbitMQ FAQ`_ could be useful as a source of information."
msgstr ""

#: ../../userguide/routing.rst:218
msgid "Special Routing Options"
msgstr ""

#: ../../userguide/routing.rst:223
msgid "RabbitMQ Message Priorities"
msgstr ""

#: ../../userguide/routing.rst:228
msgid ""
"Queues can be configured to support priorities by setting the ``x-max-"
"priority`` argument:"
msgstr ""

#: ../../userguide/routing.rst:240
msgid ""
"A default value for all queues can be set using the "
":setting:`task_queue_max_priority` setting:"
msgstr ""

#: ../../userguide/routing.rst:247
msgid ""
"A default priority for all tasks can also be specified using the "
":setting:`task_default_priority` setting:"
msgstr ""

#: ../../userguide/routing.rst:258
msgid "Redis Message Priorities"
msgstr ""

#: ../../userguide/routing.rst:261
msgid ""
"While the Celery Redis transport does honor the priority field, Redis "
"itself has no notion of priorities. Please read this note before "
"attempting to implement priorities with Redis as you may experience some "
"unexpected behavior."
msgstr ""

#: ../../userguide/routing.rst:265
msgid ""
"The priority support is implemented by creating n lists for each queue. "
"This means that even though there are 10 (0-9) priority levels, these are"
" consolidated into 4 levels by default to save resources. This means that"
" a queue named celery will really be split into 4 queues:"
msgstr ""

#: ../../userguide/routing.rst:275
msgid ""
"If you want more priority levels you can set the priority_steps transport"
" option:"
msgstr ""

#: ../../userguide/routing.rst:284
msgid ""
"That said, note that this will never be as good as priorities implemented"
" at the server level, and may be approximate at best. But it may still be"
" good enough for your application."
msgstr ""

#: ../../userguide/routing.rst:290
msgid "AMQP Primer"
msgstr ""

#: ../../userguide/routing.rst:293
msgid "Messages"
msgstr ""

#: ../../userguide/routing.rst:295
msgid ""
"A message consists of headers and a body. Celery uses headers to store "
"the content type of the message and its content encoding. The content "
"type is usually the serialization format used to serialize the message. "
"The body contains the name of the task to execute, the task id (UUID), "
"the arguments to apply it with and some additional meta-data -- like the "
"number of retries or an ETA."
msgstr ""

#: ../../userguide/routing.rst:302
msgid "This is an example task message represented as a Python dictionary:"
msgstr ""

#: ../../userguide/routing.rst:314
msgid "Producers, consumers, and brokers"
msgstr ""

#: ../../userguide/routing.rst:316
msgid ""
"The client sending messages is typically called a *publisher*, or a "
"*producer*, while the entity receiving messages is called a *consumer*."
msgstr ""

#: ../../userguide/routing.rst:320
msgid ""
"The *broker* is the message server, routing messages from producers to "
"consumers."
msgstr ""

#: ../../userguide/routing.rst:323
msgid "You're likely to see these terms used a lot in AMQP related material."
msgstr ""

#: ../../userguide/routing.rst:328
msgid "Exchanges, queues, and routing keys"
msgstr ""

#: ../../userguide/routing.rst:330
msgid "Messages are sent to exchanges."
msgstr ""

#: ../../userguide/routing.rst:331
msgid ""
"An exchange routes messages to one or more queues. Several exchange types"
" exists, providing different ways to do routing, or implementing "
"different messaging scenarios."
msgstr ""

#: ../../userguide/routing.rst:334
msgid "The message waits in the queue until someone consumes it."
msgstr ""

#: ../../userguide/routing.rst:335
msgid "The message is deleted from the queue when it has been acknowledged."
msgstr ""

#: ../../userguide/routing.rst:337
msgid "The steps required to send and receive messages are:"
msgstr ""

#: ../../userguide/routing.rst:339
msgid "Create an exchange"
msgstr ""

#: ../../userguide/routing.rst:340
msgid "Create a queue"
msgstr ""

#: ../../userguide/routing.rst:341
msgid "Bind the queue to the exchange."
msgstr ""

#: ../../userguide/routing.rst:343
msgid ""
"Celery automatically creates the entities necessary for the queues in "
":setting:`task_queues` to work (except if the queue's `auto_declare` "
"setting is set to :const:`False`)."
msgstr ""

#: ../../userguide/routing.rst:347 ../../userguide/routing.rst:568
msgid ""
"Here's an example queue configuration with three queues; One for video, "
"one for images, and one default queue for everything else:"
msgstr ""

#: ../../userguide/routing.rst:366
msgid "Exchange types"
msgstr ""

#: ../../userguide/routing.rst:368
msgid ""
"The exchange type defines how the messages are routed through the "
"exchange. The exchange types defined in the standard are `direct`, "
"`topic`, `fanout` and `headers`. Also non-standard exchange types are "
"available as plug-ins to RabbitMQ, like the `last-value-cache plug-in`_ "
"by Michael Bridgen."
msgstr ""

#: ../../userguide/routing.rst:380
msgid "Direct exchanges"
msgstr ""

#: ../../userguide/routing.rst:382
msgid ""
"Direct exchanges match by exact routing keys, so a queue bound by the "
"routing key `video` only receives messages with that routing key."
msgstr ""

#: ../../userguide/routing.rst:388
msgid "Topic exchanges"
msgstr ""

#: ../../userguide/routing.rst:390
msgid ""
"Topic exchanges matches routing keys using dot-separated words, and the "
"wild-card characters: ``*`` (matches a single word), and ``#`` (matches "
"zero or more words)."
msgstr ""

#: ../../userguide/routing.rst:394
msgid ""
"With routing keys like ``usa.news``, ``usa.weather``, ``norway.news``, "
"and ``norway.weather``, bindings could be ``*.news`` (all news), "
"``usa.#`` (all items in the USA), or ``usa.weather`` (all USA weather "
"items)."
msgstr ""

#: ../../userguide/routing.rst:401
msgid "Related API commands"
msgstr ""

#: ../../userguide/routing.rst:406
msgid "Declares an exchange by name."
msgstr ""

#: ../../userguide/routing.rst:408
msgid ""
"See :meth:`amqp:Channel.exchange_declare "
"<amqp.channel.Channel.exchange_declare>`."
msgstr ""

#: ../../userguide/routing.rst ../../userguide/tasks.rst
msgid "Keyword Arguments"
msgstr ""

#: ../../userguide/routing.rst:410
msgid ""
"Passive means the exchange won't be created, but you can use this to "
"check if the exchange already exists."
msgstr ""

#: ../../userguide/routing.rst:413
msgid "Durable exchanges are persistent (i.e., they survive a broker restart)."
msgstr ""

#: ../../userguide/routing.rst:416
msgid ""
"This means the exchange will be deleted by the broker when there are no "
"more queues using it."
msgstr ""

#: ../../userguide/routing.rst:422
msgid "Declares a queue by name."
msgstr ""

#: ../../userguide/routing.rst:424
msgid ""
"See :meth:`amqp:Channel.queue_declare "
"<amqp.channel.Channel.queue_declare>`"
msgstr ""

#: ../../userguide/routing.rst:426
msgid ""
"Exclusive queues can only be consumed from by the current connection. "
"Exclusive also implies `auto_delete`."
msgstr ""

#: ../../userguide/routing.rst:431
msgid "Binds a queue to an exchange with a routing key."
msgstr ""

#: ../../userguide/routing.rst:433
msgid "Unbound queues won't receive messages, so this is necessary."
msgstr ""

#: ../../userguide/routing.rst:435
msgid "See :meth:`amqp:Channel.queue_bind <amqp.channel.Channel.queue_bind>`"
msgstr ""

#: ../../userguide/routing.rst:439
msgid "Deletes a queue and its binding."
msgstr ""

#: ../../userguide/routing.rst:441
msgid "See :meth:`amqp:Channel.queue_delete <amqp.channel.Channel.queue_delete>`"
msgstr ""

#: ../../userguide/routing.rst:445
msgid "Deletes an exchange."
msgstr ""

#: ../../userguide/routing.rst:447
msgid ""
"See :meth:`amqp:Channel.exchange_delete "
"<amqp.channel.Channel.exchange_delete>`"
msgstr ""

#: ../../userguide/routing.rst:451
msgid ""
"Declaring doesn't necessarily mean \"create\". When you declare you "
"*assert* that the entity exists and that it's operable. There's no rule "
"as to whom should initially create the exchange/queue/binding, whether "
"consumer or producer. Usually the first one to need it will be the one to"
" create it."
msgstr ""

#: ../../userguide/routing.rst:460
msgid "Hands-on with the API"
msgstr ""

#: ../../userguide/routing.rst:462
msgid ""
"Celery comes with a tool called :program:`celery amqp` that's used for "
"command line access to the AMQP API, enabling access to administration "
"tasks like creating/deleting queues and exchanges, purging queues or "
"sending messages. It can also be used for non-AMQP brokers, but different"
" implementation may not implement all commands."
msgstr ""

#: ../../userguide/routing.rst:468
msgid ""
"You can write commands directly in the arguments to :program:`celery "
"amqp`, or just start with no arguments to start it in shell-mode:"
msgstr ""

#: ../../userguide/routing.rst:478
msgid ""
"Here ``1>`` is the prompt. The number 1, is the number of commands you "
"have executed so far. Type ``help`` for a list of commands available. It "
"also supports auto-completion, so you can start typing a command and then"
" hit the `tab` key to show a list of possible matches."
msgstr ""

#: ../../userguide/routing.rst:483
msgid "Let's create a queue you can send messages to:"
msgstr ""

#: ../../userguide/routing.rst:495
msgid ""
"This created the direct exchange ``testexchange``, and a queue named "
"``testqueue``. The queue is bound to the exchange using the routing key "
"``testkey``."
msgstr ""

#: ../../userguide/routing.rst:499
msgid ""
"From now on all messages sent to the exchange ``testexchange`` with "
"routing key ``testkey`` will be moved to this queue. You can send a "
"message by using the ``basic.publish`` command:"
msgstr ""

#: ../../userguide/routing.rst:508
msgid ""
"Now that the message is sent you can retrieve it again. You can use the "
"``basic.get``` command here, that polls for new messages on the queue in "
"a synchronous manner (this is OK for maintenance tasks, but for services "
"you want to use ``basic.consume`` instead)"
msgstr ""

#: ../../userguide/routing.rst:514
msgid "Pop a message off the queue:"
msgstr ""

#: ../../userguide/routing.rst:528
msgid ""
"AMQP uses acknowledgment to signify that a message has been received and "
"processed successfully. If the message hasn't been acknowledged and "
"consumer channel is closed, the message will be delivered to another "
"consumer."
msgstr ""

#: ../../userguide/routing.rst:533
msgid ""
"Note the delivery tag listed in the structure above; Within a connection "
"channel, every received message has a unique delivery tag, This tag is "
"used to acknowledge the message. Also note that delivery tags aren't "
"unique across connections, so in another client the delivery tag `1` "
"might point to a different message than in this channel."
msgstr ""

#: ../../userguide/routing.rst:539
msgid "You can acknowledge the message you received using ``basic.ack``:"
msgstr ""

#: ../../userguide/routing.rst:546
msgid ""
"To clean up after our test session you should delete the entities you "
"created:"
msgstr ""

#: ../../userguide/routing.rst:564
msgid "Defining queues"
msgstr ""

#: ../../userguide/routing.rst:566
msgid ""
"In Celery available queues are defined by the :setting:`task_queues` "
"setting."
msgstr ""

#: ../../userguide/routing.rst:585
msgid ""
"Here, the :setting:`task_default_queue` will be used to route tasks that "
"doesn't have an explicit route."
msgstr ""

#: ../../userguide/routing.rst:588
msgid ""
"The default exchange, exchange type, and routing key will be used as the "
"default routing values for tasks, and as the default values for entries "
"in :setting:`task_queues`."
msgstr ""

#: ../../userguide/routing.rst:592
msgid ""
"Multiple bindings to a single queue are also supported.  Here's an "
"example of two routing keys that are both bound to the same queue:"
msgstr ""

#: ../../userguide/routing.rst:612
msgid "Specifying task destination"
msgstr ""

#: ../../userguide/routing.rst:614
msgid "The destination for a task is decided by the following (in order):"
msgstr ""

#: ../../userguide/routing.rst:616
msgid "The routing arguments to :func:`Task.apply_async`."
msgstr ""

#: ../../userguide/routing.rst:617
msgid ""
"Routing related attributes defined on the :class:`~celery.task.base.Task`"
" itself."
msgstr ""

#: ../../userguide/routing.rst:619
msgid "The :ref:`routers` defined in :setting:`task_routes`."
msgstr ""

#: ../../userguide/routing.rst:621
msgid ""
"It's considered best practice to not hard-code these settings, but rather"
" leave that as configuration options by using :ref:`routers`; This is the"
" most flexible approach, but sensible defaults can still be set as task "
"attributes."
msgstr ""

#: ../../userguide/routing.rst:629
msgid "Routers"
msgstr ""

#: ../../userguide/routing.rst:631
msgid "A router is a function that decides the routing options for a task."
msgstr ""

#: ../../userguide/routing.rst:633
msgid ""
"All you need to define a new router is to define a function with the "
"signature ``(name, args, kwargs, options, task=None, **kw)``:"
msgstr ""

#: ../../userguide/routing.rst:644
msgid ""
"If you return the ``queue`` key, it'll expand with the defined settings "
"of that queue in :setting:`task_queues`:"
msgstr ""

#: ../../userguide/routing.rst:651
msgid "becomes -->"
msgstr ""

#: ../../userguide/routing.rst:661
msgid ""
"You install router classes by adding them to the :setting:`task_routes` "
"setting:"
msgstr ""

#: ../../userguide/routing.rst:668
msgid "Router functions can also be added by name:"
msgstr ""

#: ../../userguide/routing.rst:675
msgid ""
"For simple task name -> route mappings like the router example above, you"
" can simply drop a dict into :setting:`task_routes` to get the same "
"behavior:"
msgstr ""

#: ../../userguide/routing.rst:688
msgid ""
"The routers will then be traversed in order, it will stop at the first "
"router returning a true value, and use that as the final route for the "
"task."
msgstr ""

#: ../../userguide/routing.rst:691
msgid "You can also have multiple routers defined in a sequence:"
msgstr ""

#: ../../userguide/routing.rst:704
msgid ""
"The routers will then be visited in turn, and the first to return a value"
" will be chosen."
msgstr ""

#: ../../userguide/routing.rst:707
msgid ""
"If you\\'re using Redis or RabbitMQ you can also specify the queue\\'s "
"default priority in the route."
msgstr ""

#: ../../userguide/routing.rst:721
msgid ""
"Similarly, calling `apply_async` on a task will override that default "
"priority."
msgstr ""

#: ../../userguide/routing.rst:729
msgid "Priority Order and Cluster Responsiveness"
msgstr ""

#: ../../userguide/routing.rst:731
msgid ""
"It is important to note that, due to worker prefetching, if a bunch of "
"tasks submitted at the same time they may be out of priority order at "
"first. Disabling worker prefetching will prevent this issue, but may "
"cause less than ideal performance for small, fast tasks. In most cases, "
"simply reducing `worker_prefetch_multiplier` to 1 is an easier and "
"cleaner way to increase the responsiveness of your system without the "
"costs of disabling prefetching entirely."
msgstr ""

#: ../../userguide/routing.rst:739
msgid ""
"Note that priorities values are sorted in reverse: 0 being highest "
"priority."
msgstr ""

#: ../../userguide/routing.rst:743
msgid "Broadcast"
msgstr ""

#: ../../userguide/routing.rst:745
msgid ""
"Celery can also support broadcast routing. Here is an example exchange "
"``broadcast_tasks`` that delivers copies of tasks to all workers "
"connected to it:"
msgstr ""

#: ../../userguide/routing.rst:761
msgid ""
"Now the ``tasks.reload_cache`` task will be sent to every worker "
"consuming from this queue."
msgstr ""

#: ../../userguide/routing.rst:764
msgid ""
"Here is another example of broadcast routing, this time with a "
":program:`celery beat` schedule:"
msgstr ""

#: ../../userguide/routing.rst:783
msgid "Broadcast & Results"
msgstr ""

#: ../../userguide/routing.rst:785
msgid ""
"Note that Celery result doesn't define what happens if two tasks have the"
" same task_id. If the same task is distributed to more than one worker, "
"then the state history may not be preserved."
msgstr ""

#: ../../userguide/routing.rst:789
msgid "It's a good idea to set the ``task.ignore_result`` attribute in this case."
msgstr ""

#: ../../userguide/security.rst:13
msgid ""
"While Celery is written with security in mind, it should be treated as an"
" unsafe component."
msgstr ""

#: ../../userguide/security.rst:16
msgid ""
"Depending on your `Security Policy`_, there are various steps you can "
"take to make your Celery installation more secure."
msgstr ""

#: ../../userguide/security.rst:24
msgid "Areas of Concern"
msgstr ""

#: ../../userguide/security.rst:27
msgid "Broker"
msgstr ""

#: ../../userguide/security.rst:29
msgid ""
"It's imperative that the broker is guarded from unwanted access, "
"especially if accessible to the public. By default, workers trust that "
"the data they get from the broker hasn't been tampered with. See `Message"
" Signing`_ for information on how to make the broker connection more "
"trustworthy."
msgstr ""

#: ../../userguide/security.rst:35
msgid ""
"The first line of defense should be to put a firewall in front of the "
"broker, allowing only white-listed machines to access it."
msgstr ""

#: ../../userguide/security.rst:38
msgid ""
"Keep in mind that both firewall misconfiguration, and temporarily "
"disabling the firewall, is common in the real world. Solid security "
"policy includes monitoring of firewall equipment to detect if they've "
"been disabled, be it accidentally or on purpose."
msgstr ""

#: ../../userguide/security.rst:43
msgid "In other words, one shouldn't blindly trust the firewall either."
msgstr ""

#: ../../userguide/security.rst:45
msgid ""
"If your broker supports fine-grained access control, like RabbitMQ, this "
"is something you should look at enabling. See for example "
"http://www.rabbitmq.com/access-control.html."
msgstr ""

#: ../../userguide/security.rst:49
msgid ""
"If supported by your broker backend, you can enable end-to-end SSL "
"encryption and authentication using :setting:`broker_use_ssl`."
msgstr ""

#: ../../userguide/security.rst:53
msgid "Client"
msgstr ""

#: ../../userguide/security.rst:55
msgid ""
"In Celery, \"client\" refers to anything that sends messages to the "
"broker, for example web-servers that apply tasks."
msgstr ""

#: ../../userguide/security.rst:58
msgid ""
"Having the broker properly secured doesn't matter if arbitrary messages "
"can be sent through a client."
msgstr ""

#: ../../userguide/security.rst:61
msgid "*[Need more text here]*"
msgstr ""

#: ../../userguide/security.rst:66
msgid ""
"The default permissions of tasks running inside a worker are the same "
"ones as the privileges of the worker itself. This applies to resources, "
"such as; memory, file-systems, and devices."
msgstr ""

#: ../../userguide/security.rst:70
msgid ""
"An exception to this rule is when using the multiprocessing based task "
"pool, which is currently the default. In this case, the task will have "
"access to any memory copied as a result of the :func:`fork` call, and "
"access to memory contents written by parent tasks in the same worker "
"child process."
msgstr ""

#: ../../userguide/security.rst:76
msgid ""
"Limiting access to memory contents can be done by launching every task in"
" a subprocess (:func:`fork` + :func:`execve`)."
msgstr ""

#: ../../userguide/security.rst:79
msgid ""
"Limiting file-system and device access can be accomplished by using "
"`chroot`_, `jail`_, `sandboxing`_, virtual machines, or other mechanisms "
"as enabled by the platform or additional software."
msgstr ""

#: ../../userguide/security.rst:83
msgid ""
"Note also that any task executed in the worker will have the same network"
" access as the machine on which it's running. If the worker is located on"
" an internal network it's recommended to add firewall rules for outbound "
"traffic."
msgstr ""

#: ../../userguide/security.rst:98
msgid ""
"The default serializer is JSON since version 4.0, but since it has only "
"support for a restricted set of types you may want to consider using "
"pickle for serialization instead."
msgstr ""

#: ../../userguide/security.rst:102
msgid ""
"The `pickle` serializer is convenient as it can serialize almost any "
"Python object, even functions with some work, but for the same reasons "
"`pickle` is inherently insecure [*]_, and should be avoided whenever "
"clients are untrusted or unauthenticated."
msgstr ""

#: ../../userguide/security.rst:108
msgid ""
"You can disable untrusted content by specifying a white-list of accepted "
"content-types in the :setting:`accept_content` setting:"
msgstr ""

#: ../../userguide/security.rst:116
msgid ""
"This setting was first supported in version 3.0.18. If you're running an "
"earlier version it will simply be ignored, so make sure you're running a "
"version that supports it."
msgstr ""

#: ../../userguide/security.rst:125
msgid ""
"This accepts a list of serializer names and content-types, so you could "
"also specify the content type for json:"
msgstr ""

#: ../../userguide/security.rst:132
msgid ""
"Celery also comes with a special `auth` serializer that validates "
"communication between Celery clients and workers, making sure that "
"messages originates from trusted sources. Using `Public-key cryptography`"
" the `auth` serializer can verify the authenticity of senders, to enable "
"this read :ref:`message-signing` for more information."
msgstr ""

#: ../../userguide/security.rst:145
msgid "Message Signing"
msgstr ""

#: ../../userguide/security.rst:147
msgid ""
"Celery can use the :pypi:`cryptography` library to sign message using "
"`Public-key cryptography`, where messages sent by clients are signed "
"using a private key and then later verified by the worker using a public "
"certificate."
msgstr ""

#: ../../userguide/security.rst:152
msgid ""
"Optimally certificates should be signed by an official `Certificate "
"Authority`_, but they can also be self-signed."
msgstr ""

#: ../../userguide/security.rst:155
msgid ""
"To enable this you should configure the :setting:`task_serializer` "
"setting to use the `auth` serializer. Enforcing the workers to only "
"accept signed messages, you should set `accept_content` to `['auth']`. "
"For additional signing of the event protocol, set `event_serializer` to "
"`auth`. Also required is configuring the paths used to locate private "
"keys and certificates on the file-system: the :setting:`security_key`, "
":setting:`security_certificate`, and :setting:`security_cert_store` "
"settings respectively. You can tweak the signing algorithm with "
":setting:`security_digest`."
msgstr ""

#: ../../userguide/security.rst:166
msgid ""
"With these configured it's also necessary to call the "
":func:`celery.setup_security` function. Note that this will also disable "
"all insecure serializers so that the worker won't accept messages with "
"untrusted content types."
msgstr ""

#: ../../userguide/security.rst:171
msgid ""
"This is an example configuration using the `auth` serializer, with the "
"private key and certificate files located in `/etc/ssl`."
msgstr ""

#: ../../userguide/security.rst:190
msgid ""
"While relative paths aren't disallowed, using absolute paths is "
"recommended for these files."
msgstr ""

#: ../../userguide/security.rst:193
msgid ""
"Also note that the `auth` serializer won't encrypt the contents of a "
"message, so if needed this will have to be enabled separately."
msgstr ""

#: ../../userguide/security.rst:201
msgid "Intrusion Detection"
msgstr ""

#: ../../userguide/security.rst:203
msgid ""
"The most important part when defending your systems against intruders is "
"being able to detect if the system has been compromised."
msgstr ""

#: ../../userguide/security.rst:207
msgid "Logs"
msgstr ""

#: ../../userguide/security.rst:209
msgid ""
"Logs are usually the first place to look for evidence of security "
"breaches, but they're useless if they can be tampered with."
msgstr ""

#: ../../userguide/security.rst:212
msgid ""
"A good solution is to set up centralized logging with a dedicated logging"
" server. Access to it should be restricted. In addition to having all of "
"the logs in a single place, if configured correctly, it can make it "
"harder for intruders to tamper with your logs."
msgstr ""

#: ../../userguide/security.rst:217
msgid ""
"This should be fairly easy to setup using syslog (see also `syslog-ng`_ "
"and `rsyslog`_). Celery uses the :mod:`logging` library, and already has "
"support for using syslog."
msgstr ""

#: ../../userguide/security.rst:221
msgid ""
"A tip for the paranoid is to send logs using UDP and cut the transmit "
"part of the logging server's network cable :-)"
msgstr ""

#: ../../userguide/security.rst:228
msgid "Tripwire"
msgstr ""

#: ../../userguide/security.rst:230
msgid ""
"`Tripwire`_ is a (now commercial) data integrity tool, with several open "
"source implementations, used to keep cryptographic hashes of files in the"
" file-system, so that administrators can be alerted when they change. "
"This way when the damage is done and your system has been compromised you"
" can tell exactly what files intruders have changed  (password files, "
"logs, back-doors, root-kits, and so on). Often this is the only way "
"you'll be able to detect an intrusion."
msgstr ""

#: ../../userguide/security.rst:238
msgid "Some open source implementations include:"
msgstr ""

#: ../../userguide/security.rst:240
msgid "`OSSEC`_"
msgstr ""

#: ../../userguide/security.rst:241
msgid "`Samhain`_"
msgstr ""

#: ../../userguide/security.rst:242
msgid "`Open Source Tripwire`_"
msgstr ""

#: ../../userguide/security.rst:243
msgid "`AIDE`_"
msgstr ""

#: ../../userguide/security.rst:245
msgid ""
"Also, the `ZFS`_ file-system comes with built-in integrity checks that "
"can be used."
msgstr ""

#: ../../userguide/security.rst:257
msgid "https://blog.nelhage.com/2011/03/exploiting-pickle/"
msgstr ""

#: ../../userguide/signals.rst:5 ../../userguide/signals.rst:69
msgid "Signals"
msgstr ""

#: ../../userguide/signals.rst:10
msgid ""
"Signals allow decoupled applications to receive notifications when "
"certain actions occur elsewhere in the application."
msgstr ""

#: ../../userguide/signals.rst:13
msgid ""
"Celery ships with many signals that your application can hook into to "
"augment behavior of certain actions."
msgstr ""

#: ../../userguide/signals.rst:21
msgid ""
"Several kinds of events trigger signals, you can connect to these signals"
" to perform actions as they trigger."
msgstr ""

#: ../../userguide/signals.rst:24
msgid "Example connecting to the :signal:`after_task_publish` signal:"
msgstr ""

#: ../../userguide/signals.rst:40
msgid ""
"Some signals also have a sender you can filter by. For example the "
":signal:`after_task_publish` signal uses the task name as a sender, so by"
" providing the ``sender`` argument to "
":class:`~celery.utils.dispatch.signal.Signal.connect` you can connect "
"your handler to be called every time a task with name "
"`\"proj.tasks.add\"` is published:"
msgstr ""

#: ../../userguide/signals.rst:58
msgid ""
"Signals use the same implementation as :mod:`django.core.dispatch`. As a "
"result other keyword parameters (e.g., signal) are passed to all signal "
"handlers by default."
msgstr ""

#: ../../userguide/signals.rst:62
msgid ""
"The best practice for signal handlers is to accept arbitrary keyword "
"arguments (i.e., ``**kwargs``). That way new Celery versions can add "
"additional arguments without breaking user code."
msgstr ""

#: ../../userguide/signals.rst:72
msgid "Task Signals"
msgstr ""

#: ../../userguide/signals.rst:77
msgid "``before_task_publish``"
msgstr ""

#: ../../userguide/signals.rst:80
msgid ""
"Dispatched before a task is published. Note that this is executed in the "
"process sending the task."
msgstr ""

#: ../../userguide/signals.rst:83 ../../userguide/signals.rst:131
msgid "Sender is the name of the task being sent."
msgstr ""

#: ../../userguide/signals.rst:85 ../../userguide/signals.rst:133
#: ../../userguide/signals.rst:164 ../../userguide/signals.rst:191
#: ../../userguide/signals.rst:226 ../../userguide/signals.rst:266
#: ../../userguide/signals.rst:301 ../../userguide/signals.rst:320
#: ../../userguide/signals.rst:352 ../../userguide/signals.rst:380
#: ../../userguide/signals.rst:430 ../../userguide/signals.rst:477
#: ../../userguide/signals.rst:528 ../../userguide/signals.rst:565
#: ../../userguide/signals.rst:644 ../../userguide/signals.rst:674
#: ../../userguide/signals.rst:700 ../../userguide/signals.rst:730
#: ../../userguide/signals.rst:788
msgid "Provides arguments:"
msgstr ""

#: ../../userguide/signals.rst:87 ../../userguide/signals.rst:141
msgid "``body``"
msgstr ""

#: ../../userguide/signals.rst:89
msgid "Task message body."
msgstr ""

#: ../../userguide/signals.rst:91
msgid ""
"This is a mapping containing the task message fields, see :ref:`message-"
"protocol-task-v2` and :ref:`message-protocol-task-v1` for a reference of "
"possible fields that can be defined."
msgstr ""

#: ../../userguide/signals.rst:96 ../../userguide/signals.rst:147
msgid "``exchange``"
msgstr ""

#: ../../userguide/signals.rst:98
msgid "Name of the exchange to send to or a :class:`~kombu.Exchange` object."
msgstr ""

#: ../../userguide/signals.rst:100 ../../userguide/signals.rst:151
msgid "``routing_key``"
msgstr ""

#: ../../userguide/signals.rst:102
msgid "Routing key to use when sending the message."
msgstr ""

#: ../../userguide/signals.rst:104 ../../userguide/signals.rst:135
msgid "``headers``"
msgstr ""

#: ../../userguide/signals.rst:106
msgid "Application headers mapping (can be modified)."
msgstr ""

#: ../../userguide/signals.rst:108
msgid "``properties``"
msgstr ""

#: ../../userguide/signals.rst:110
msgid "Message properties (can be modified)"
msgstr ""

#: ../../userguide/signals.rst:112
msgid "``declare``"
msgstr ""

#: ../../userguide/signals.rst:114
msgid ""
"List of entities (:class:`~kombu.Exchange`, :class:`~kombu.Queue`, or "
":class:`~kombu.binding` to declare before publishing the message. Can be "
"modified."
msgstr ""

#: ../../userguide/signals.rst:118
msgid "``retry_policy``"
msgstr ""

#: ../../userguide/signals.rst:120
msgid ""
"Mapping of retry options. Can be any argument to "
":meth:`kombu.Connection.ensure` and can be modified."
msgstr ""

#: ../../userguide/signals.rst:126
msgid "``after_task_publish``"
msgstr ""

#: ../../userguide/signals.rst:128
msgid ""
"Dispatched when a task has been sent to the broker. Note that this is "
"executed in the process that sent the task."
msgstr ""

#: ../../userguide/signals.rst:137
msgid ""
"The task message headers, see :ref:`message-protocol-task-v2` and :ref"
":`message-protocol-task-v1` for a reference of possible fields that can "
"be defined."
msgstr ""

#: ../../userguide/signals.rst:143
msgid ""
"The task message body, see :ref:`message-protocol-task-v2` and :ref"
":`message-protocol-task-v1` for a reference of possible fields that can "
"be defined."
msgstr ""

#: ../../userguide/signals.rst:149
msgid "Name of the exchange or :class:`~kombu.Exchange` object used."
msgstr ""

#: ../../userguide/signals.rst:153
msgid "Routing key used."
msgstr ""

#: ../../userguide/signals.rst:158
msgid "``task_prerun``"
msgstr ""

#: ../../userguide/signals.rst:160
msgid "Dispatched before a task is executed."
msgstr ""

#: ../../userguide/signals.rst:162
msgid "Sender is the task object being executed."
msgstr ""

#: ../../userguide/signals.rst:166 ../../userguide/signals.rst:193
#: ../../userguide/signals.rst:268
msgid "``task_id``"
msgstr ""

#: ../../userguide/signals.rst:168 ../../userguide/signals.rst:195
msgid "Id of the task to be executed."
msgstr ""

#: ../../userguide/signals.rst:170 ../../userguide/signals.rst:197
msgid "``task``"
msgstr ""

#: ../../userguide/signals.rst:172 ../../userguide/signals.rst:199
msgid "The task being executed."
msgstr ""

#: ../../userguide/signals.rst:174 ../../userguide/signals.rst:201
#: ../../userguide/signals.rst:276 ../../userguide/signals.rst:650
msgid "``args``"
msgstr ""

#: ../../userguide/signals.rst:176 ../../userguide/signals.rst:203
msgid "The tasks positional arguments."
msgstr ""

#: ../../userguide/signals.rst:178 ../../userguide/signals.rst:205
#: ../../userguide/signals.rst:280 ../../userguide/signals.rst:654
msgid "``kwargs``"
msgstr ""

#: ../../userguide/signals.rst:180 ../../userguide/signals.rst:207
msgid "The tasks keyword arguments."
msgstr ""

#: ../../userguide/signals.rst:185
msgid "``task_postrun``"
msgstr ""

#: ../../userguide/signals.rst:187
msgid "Dispatched after a task has been executed."
msgstr ""

#: ../../userguide/signals.rst:189 ../../userguide/signals.rst:250
#: ../../userguide/signals.rst:264
msgid "Sender is the task object executed."
msgstr ""

#: ../../userguide/signals.rst:209
msgid "``retval``"
msgstr ""

#: ../../userguide/signals.rst:211 ../../userguide/tasks.rst:1525
msgid "The return value of the task."
msgstr ""

#: ../../userguide/signals.rst:213
msgid "``state``"
msgstr ""

#: ../../userguide/signals.rst:215
msgid "Name of the resulting state."
msgstr ""

#: ../../userguide/signals.rst:220
msgid "``task_retry``"
msgstr ""

#: ../../userguide/signals.rst:222
msgid "Dispatched when a task will be retried."
msgstr ""

#: ../../userguide/signals.rst:224
msgid "Sender is the task object."
msgstr ""

#: ../../userguide/signals.rst:228 ../../userguide/signals.rst:303
#: ../../userguide/signals.rst:322
msgid "``request``"
msgstr ""

#: ../../userguide/signals.rst:230
msgid "The current task request."
msgstr ""

#: ../../userguide/signals.rst:232
msgid "``reason``"
msgstr ""

#: ../../userguide/signals.rst:234
msgid ""
"Reason for retry (usually an exception instance, but can always be "
"coerced to :class:`str`)."
msgstr ""

#: ../../userguide/signals.rst:237 ../../userguide/signals.rst:288
msgid "``einfo``"
msgstr ""

#: ../../userguide/signals.rst:239
msgid ""
"Detailed exception information, including traceback (a "
":class:`billiard.einfo.ExceptionInfo` object)."
msgstr ""

#: ../../userguide/signals.rst:246
msgid "``task_success``"
msgstr ""

#: ../../userguide/signals.rst:248
msgid "Dispatched when a task succeeds."
msgstr ""

#: ../../userguide/signals.rst:252
msgid "Provides arguments"
msgstr ""

#: ../../userguide/signals.rst:255
msgid "``result``"
msgstr ""

#: ../../userguide/signals.rst:255
msgid "Return value of the task."
msgstr ""

#: ../../userguide/signals.rst:260
msgid "``task_failure``"
msgstr ""

#: ../../userguide/signals.rst:262
msgid "Dispatched when a task fails."
msgstr ""

#: ../../userguide/signals.rst:270
msgid "Id of the task."
msgstr ""

#: ../../userguide/signals.rst:272
msgid "``exception``"
msgstr ""

#: ../../userguide/signals.rst:274
msgid "Exception instance raised."
msgstr ""

#: ../../userguide/signals.rst:278
msgid "Positional arguments the task was called with."
msgstr ""

#: ../../userguide/signals.rst:282
msgid "Keyword arguments the task was called with."
msgstr ""

#: ../../userguide/signals.rst:284
msgid "``traceback``"
msgstr ""

#: ../../userguide/signals.rst:286
msgid "Stack trace object."
msgstr ""

#: ../../userguide/signals.rst:290
msgid "The :class:`billiard.einfo.ExceptionInfo` instance."
msgstr ""

#: ../../userguide/signals.rst:295
msgid "``task_received``"
msgstr ""

#: ../../userguide/signals.rst:297
msgid ""
"Dispatched when a task is received from the broker and is ready for "
"execution."
msgstr ""

#: ../../userguide/signals.rst:299
msgid "Sender is the consumer object."
msgstr ""

#: ../../userguide/signals.rst:305 ../../userguide/signals.rst:324
msgid ""
"This is a :class:`~celery.worker.request.Request` instance, and not "
"``task.request``. When using the prefork pool this signal is dispatched "
"in the parent process, so ``task.request`` isn't available and shouldn't "
"be used. Use this object instead, as they share many of the same fields."
msgstr ""

#: ../../userguide/signals.rst:314
msgid "``task_revoked``"
msgstr ""

#: ../../userguide/signals.rst:316
msgid "Dispatched when a task is revoked/terminated by the worker."
msgstr ""

#: ../../userguide/signals.rst:318
msgid "Sender is the task object revoked/terminated."
msgstr ""

#: ../../userguide/signals.rst:330
msgid "``terminated``"
msgstr ""

#: ../../userguide/signals.rst:332
msgid "Set to :const:`True` if the task was terminated."
msgstr ""

#: ../../userguide/signals.rst:334
msgid "``signum``"
msgstr ""

#: ../../userguide/signals.rst:336
msgid ""
"Signal number used to terminate the task. If this is :const:`None` and "
"terminated is :const:`True` then :sig:`TERM` should be assumed."
msgstr ""

#: ../../userguide/signals.rst:339
msgid "``expired``"
msgstr ""

#: ../../userguide/signals.rst:341
msgid "Set to :const:`True` if the task expired."
msgstr ""

#: ../../userguide/signals.rst:346
msgid "``task_unknown``"
msgstr ""

#: ../../userguide/signals.rst:348
msgid ""
"Dispatched when a worker receives a message for a task that's not "
"registered."
msgstr ""

#: ../../userguide/signals.rst:350 ../../userguide/signals.rst:378
msgid "Sender is the worker :class:`~celery.worker.consumer.Consumer`."
msgstr ""

#: ../../userguide/signals.rst:354
msgid "``name``"
msgstr ""

#: ../../userguide/signals.rst:356
msgid "Name of task not found in registry."
msgstr ""

#: ../../userguide/signals.rst:358
msgid "``id``"
msgstr ""

#: ../../userguide/signals.rst:360
msgid "The task id found in the message."
msgstr ""

#: ../../userguide/signals.rst:362 ../../userguide/signals.rst:382
msgid "``message``"
msgstr ""

#: ../../userguide/signals.rst:364 ../../userguide/signals.rst:384
msgid "Raw message object."
msgstr ""

#: ../../userguide/signals.rst:366 ../../userguide/signals.rst:386
msgid "``exc``"
msgstr ""

#: ../../userguide/signals.rst:368
msgid "The error that occurred."
msgstr ""

#: ../../userguide/signals.rst:373
msgid "``task_rejected``"
msgstr ""

#: ../../userguide/signals.rst:375
msgid ""
"Dispatched when a worker receives an unknown type of message to one of "
"its task queues."
msgstr ""

#: ../../userguide/signals.rst:388
msgid "The error that occurred (if any)."
msgstr ""

#: ../../userguide/signals.rst:391
msgid "App Signals"
msgstr ""

#: ../../userguide/signals.rst:396
msgid "``import_modules``"
msgstr ""

#: ../../userguide/signals.rst:398
msgid ""
"This signal is sent when a program (worker, beat, shell) etc, asks for "
"modules in the :setting:`include` and :setting:`imports` settings to be "
"imported."
msgstr ""

#: ../../userguide/signals.rst:402
msgid "Sender is the app instance."
msgstr ""

#: ../../userguide/signals.rst:405
msgid "Worker Signals"
msgstr ""

#: ../../userguide/signals.rst:410
msgid "``celeryd_after_setup``"
msgstr ""

#: ../../userguide/signals.rst:412
msgid ""
"This signal is sent after the worker instance is set up, but before it "
"calls run. This means that any queues from the :option:`celery worker -Q`"
" option is enabled, logging has been set up and so on."
msgstr ""

#: ../../userguide/signals.rst:416
msgid ""
"It can be used to add custom queues that should always be consumed from, "
"disregarding the :option:`celery worker -Q` option. Here's an example "
"that sets up a direct queue for each worker, these queues can then be "
"used to route a task to any specific worker:"
msgstr ""

#: ../../userguide/signals.rst:432 ../../userguide/signals.rst:479
msgid "``sender``"
msgstr ""

#: ../../userguide/signals.rst:434
msgid "Node name of the worker."
msgstr ""

#: ../../userguide/signals.rst:436 ../../userguide/signals.rst:483
msgid "``instance``"
msgstr ""

#: ../../userguide/signals.rst:438 ../../userguide/signals.rst:485
msgid ""
"This is the :class:`celery.apps.worker.Worker` instance to be "
"initialized. Note that only the :attr:`app` and :attr:`hostname` "
"(nodename) attributes have been set so far, and the rest of ``__init__`` "
"hasn't been executed."
msgstr ""

#: ../../userguide/signals.rst:442 ../../userguide/signals.rst:489
msgid "``conf``"
msgstr ""

#: ../../userguide/signals.rst:444 ../../userguide/signals.rst:491
msgid "The configuration of the current app."
msgstr ""

#: ../../userguide/signals.rst:449
msgid "``celeryd_init``"
msgstr ""

#: ../../userguide/signals.rst:451
msgid ""
"This is the first signal sent when :program:`celery worker` starts up. "
"The ``sender`` is the host name of the worker, so this signal can be used"
" to setup worker specific configuration:"
msgstr ""

#: ../../userguide/signals.rst:463
msgid ""
"or to set up configuration for multiple workers you can omit specifying a"
" sender when you connect:"
msgstr ""

#: ../../userguide/signals.rst:481
msgid "Nodename of the worker."
msgstr ""

#: ../../userguide/signals.rst:493 ../../userguide/signals.rst:794
msgid "``options``"
msgstr ""

#: ../../userguide/signals.rst:495
msgid ""
"Options passed to the worker from command-line arguments (including "
"defaults)."
msgstr ""

#: ../../userguide/signals.rst:501
msgid "``worker_init``"
msgstr ""

#: ../../userguide/signals.rst:503
msgid "Dispatched before the worker is started."
msgstr ""

#: ../../userguide/signals.rst:508
msgid "``worker_ready``"
msgstr ""

#: ../../userguide/signals.rst:510
msgid "Dispatched when the worker is ready to accept work."
msgstr ""

#: ../../userguide/signals.rst:515
msgid "``heartbeat_sent``"
msgstr ""

#: ../../userguide/signals.rst:517
msgid "Dispatched when Celery sends a worker heartbeat."
msgstr ""

#: ../../userguide/signals.rst:519
msgid "Sender is the :class:`celery.worker.heartbeat.Heart` instance."
msgstr ""

#: ../../userguide/signals.rst:524
msgid "``worker_shutting_down``"
msgstr ""

#: ../../userguide/signals.rst:526
msgid "Dispatched when the worker begins the shutdown process."
msgstr ""

#: ../../userguide/signals.rst:530
msgid "``sig``"
msgstr ""

#: ../../userguide/signals.rst:532
msgid "The POSIX signal that was received."
msgstr ""

#: ../../userguide/signals.rst:534
msgid "``how``"
msgstr ""

#: ../../userguide/signals.rst:536
msgid "The shutdown method, warm or cold."
msgstr ""

#: ../../userguide/signals.rst:538 ../../userguide/signals.rst:571
msgid "``exitcode``"
msgstr ""

#: ../../userguide/signals.rst:540
msgid "The exitcode that will be used when the main process exits."
msgstr ""

#: ../../userguide/signals.rst:545
msgid "``worker_process_init``"
msgstr ""

#: ../../userguide/signals.rst:547
msgid "Dispatched in all pool child processes when they start."
msgstr ""

#: ../../userguide/signals.rst:549
msgid ""
"Note that handlers attached to this signal mustn't be blocking for more "
"than 4 seconds, or the process will be killed assuming it failed to "
"start."
msgstr ""

#: ../../userguide/signals.rst:556
msgid "``worker_process_shutdown``"
msgstr ""

#: ../../userguide/signals.rst:558
msgid "Dispatched in all pool child processes just before they exit."
msgstr ""

#: ../../userguide/signals.rst:560
msgid ""
"Note: There's no guarantee that this signal will be dispatched, similarly"
" to :keyword:`finally` blocks it's impossible to guarantee that handlers "
"will be called at shutdown, and if called it may be interrupted during."
msgstr ""

#: ../../userguide/signals.rst:567 ../../userguide/workers.rst:927
msgid "``pid``"
msgstr ""

#: ../../userguide/signals.rst:569
msgid "The pid of the child process that's about to shutdown."
msgstr ""

#: ../../userguide/signals.rst:573
msgid "The exitcode that'll be used when the child process exits."
msgstr ""

#: ../../userguide/signals.rst:578
msgid "``worker_shutdown``"
msgstr ""

#: ../../userguide/signals.rst:580
msgid "Dispatched when the worker is about to shut down."
msgstr ""

#: ../../userguide/signals.rst:583
msgid "Beat Signals"
msgstr ""

#: ../../userguide/signals.rst:588
msgid "``beat_init``"
msgstr ""

#: ../../userguide/signals.rst:590
msgid ""
"Dispatched when :program:`celery beat` starts (either standalone or "
"embedded)."
msgstr ""

#: ../../userguide/signals.rst:592 ../../userguide/signals.rst:602
msgid "Sender is the :class:`celery.beat.Service` instance."
msgstr ""

#: ../../userguide/signals.rst:597
msgid "``beat_embedded_init``"
msgstr ""

#: ../../userguide/signals.rst:599
msgid ""
"Dispatched in addition to the :signal:`beat_init` signal when "
":program:`celery beat` is started as an embedded process."
msgstr ""

#: ../../userguide/signals.rst:605
msgid "Eventlet Signals"
msgstr ""

#: ../../userguide/signals.rst:610
msgid "``eventlet_pool_started``"
msgstr ""

#: ../../userguide/signals.rst:612
msgid "Sent when the eventlet pool has been started."
msgstr ""

#: ../../userguide/signals.rst:614 ../../userguide/signals.rst:624
#: ../../userguide/signals.rst:633 ../../userguide/signals.rst:642
msgid "Sender is the :class:`celery.concurrency.eventlet.TaskPool` instance."
msgstr ""

#: ../../userguide/signals.rst:619
msgid "``eventlet_pool_preshutdown``"
msgstr ""

#: ../../userguide/signals.rst:621
msgid ""
"Sent when the worker shutdown, just before the eventlet pool is requested"
" to wait for remaining workers."
msgstr ""

#: ../../userguide/signals.rst:629
msgid "``eventlet_pool_postshutdown``"
msgstr ""

#: ../../userguide/signals.rst:631
msgid "Sent when the pool has been joined and the worker is ready to shutdown."
msgstr ""

#: ../../userguide/signals.rst:638
msgid "``eventlet_pool_apply``"
msgstr ""

#: ../../userguide/signals.rst:640
msgid "Sent whenever a task is applied to the pool."
msgstr ""

#: ../../userguide/signals.rst:646
msgid "``target``"
msgstr ""

#: ../../userguide/signals.rst:648
msgid "The target function."
msgstr ""

#: ../../userguide/signals.rst:652 ../../userguide/tasks.rst:393
msgid "Positional arguments."
msgstr ""

#: ../../userguide/signals.rst:656 ../../userguide/tasks.rst:395
msgid "Keyword arguments."
msgstr ""

#: ../../userguide/signals.rst:659
msgid "Logging Signals"
msgstr ""

#: ../../userguide/signals.rst:664
msgid "``setup_logging``"
msgstr ""

#: ../../userguide/signals.rst:666
msgid ""
"Celery won't configure the loggers if this signal is connected, so you "
"can use this to completely override the logging configuration with your "
"own."
msgstr ""

#: ../../userguide/signals.rst:670
msgid ""
"If you'd like to augment the logging configuration setup by Celery then "
"you can use the :signal:`after_setup_logger` and "
":signal:`after_setup_task_logger` signals."
msgstr ""

#: ../../userguide/signals.rst:676 ../../userguide/signals.rst:706
#: ../../userguide/signals.rst:736
msgid "``loglevel``"
msgstr ""

#: ../../userguide/signals.rst:678 ../../userguide/signals.rst:708
#: ../../userguide/signals.rst:738
msgid "The level of the logging object."
msgstr ""

#: ../../userguide/signals.rst:680 ../../userguide/signals.rst:710
#: ../../userguide/signals.rst:740
msgid "``logfile``"
msgstr ""

#: ../../userguide/signals.rst:682 ../../userguide/signals.rst:712
#: ../../userguide/signals.rst:742
msgid "The name of the logfile."
msgstr ""

#: ../../userguide/signals.rst:684 ../../userguide/signals.rst:714
#: ../../userguide/signals.rst:744
msgid "``format``"
msgstr ""

#: ../../userguide/signals.rst:686 ../../userguide/signals.rst:716
#: ../../userguide/signals.rst:746
msgid "The log format string."
msgstr ""

#: ../../userguide/signals.rst:688 ../../userguide/signals.rst:718
#: ../../userguide/signals.rst:748
msgid "``colorize``"
msgstr ""

#: ../../userguide/signals.rst:690 ../../userguide/signals.rst:720
#: ../../userguide/signals.rst:750
msgid "Specify if log messages are colored or not."
msgstr ""

#: ../../userguide/signals.rst:695
msgid "``after_setup_logger``"
msgstr ""

#: ../../userguide/signals.rst:697
msgid ""
"Sent after the setup of every global logger (not task loggers). Used to "
"augment logging configuration."
msgstr ""

#: ../../userguide/signals.rst:702 ../../userguide/signals.rst:732
msgid "``logger``"
msgstr ""

#: ../../userguide/signals.rst:704 ../../userguide/signals.rst:734
msgid "The logger object."
msgstr ""

#: ../../userguide/signals.rst:725
msgid "``after_setup_task_logger``"
msgstr ""

#: ../../userguide/signals.rst:727
msgid ""
"Sent after the setup of every single task logger. Used to augment logging"
" configuration."
msgstr ""

#: ../../userguide/signals.rst:753
msgid "Command signals"
msgstr ""

#: ../../userguide/signals.rst:758
msgid "``user_preload_options``"
msgstr ""

#: ../../userguide/signals.rst:760
msgid ""
"This signal is sent after any of the Celery command line programs are "
"finished parsing the user preload options."
msgstr ""

#: ../../userguide/signals.rst:763
msgid ""
"It can be used to add additional command-line arguments to the "
":program:`celery` umbrella command:"
msgstr ""

#: ../../userguide/signals.rst:784
msgid ""
"Sender is the :class:`~celery.bin.base.Command` instance, and the value "
"depends on the program that was called (e.g., for the umbrella command "
"it'll be a :class:`~celery.bin.celery.CeleryCommand`) object)."
msgstr ""

#: ../../userguide/signals.rst:790
msgid "``app``"
msgstr ""

#: ../../userguide/signals.rst:792
msgid "The app instance."
msgstr ""

#: ../../userguide/signals.rst:796
msgid "Mapping of the parsed user preload options (with default values)."
msgstr ""

#: ../../userguide/signals.rst:799
msgid "Deprecated Signals"
msgstr ""

#: ../../userguide/signals.rst:804
msgid "``task_sent``"
msgstr ""

#: ../../userguide/signals.rst:806
msgid ""
"This signal is deprecated, please use :signal:`after_task_publish` "
"instead."
msgstr ""

#: ../../userguide/sphinx.rst:5
msgid "Documenting Tasks with Sphinx"
msgstr ""

#: ../../userguide/sphinx.rst:7
msgid ""
"This document describes how auto-generate documentation for Tasks using "
"Sphinx."
msgstr ""

#: ../../userguide/sphinx.rst:12
msgid "celery.contrib.sphinx"
msgstr ""

#: celery.contrib.sphinx:1 of
msgid "Sphinx documentation plugin used to document tasks."
msgstr ""

#: celery.contrib.sphinx:9 of
msgid "Add the extension to your :file:`docs/conf.py` configuration module:"
msgstr ""

#: celery.contrib.sphinx:16 of
msgid ""
"If you'd like to change the prefix for tasks in reference documentation "
"then you can change the ``celery_task_prefix`` configuration value:"
msgstr ""

#: celery.contrib.sphinx:23 of
msgid ""
"With the extension installed `autodoc` will automatically find task "
"decorated objects (e.g. when using the automodule directive) and generate"
" the correct (as well as add a ``(task)`` prefix), and you can also refer"
" to the tasks using `:task:proj.tasks.add` syntax."
msgstr ""

#: celery.contrib.sphinx:29 of
msgid "Use ``.. autotask::`` to alternatively manually document a task."
msgstr ""

#: celery.contrib.sphinx.TaskDirective:1 of
msgid "Sphinx task directive."
msgstr ""

#: celery.contrib.sphinx.TaskDirective.get_signature_prefix:1 of
msgid "May return a prefix to put before the object name in the signature."
msgstr ""

#: celery.contrib.sphinx.TaskDocumenter:1 of
msgid "Document task definitions."
msgstr ""

#: celery.contrib.sphinx.TaskDocumenter.can_document_member:1 of
msgid "Called to see if a member can be documented by this documenter."
msgstr ""

#: celery.contrib.sphinx.TaskDocumenter.check_module:1 of
msgid ""
"Check if *self.object* is really defined in the module given by "
"*self.modname*."
msgstr ""

#: celery.contrib.sphinx.TaskDocumenter.document_members:1 of
msgid "Generate reST for member documentation."
msgstr ""

#: celery.contrib.sphinx.TaskDocumenter.document_members:3 of
msgid ""
"If *all_members* is True, do all members, else those given by "
"*self.options.members*."
msgstr ""

#: celery.contrib.sphinx.TaskDocumenter.format_args:1 of
msgid "Format the argument signature of *self.object*."
msgstr ""

#: celery.contrib.sphinx.TaskDocumenter.format_args:3 of
msgid "Should return None if the object does not have a signature."
msgstr ""

#: celery.contrib.sphinx.autodoc_skip_member_handler:1 of
msgid "Handler for autodoc-skip-member event."
msgstr ""

#: celery.contrib.sphinx.setup:1 of
msgid "Setup Sphinx extension."
msgstr ""

#: ../../userguide/tasks.rst:5
msgid "Tasks"
msgstr ""

#: ../../userguide/tasks.rst:7
msgid "Tasks are the building blocks of Celery applications."
msgstr ""

#: ../../userguide/tasks.rst:9
msgid ""
"A task is a class that can be created out of any callable. It performs "
"dual roles in that it defines both what happens when a task is called "
"(sends a message), and what happens when a worker receives that message."
msgstr ""

#: ../../userguide/tasks.rst:13
msgid ""
"Every task class has a unique name, and this name is referenced in "
"messages so the worker can find the right function to execute."
msgstr ""

#: ../../userguide/tasks.rst:16
msgid ""
"A task message is not removed from the queue until that message has been "
":term:`acknowledged` by a worker. A worker can reserve many messages in "
"advance and even if the worker is killed -- by power failure or some "
"other reason -- the message will be redelivered to another worker."
msgstr ""

#: ../../userguide/tasks.rst:21
msgid ""
"Ideally task functions should be :term:`idempotent`: meaning the function"
" won't cause unintended effects even if called multiple times with the "
"same arguments. Since the worker cannot detect if your tasks are "
"idempotent, the default behavior is to acknowledge the message in "
"advance, just before it's executed, so that a task invocation that "
"already started is never executed again."
msgstr ""

#: ../../userguide/tasks.rst:28
msgid ""
"If your task is idempotent you can set the :attr:`~Task.acks_late` option"
" to have the worker acknowledge the message *after* the task returns "
"instead. See also the FAQ entry :ref:`faq-acks_late-vs-retry`."
msgstr ""

#: ../../userguide/tasks.rst:32
msgid ""
"Note that the worker will acknowledge the message if the child process "
"executing the task is terminated (either by the task calling "
":func:`sys.exit`, or by signal) even when :attr:`~Task.acks_late` is "
"enabled.  This behavior is by purpose as..."
msgstr ""

#: ../../userguide/tasks.rst:37
msgid ""
"We don't want to rerun tasks that forces the kernel to send a "
":sig:`SIGSEGV` (segmentation fault) or similar signals to the process."
msgstr ""

#: ../../userguide/tasks.rst:39
msgid ""
"We assume that a system administrator deliberately killing the task does "
"not want it to automatically restart."
msgstr ""

#: ../../userguide/tasks.rst:41
msgid ""
"A task that allocates too much memory is in danger of triggering the "
"kernel OOM killer, the same may happen again."
msgstr ""

#: ../../userguide/tasks.rst:43
msgid ""
"A task that always fails when redelivered may cause a high-frequency "
"message loop taking down the system."
msgstr ""

#: ../../userguide/tasks.rst:46
msgid ""
"If you really want a task to be redelivered in these scenarios you should"
" consider enabling the :setting:`task_reject_on_worker_lost` setting."
msgstr ""

#: ../../userguide/tasks.rst:51
msgid ""
"A task that blocks indefinitely may eventually stop the worker instance "
"from doing any other work."
msgstr ""

#: ../../userguide/tasks.rst:54
msgid ""
"If your task does I/O then make sure you add timeouts to these "
"operations, like adding a timeout to a web request using the "
":pypi:`requests` library:"
msgstr ""

#: ../../userguide/tasks.rst:62
msgid ""
":ref:`Time limits <worker-time-limits>` are convenient for making sure "
"all tasks return in a timely manner, but a time limit event will actually"
" kill the process by force so only use them to detect cases where you "
"haven't used manual timeouts yet."
msgstr ""

#: ../../userguide/tasks.rst:67
msgid ""
"The default prefork pool scheduler is not friendly to long-running tasks,"
" so if you have tasks that run for minutes/hours make sure you enable the"
" :option:`-Ofair <celery worker -O>` command-line argument to the "
":program:`celery worker`. See :ref:`prefork-pool-prefetch` for more "
"information, and for the best performance route long-running and short-"
"running tasks to dedicated workers (:ref:`routing-automatic`)."
msgstr ""

#: ../../userguide/tasks.rst:74
msgid ""
"If your worker hangs then please investigate what tasks are running "
"before submitting an issue, as most likely the hanging is caused by one "
"or more tasks hanging on a network operation."
msgstr ""

#: ../../userguide/tasks.rst:78
msgid "--"
msgstr ""

#: ../../userguide/tasks.rst:80
msgid ""
"In this chapter you'll learn all about defining tasks, and this is the "
"**table of contents**:"
msgstr ""

#: ../../userguide/tasks.rst:93
msgid ""
"You can easily create a task from any callable by using the "
":meth:`~@task` decorator:"
msgstr ""

#: ../../userguide/tasks.rst:105
msgid ""
"There are also many :ref:`options <task-options>` that can be set for the"
" task, these can be specified as arguments to the decorator:"
msgstr ""

#: ../../userguide/tasks.rst:117
msgid ""
"The task decorator is available on your :class:`@Celery` application "
"instance, if you don't know what this is then please read :ref:`first-"
"steps`."
msgstr ""

#: ../../userguide/tasks.rst:120
msgid ""
"If you're using Django (see :ref:`django-first-steps`), or you're the "
"author of a library then you probably want to use the "
":func:`@shared_task` decorator:"
msgstr ""

#: ../../userguide/tasks.rst:133
msgid ""
"When using multiple decorators in combination with the task decorator you"
" must make sure that the `task` decorator is applied last (oddly, in "
"Python this means it must be first in the list):"
msgstr ""

#: ../../userguide/tasks.rst:147
msgid "Bound tasks"
msgstr ""

#: ../../userguide/tasks.rst:149
msgid ""
"A task being bound means the first argument to the task will always be "
"the task instance (``self``), just like Python bound methods:"
msgstr ""

#: ../../userguide/tasks.rst:160
msgid ""
"Bound tasks are needed for retries (using :meth:`Task.retry() "
"<@Task.retry>`), for accessing information about the current task "
"request, and for any additional functionality you add to custom task base"
" classes."
msgstr ""

#: ../../userguide/tasks.rst:165
msgid "Task inheritance"
msgstr ""

#: ../../userguide/tasks.rst:167
msgid ""
"The ``base`` argument to the task decorator specifies the base class of "
"the task:"
msgstr ""

#: ../../userguide/tasks.rst:185
msgid "Names"
msgstr ""

#: ../../userguide/tasks.rst:187
msgid "Every task must have a unique name."
msgstr ""

#: ../../userguide/tasks.rst:189
msgid ""
"If no explicit name is provided the task decorator will generate one for "
"you, and this name will be based on 1) the module the task is defined in,"
" and 2) the name of the task function."
msgstr ""

#: ../../userguide/tasks.rst:193
msgid "Example setting explicit name:"
msgstr ""

#: ../../userguide/tasks.rst:204
msgid ""
"A best practice is to use the module name as a name-space, this way names"
" won't collide if there's already a task with that name defined in "
"another module."
msgstr ""

#: ../../userguide/tasks.rst:214
msgid ""
"You can tell the name of the task by investigating its ``.name`` "
"attribute:"
msgstr ""

#: ../../userguide/tasks.rst:221
msgid ""
"The name we specified here (``tasks.add``) is exactly the name that "
"would've been automatically generated for us if the task was defined in a"
" module named :file:`tasks.py`:"
msgstr ""

#: ../../userguide/tasks.rst:242
msgid "Automatic naming and relative imports"
msgstr ""

msgid "Absolute Imports"
msgstr ""

#: ../../userguide/tasks.rst:246
msgid ""
"The best practice for developers targeting Python 2 is to add the "
"following to the top of **every module**:"
msgstr ""

#: ../../userguide/tasks.rst:253
msgid ""
"This will force you to always use absolute imports so you will never have"
" any problems with tasks using relative names."
msgstr ""

#: ../../userguide/tasks.rst:256
msgid ""
"Absolute imports are the default in Python 3 so you don't need this if "
"you target that version."
msgstr ""

#: ../../userguide/tasks.rst:259
msgid ""
"Relative imports and automatic name generation don't go well together, so"
" if you're using relative imports you should set the name explicitly."
msgstr ""

#: ../../userguide/tasks.rst:262
msgid ""
"For example if the client imports the module ``\"myapp.tasks\"`` as "
"``\".tasks\"``, and the worker imports the module as ``\"myapp.tasks\"``,"
" the generated names won't match and an :exc:`~@NotRegistered` error will"
" be raised by the worker."
msgstr ""

#: ../../userguide/tasks.rst:267
msgid ""
"This is also the case when using Django and using ``project.myapp``-style"
" naming in ``INSTALLED_APPS``:"
msgstr ""

#: ../../userguide/tasks.rst:274
msgid ""
"If you install the app under the name ``project.myapp`` then the tasks "
"module will be imported as ``project.myapp.tasks``, so you must make sure"
" you always import the tasks using the same name:"
msgstr ""

#: ../../userguide/tasks.rst:284
msgid ""
"The second example will cause the task to be named differently since the "
"worker and the client imports the modules under different names:"
msgstr ""

#: ../../userguide/tasks.rst:297
msgid ""
"For this reason you must be consistent in how you import modules, and "
"that is also a Python best practice."
msgstr ""

#: ../../userguide/tasks.rst:300
msgid "Similarly, you shouldn't use old-style relative imports:"
msgstr ""

#: ../../userguide/tasks.rst:308
msgid "New-style relative imports are fine and can be used:"
msgstr ""

#: ../../userguide/tasks.rst:314
msgid ""
"If you want to use Celery with a project already using these patterns "
"extensively and you don't have the time to refactor the existing code "
"then you can consider specifying the names explicitly instead of relying "
"on the automatic naming:"
msgstr ""

#: ../../userguide/tasks.rst:328
msgid "Changing the automatic naming behavior"
msgstr ""

#: ../../userguide/tasks.rst:332
msgid ""
"There are some cases when the default automatic naming isn't suitable. "
"Consider having many tasks within many different modules::"
msgstr ""

#: ../../userguide/tasks.rst:345
msgid ""
"Using the default automatic naming, each task will have a generated name "
"like `moduleA.tasks.taskA`, `moduleA.tasks.taskB`, `moduleB.tasks.test`, "
"and so on. You may want to get rid of having `tasks` in all task names. "
"As pointed above, you can explicitly give names for all tasks, or you can"
" change the automatic naming behavior by overriding "
":meth:`@gen_task_name`. Continuing with the example, `celery.py` may "
"contain:"
msgstr ""

#: ../../userguide/tasks.rst:366
msgid ""
"So each task will have a name like `moduleA.taskA`, `moduleA.taskB` and "
"`moduleB.test`."
msgstr ""

#: ../../userguide/tasks.rst:371
msgid ""
"Make sure that your :meth:`@gen_task_name` is a pure function: meaning "
"that for the same input it must always return the same output."
msgstr ""

#: ../../userguide/tasks.rst:377
msgid "Task Request"
msgstr ""

#: ../../userguide/tasks.rst:379
msgid ""
":attr:`Task.request <@Task.request>` contains information and state "
"related to the currently executing task."
msgstr ""

#: ../../userguide/tasks.rst:382
msgid "The request defines the following attributes:"
msgstr ""

#: ../../userguide/tasks.rst
msgid "id"
msgstr ""

#: ../../userguide/tasks.rst:384
msgid "The unique id of the executing task."
msgstr ""

#: ../../userguide/tasks.rst
msgid "group"
msgstr ""

#: ../../userguide/tasks.rst:386
msgid ""
"The unique id of the task's :ref:`group <canvas-group>`, if this task is "
"a member."
msgstr ""

#: ../../userguide/tasks.rst
msgid "chord"
msgstr ""

#: ../../userguide/tasks.rst:388
msgid ""
"The unique id of the chord this task belongs to (if the task is part of "
"the header)."
msgstr ""

#: ../../userguide/tasks.rst
msgid "correlation_id"
msgstr ""

#: ../../userguide/tasks.rst:391
msgid "Custom ID used for things like de-duplication."
msgstr ""

#: ../../userguide/tasks.rst
msgid "args"
msgstr ""

#: ../../userguide/tasks.rst
msgid "kwargs"
msgstr ""

#: ../../userguide/tasks.rst
msgid "origin"
msgstr ""

#: ../../userguide/tasks.rst:397
msgid "Name of host that sent this task."
msgstr ""

#: ../../userguide/tasks.rst
msgid "retries"
msgstr ""

#: ../../userguide/tasks.rst:399
msgid ""
"How many times the current task has been retried. An integer starting at "
"`0`."
msgstr ""

#: ../../userguide/tasks.rst
msgid "is_eager"
msgstr ""

#: ../../userguide/tasks.rst:402
msgid ""
"Set to :const:`True` if the task is executed locally in the client, not "
"by a worker."
msgstr ""

#: ../../userguide/tasks.rst
msgid "eta"
msgstr ""

#: ../../userguide/tasks.rst:405
msgid ""
"The original ETA of the task (if any). This is in UTC time (depending on "
"the :setting:`enable_utc` setting)."
msgstr ""

#: ../../userguide/tasks.rst
msgid "expires"
msgstr ""

#: ../../userguide/tasks.rst:409
msgid ""
"The original expiry time of the task (if any). This is in UTC time "
"(depending on the :setting:`enable_utc` setting)."
msgstr ""

#: ../../userguide/tasks.rst
msgid "hostname"
msgstr ""

#: ../../userguide/tasks.rst:413
msgid "Node name of the worker instance executing the task."
msgstr ""

#: ../../userguide/tasks.rst
msgid "delivery_info"
msgstr ""

#: ../../userguide/tasks.rst:415
msgid ""
"Additional message delivery information. This is a mapping containing the"
" exchange and routing key used to deliver this task. Used by for example "
":meth:`Task.retry() <@Task.retry>` to resend the task to the same "
"destination queue. Availability of keys in this dict depends on the "
"message broker used."
msgstr ""

#: ../../userguide/tasks.rst
msgid "reply-to"
msgstr ""

#: ../../userguide/tasks.rst:422
msgid ""
"Name of queue to send replies back to (used with RPC result backend for "
"example)."
msgstr ""

#: ../../userguide/tasks.rst
msgid "called_directly"
msgstr ""

#: ../../userguide/tasks.rst:425
msgid "This flag is set to true if the task wasn't executed by the worker."
msgstr ""

#: ../../userguide/tasks.rst
msgid "timelimit"
msgstr ""

#: ../../userguide/tasks.rst:428
msgid ""
"A tuple of the current ``(soft, hard)`` time limits active for this task "
"(if any)."
msgstr ""

#: ../../userguide/tasks.rst
msgid "callbacks"
msgstr ""

#: ../../userguide/tasks.rst:431
msgid "A list of signatures to be called if this task returns successfully."
msgstr ""

#: ../../userguide/tasks.rst
msgid "errback"
msgstr ""

#: ../../userguide/tasks.rst:433
msgid "A list of signatures to be called if this task fails."
msgstr ""

#: ../../userguide/tasks.rst
msgid "utc"
msgstr ""

#: ../../userguide/tasks.rst:435
msgid "Set to true the caller has UTC enabled (:setting:`enable_utc`)."
msgstr ""

#: ../../userguide/tasks.rst
msgid "headers"
msgstr ""

#: ../../userguide/tasks.rst:440
msgid ""
"Mapping of message headers sent with this task message (may be "
":const:`None`)."
msgstr ""

#: ../../userguide/tasks.rst
msgid "reply_to"
msgstr ""

#: ../../userguide/tasks.rst:443
msgid "Where to send reply to (queue name)."
msgstr ""

#: ../../userguide/tasks.rst:445
msgid ""
"Usually the same as the task id, often used in amqp to keep track of what"
" a reply is for."
msgstr ""

#: ../../userguide/tasks.rst
msgid "root_id"
msgstr ""

#: ../../userguide/tasks.rst:450
msgid ""
"The unique id of the first task in the workflow this task is part of (if "
"any)."
msgstr ""

#: ../../userguide/tasks.rst
msgid "parent_id"
msgstr ""

#: ../../userguide/tasks.rst:453
msgid "The unique id of the task that called this task (if any)."
msgstr ""

#: ../../userguide/tasks.rst
msgid "chain"
msgstr ""

#: ../../userguide/tasks.rst:455
msgid ""
"Reversed list of tasks that form a chain (if any). The last item in this "
"list will be the next task to succeed the current task.  If using version"
" one of the task protocol the chain tasks will be in "
"``request.callbacks`` instead."
msgstr ""

#: ../../userguide/tasks.rst:463
msgid "An example task accessing information in the context is:"
msgstr ""

#: ../../userguide/tasks.rst:473
msgid ""
"The ``bind`` argument means that the function will be a \"bound method\" "
"so that you can access attributes and methods on the task type instance."
msgstr ""

#: ../../userguide/tasks.rst:481
msgid ""
"The worker will automatically set up logging for you, or you can "
"configure logging manually."
msgstr ""

#: ../../userguide/tasks.rst:484
msgid ""
"A special logger is available named \"celery.task\", you can inherit from"
" this logger to automatically get the task name and unique id as part of "
"the logs."
msgstr ""

#: ../../userguide/tasks.rst:488
msgid ""
"The best practice is to create a common logger for all of your tasks at "
"the top of your module:"
msgstr ""

#: ../../userguide/tasks.rst:502
msgid ""
"Celery uses the standard Python logger library, and the documentation can"
" be found :mod:`here <logging>`."
msgstr ""

#: ../../userguide/tasks.rst:505
msgid ""
"You can also use :func:`print`, as anything written to standard out/-err "
"will be redirected to the logging system (you can disable this, see "
":setting:`worker_redirect_stdouts`)."
msgstr ""

#: ../../userguide/tasks.rst:511
msgid ""
"The worker won't update the redirection if you create a logger instance "
"somewhere in your task or task module."
msgstr ""

#: ../../userguide/tasks.rst:514
msgid ""
"If you want to redirect ``sys.stdout`` and ``sys.stderr`` to a custom "
"logger you have to enable this manually, for example:"
msgstr ""

#: ../../userguide/tasks.rst:537
msgid ""
"If a specific Celery logger you need is not emitting logs, you should "
"check that the logger is propagating properly. In this example "
"\"celery.app.trace\" is enabled so that \"succeeded in\" logs are "
"emitted:"
msgstr ""

#: ../../userguide/tasks.rst:558
msgid "Argument checking"
msgstr ""

#: ../../userguide/tasks.rst:562
msgid ""
"Celery will verify the arguments passed when you call the task, just like"
" Python does when calling a normal function:"
msgstr ""

#: ../../userguide/tasks.rst:585
msgid ""
"You can disable the argument checking for any task by setting its "
":attr:`~@Task.typing` attribute to :const:`False`:"
msgstr ""

#: ../../userguide/tasks.rst:601
msgid "Hiding sensitive information in arguments"
msgstr ""

#: ../../userguide/tasks.rst:605
msgid ""
"When using :setting:`task_protocol` 2 or higher (default since 4.0), you "
"can override how positional arguments and keyword arguments are "
"represented in logs and monitoring events using the ``argsrepr`` and "
"``kwargsrepr`` calling arguments:"
msgstr ""

#: ../../userguide/tasks.rst:621
msgid ""
"Sensitive information will still be accessible to anyone able to read "
"your task message from the broker, or otherwise able intercept it."
msgstr ""

#: ../../userguide/tasks.rst:624
msgid ""
"For this reason you should probably encrypt your message if it contains "
"sensitive information, or in this example with a credit card number the "
"actual number could be stored encrypted in a secure store that you "
"retrieve and decrypt in the task itself."
msgstr ""

#: ../../userguide/tasks.rst:632
msgid "Retrying"
msgstr ""

#: ../../userguide/tasks.rst:634
msgid ""
":meth:`Task.retry() <@Task.retry>` can be used to re-execute the task, "
"for example in the event of recoverable errors."
msgstr ""

#: ../../userguide/tasks.rst:637
msgid ""
"When you call ``retry`` it'll send a new message, using the same task-id,"
" and it'll take care to make sure the message is delivered to the same "
"queue as the originating task."
msgstr ""

#: ../../userguide/tasks.rst:641
msgid ""
"When a task is retried this is also recorded as a task state, so that you"
" can track the progress of the task using the result instance (see :ref"
":`task-states`)."
msgstr ""

#: ../../userguide/tasks.rst:645
msgid "Here's an example using ``retry``:"
msgstr ""

#: ../../userguide/tasks.rst:659
msgid ""
"The :meth:`Task.retry() <@Task.retry>` call will raise an exception so "
"any code after the retry won't be reached. This is the :exc:`~@Retry` "
"exception, it isn't handled as an error but rather as a semi-predicate to"
" signify to the worker that the task is to be retried, so that it can "
"store the correct state when a result backend is enabled."
msgstr ""

#: ../../userguide/tasks.rst:665
msgid ""
"This is normal operation and always happens unless the ``throw`` argument"
" to retry is set to :const:`False`."
msgstr ""

#: ../../userguide/tasks.rst:668
msgid ""
"The bind argument to the task decorator will give access to ``self`` (the"
" task type instance)."
msgstr ""

#: ../../userguide/tasks.rst:671
msgid ""
"The ``exc`` argument is used to pass exception information that's used in"
" logs, and when storing task results. Both the exception and the "
"traceback will be available in the task state (if a result backend is "
"enabled)."
msgstr ""

#: ../../userguide/tasks.rst:676
msgid ""
"If the task has a ``max_retries`` value the current exception will be re-"
"raised if the max number of retries has been exceeded, but this won't "
"happen if:"
msgstr ""

#: ../../userguide/tasks.rst:680
msgid "An ``exc`` argument wasn't given."
msgstr ""

#: ../../userguide/tasks.rst:682
msgid ""
"In this case the :exc:`~@MaxRetriesExceededError` exception will be "
"raised."
msgstr ""

#: ../../userguide/tasks.rst:685
msgid "There's no current exception"
msgstr ""

#: ../../userguide/tasks.rst:687
msgid ""
"If there's no original exception to re-raise the ``exc`` argument will be"
" used instead, so:"
msgstr ""

#: ../../userguide/tasks.rst:694
msgid "will raise the ``exc`` argument given."
msgstr ""

#: ../../userguide/tasks.rst:699
msgid "Using a custom retry delay"
msgstr ""

#: ../../userguide/tasks.rst:701
msgid ""
"When a task is to be retried, it can wait for a given amount of time "
"before doing so, and the default delay is defined by the "
":attr:`~@Task.default_retry_delay` attribute. By default this is set to 3"
" minutes. Note that the unit for setting the delay is in seconds (int or "
"float)."
msgstr ""

#: ../../userguide/tasks.rst:707
msgid ""
"You can also provide the `countdown` argument to :meth:`~@Task.retry` to "
"override this default."
msgstr ""

#: ../../userguide/tasks.rst:723
msgid "Automatic retry for known exceptions"
msgstr ""

#: ../../userguide/tasks.rst:727
msgid ""
"Sometimes you just want to retry a task whenever a particular exception "
"is raised."
msgstr ""

#: ../../userguide/tasks.rst:730
msgid ""
"Fortunately, you can tell Celery to automatically retry a task using "
"`autoretry_for` argument in the :meth:`~@Celery.task` decorator:"
msgstr ""

#: ../../userguide/tasks.rst:741
msgid ""
"If you want to specify custom arguments for an internal "
":meth:`~@Task.retry` call, pass `retry_kwargs` argument to "
":meth:`~@Celery.task` decorator:"
msgstr ""

#: ../../userguide/tasks.rst:751
msgid ""
"This is provided as an alternative to manually handling the exceptions, "
"and the example above will do the same as wrapping the task body in a "
":keyword:`try` ... :keyword:`except` statement:"
msgstr ""

#: ../../userguide/tasks.rst:764
msgid "If you want to automatically retry on any error, simply use:"
msgstr ""

#: ../../userguide/tasks.rst:774
msgid ""
"If your tasks depend on another service, like making a request to an API,"
" then it's a good idea to use `exponential backoff`_ to avoid "
"overwhelming the service with your requests. Fortunately, Celery's "
"automatic retry support makes it easy. Just specify the "
":attr:`~Task.retry_backoff` argument, like this:"
msgstr ""

#: ../../userguide/tasks.rst:787
msgid ""
"By default, this exponential backoff will also introduce random jitter_ "
"to avoid having all the tasks run at the same moment. It will also cap "
"the maximum backoff delay to 10 minutes. All these settings can be "
"customized via options documented below."
msgstr ""

#: ../../userguide/tasks.rst:794
msgid ""
"A list/tuple of exception classes. If any of these exceptions are raised "
"during the execution of the task, the task will automatically be retried."
" By default, no exceptions will be autoretried."
msgstr ""

#: ../../userguide/tasks.rst:800
msgid ""
"A dictionary. Use this to customize how autoretries are executed. Note "
"that if you use the exponential backoff options below, the `countdown` "
"task option will be determined by Celery's autoretry system, and any "
"`countdown` included in this dictionary will be ignored."
msgstr ""

#: ../../userguide/tasks.rst:807
msgid ""
"A boolean, or a number. If this option is set to ``True``, autoretries "
"will be delayed following the rules of `exponential backoff`_. The first "
"retry will have a delay of 1 second, the second retry will have a delay "
"of 2 seconds, the third will delay 4 seconds, the fourth will delay 8 "
"seconds, and so on. (However, this delay value is modified by "
":attr:`~Task.retry_jitter`, if it is enabled.) If this option is set to a"
" number, it is used as a delay factor. For example, if this option is set"
" to ``3``, the first retry will delay 3 seconds, the second will delay 6 "
"seconds, the third will delay 12 seconds, the fourth will delay 24 "
"seconds, and so on. By default, this option is set to ``False``, and "
"autoretries will not be delayed."
msgstr ""

#: ../../userguide/tasks.rst:821
msgid ""
"A number. If ``retry_backoff`` is enabled, this option will set a maximum"
" delay in seconds between task autoretries. By default, this option is "
"set to ``600``, which is 10 minutes."
msgstr ""

#: ../../userguide/tasks.rst:827
msgid ""
"A boolean. `Jitter`_ is used to introduce randomness into exponential "
"backoff delays, to prevent all tasks in the queue from being executed "
"simultaneously. If this option is set to ``True``, the delay value "
"calculated by :attr:`~Task.retry_backoff` is treated as a maximum, and "
"the actual delay value will be a random number between zero and that "
"maximum. By default, this option is set to ``True``."
msgstr ""

#: ../../userguide/tasks.rst:837
msgid "List of Options"
msgstr ""

#: ../../userguide/tasks.rst:839
msgid ""
"The task decorator can take a number of options that change the way the "
"task behaves, for example you can set the rate limit for a task using the"
" :attr:`rate_limit` option."
msgstr ""

#: ../../userguide/tasks.rst:843
msgid ""
"Any keyword argument passed to the task decorator will actually be set as"
" an attribute of the resulting task class, and this is a list of the "
"built-in attributes."
msgstr ""

#: ../../userguide/tasks.rst:848
msgid "General"
msgstr ""

#: ../../userguide/tasks.rst:854
msgid "The name the task is registered as."
msgstr ""

#: ../../userguide/tasks.rst:856
msgid ""
"You can set this name manually, or a name will be automatically generated"
" using the module and class name."
msgstr ""

#: ../../userguide/tasks.rst:859
msgid "See also :ref:`task-names`."
msgstr ""

#: ../../userguide/tasks.rst:863
msgid ""
"If the task is being executed this will contain information about the "
"current request. Thread local storage is used."
msgstr ""

#: ../../userguide/tasks.rst:866
msgid "See :ref:`task-request-info`."
msgstr ""

#: ../../userguide/tasks.rst:870
msgid ""
"Only applies if the task calls ``self.retry`` or if the task is decorated"
" with the :ref:`autoretry_for <task-autoretry>` argument."
msgstr ""

#: ../../userguide/tasks.rst:873
msgid ""
"The maximum number of attempted retries before giving up. If the number "
"of retries exceeds this value a :exc:`~@MaxRetriesExceededError` "
"exception will be raised."
msgstr ""

#: ../../userguide/tasks.rst:879
msgid ""
"You have to call :meth:`~@Task.retry` manually, as it won't automatically"
" retry on exception.."
msgstr ""

#: ../../userguide/tasks.rst:882
msgid ""
"The default is ``3``. A value of :const:`None` will disable the retry "
"limit and the task will retry forever until it succeeds."
msgstr ""

#: ../../userguide/tasks.rst:888
msgid ""
"Optional tuple of expected error classes that shouldn't be regarded as an"
" actual error."
msgstr ""

#: ../../userguide/tasks.rst:891
msgid ""
"Errors in this list will be reported as a failure to the result backend, "
"but the worker won't log the event as an error, and no traceback will be "
"included."
msgstr ""

#: ../../userguide/tasks.rst:903
msgid "Error types:"
msgstr ""

#: ../../userguide/tasks.rst:905
msgid "Expected errors (in ``Task.throws``)"
msgstr ""

#: ../../userguide/tasks.rst:907
msgid "Logged with severity ``INFO``, traceback excluded."
msgstr ""

#: ../../userguide/tasks.rst:909
msgid "Unexpected errors"
msgstr ""

#: ../../userguide/tasks.rst:911
msgid "Logged with severity ``ERROR``, with traceback included."
msgstr ""

#: ../../userguide/tasks.rst:915
msgid ""
"Default time in seconds before a retry of the task should be executed. "
"Can be either :class:`int` or :class:`float`. Default is a three minute "
"delay."
msgstr ""

#: ../../userguide/tasks.rst:921
msgid ""
"Set the rate limit for this task type (limits the number of tasks that "
"can be run in a given time frame). Tasks will still complete when a rate "
"limit is in effect, but it may take some time before it's allowed to "
"start."
msgstr ""

#: ../../userguide/tasks.rst:926
msgid ""
"If this is :const:`None` no rate limit is in effect. If it is an integer "
"or float, it is interpreted as \"tasks per second\"."
msgstr ""

#: ../../userguide/tasks.rst:929
msgid ""
"The rate limits can be specified in seconds, minutes or hours by "
"appending `\"/s\"`, `\"/m\"` or `\"/h\"` to the value. Tasks will be "
"evenly distributed over the specified time frame."
msgstr ""

#: ../../userguide/tasks.rst:933
msgid ""
"Example: `\"100/m\"` (hundred tasks a minute). This will enforce a "
"minimum delay of 600ms between starting two tasks on the same worker "
"instance."
msgstr ""

#: ../../userguide/tasks.rst:936
msgid ""
"Default is the :setting:`task_default_rate_limit` setting: if not "
"specified means rate limiting for tasks is disabled by default."
msgstr ""

#: ../../userguide/tasks.rst:939
msgid ""
"Note that this is a *per worker instance* rate limit, and not a global "
"rate limit. To enforce a global rate limit (e.g., for an API with a "
"maximum number of  requests per second), you must restrict to a given "
"queue."
msgstr ""

#: ../../userguide/tasks.rst:946
msgid ""
"The hard time limit, in seconds, for this task. When not set the workers "
"default is used."
msgstr ""

#: ../../userguide/tasks.rst:951
msgid ""
"The soft time limit for this task. When not set the workers default is "
"used."
msgstr ""

#: ../../userguide/tasks.rst:956
msgid ""
"Don't store task state. Note that this means you can't use "
":class:`~celery.result.AsyncResult` to check if the task is ready, or get"
" its return value."
msgstr ""

#: ../../userguide/tasks.rst:962
msgid ""
"If :const:`True`, errors will be stored even if the task is configured to"
" ignore results."
msgstr ""

#: ../../userguide/tasks.rst:967
msgid ""
"A string identifying the default serialization method to use. Defaults to"
" the :setting:`task_serializer` setting. Can be `pickle`, `json`, `yaml`,"
" or any custom serialization methods that have been registered with "
":mod:`kombu.serialization.registry`."
msgstr ""

#: ../../userguide/tasks.rst:973
msgid "Please see :ref:`calling-serializers` for more information."
msgstr ""

#: ../../userguide/tasks.rst:977
msgid "A string identifying the default compression scheme to use."
msgstr ""

#: ../../userguide/tasks.rst:979
msgid ""
"Defaults to the :setting:`task_compression` setting. Can be `gzip`, or "
"`bzip2`, or any custom compression schemes that have been registered with"
" the :mod:`kombu.compression` registry."
msgstr ""

#: ../../userguide/tasks.rst:983
msgid "Please see :ref:`calling-compression` for more information."
msgstr ""

#: ../../userguide/tasks.rst:987
msgid ""
"The result store backend to use for this task. An instance of one of the "
"backend classes in `celery.backends`. Defaults to `app.backend`, defined "
"by the :setting:`result_backend` setting."
msgstr ""

#: ../../userguide/tasks.rst:993
msgid ""
"If set to :const:`True` messages for this task will be acknowledged "
"**after** the task has been executed, not *just before* (the default "
"behavior)."
msgstr ""

#: ../../userguide/tasks.rst:997
msgid ""
"Note: This means the task may be executed multiple times should the "
"worker crash in the middle of execution.  Make sure your tasks are "
":term:`idempotent`."
msgstr ""

#: ../../userguide/tasks.rst:1001
msgid ""
"The global default can be overridden by the :setting:`task_acks_late` "
"setting."
msgstr ""

#: ../../userguide/tasks.rst:1008
msgid ""
"If :const:`True` the task will report its status as \"started\" when the "
"task is executed by a worker. The default value is :const:`False` as the "
"normal behavior is to not report that level of granularity. Tasks are "
"either pending, finished, or waiting to be retried. Having a \"started\" "
"status can be useful for when there are long running tasks and there's a "
"need to report what task is currently running."
msgstr ""

#: ../../userguide/tasks.rst:1016
msgid ""
"The host name and process id of the worker executing the task will be "
"available in the state meta-data (e.g., `result.info['pid']`)"
msgstr ""

#: ../../userguide/tasks.rst:1019
msgid ""
"The global default can be overridden by the :setting:`task_track_started`"
" setting."
msgstr ""

#: ../../userguide/tasks.rst:1025
msgid "The API reference for :class:`~@Task`."
msgstr ""

#: ../../userguide/tasks.rst:1030
msgid "States"
msgstr ""

#: ../../userguide/tasks.rst:1032
msgid ""
"Celery can keep track of the tasks current state. The state also contains"
" the result of a successful task, or the exception and traceback "
"information of a failed task."
msgstr ""

#: ../../userguide/tasks.rst:1036
msgid ""
"There are several *result backends* to choose from, and they all have "
"different strengths and weaknesses (see :ref:`task-result-backends`)."
msgstr ""

#: ../../userguide/tasks.rst:1039
msgid ""
"During its lifetime a task will transition through several possible "
"states, and each state may have arbitrary meta-data attached to it. When "
"a task moves into a new state the previous state is forgotten about, but "
"some transitions can be deduced, (e.g., a task now in the :state:`FAILED`"
" state, is implied to have been in the :state:`STARTED` state at some "
"point)."
msgstr ""

#: ../../userguide/tasks.rst:1046
msgid ""
"There are also sets of states, like the set of :state:`FAILURE_STATES`, "
"and the set of :state:`READY_STATES`."
msgstr ""

#: ../../userguide/tasks.rst:1049
msgid ""
"The client uses the membership of these sets to decide whether the "
"exception should be re-raised (:state:`PROPAGATE_STATES`), or whether the"
" state can be cached (it can if the task is ready)."
msgstr ""

#: ../../userguide/tasks.rst:1053
msgid "You can also define :ref:`custom-states`."
msgstr ""

#: ../../userguide/tasks.rst:1058
msgid "Result Backends"
msgstr ""

#: ../../userguide/tasks.rst:1060
msgid ""
"If you want to keep track of tasks or need the return values, then Celery"
" must store or send the states somewhere so that they can be retrieved "
"later. There are several built-in result backends to choose from: "
"SQLAlchemy/Django ORM, Memcached, RabbitMQ/QPid (``rpc``), and Redis -- "
"or you can define your own."
msgstr ""

#: ../../userguide/tasks.rst:1065
msgid ""
"No backend works well for every use case. You should read about the "
"strengths and weaknesses of each backend, and choose the most appropriate"
" for your needs."
msgstr ""

#: ../../userguide/tasks.rst:1071
msgid ""
"Backends use resources to store and transmit results. To ensure that "
"resources are released, you must eventually call "
":meth:`~@AsyncResult.get` or :meth:`~@AsyncResult.forget` on EVERY "
":class:`~@AsyncResult` instance returned after calling a task."
msgstr ""

#: ../../userguide/tasks.rst:1079
msgid ":ref:`conf-result-backend`"
msgstr ""

#: ../../userguide/tasks.rst:1082
msgid "RPC Result Backend (RabbitMQ/QPid)"
msgstr ""

#: ../../userguide/tasks.rst:1084
msgid ""
"The RPC result backend (`rpc://`) is special as it doesn't actually "
"*store* the states, but rather sends them as messages. This is an "
"important difference as it means that a result *can only be retrieved "
"once*, and *only by the client that initiated the task*. Two different "
"processes can't wait for the same result."
msgstr ""

#: ../../userguide/tasks.rst:1089
msgid ""
"Even with that limitation, it is an excellent choice if you need to "
"receive state changes in real-time. Using messaging means the client "
"doesn't have to poll for new states."
msgstr ""

#: ../../userguide/tasks.rst:1093
msgid ""
"The messages are transient (non-persistent) by default, so the results "
"will disappear if the broker restarts. You can configure the result "
"backend to send persistent messages using the "
":setting:`result_persistent` setting."
msgstr ""

#: ../../userguide/tasks.rst:1098
msgid "Database Result Backend"
msgstr ""

#: ../../userguide/tasks.rst:1100
msgid ""
"Keeping state in the database can be convenient for many, especially for "
"web applications with a database already in place, but it also comes with"
" limitations."
msgstr ""

#: ../../userguide/tasks.rst:1104
msgid ""
"Polling the database for new states is expensive, and so you should "
"increase the polling intervals of operations, such as `result.get()`."
msgstr ""

#: ../../userguide/tasks.rst:1107
msgid ""
"Some databases use a default transaction isolation level that isn't "
"suitable for polling tables for changes."
msgstr ""

#: ../../userguide/tasks.rst:1110
msgid ""
"In MySQL the default transaction isolation level is `REPEATABLE-READ`: "
"meaning the transaction won't see changes made by other transactions "
"until the current transaction is committed."
msgstr ""

#: ../../userguide/tasks.rst:1114
msgid "Changing that to the `READ-COMMITTED` isolation level is recommended."
msgstr ""

#: ../../userguide/tasks.rst:1119
msgid "Built-in States"
msgstr ""

#: ../../userguide/tasks.rst:1124
msgid "PENDING"
msgstr ""

#: ../../userguide/tasks.rst:1126
msgid ""
"Task is waiting for execution or unknown. Any task id that's not known is"
" implied to be in the pending state."
msgstr ""

#: ../../userguide/tasks.rst:1132
msgid "STARTED"
msgstr ""

#: ../../userguide/tasks.rst:1134
msgid ""
"Task has been started. Not reported by default, to enable please see "
":attr:`@Task.track_started`."
msgstr ""

#: ../../userguide/tasks.rst
msgid "meta-data"
msgstr ""

#: ../../userguide/tasks.rst:1137
msgid "`pid` and `hostname` of the worker process executing the task."
msgstr ""

#: ../../userguide/tasks.rst:1143
msgid "SUCCESS"
msgstr ""

#: ../../userguide/tasks.rst:1145
msgid "Task has been successfully executed."
msgstr ""

#: ../../userguide/tasks.rst:1147
msgid "`result` contains the return value of the task."
msgstr ""

#: ../../userguide/tasks.rst
msgid "propagates"
msgstr ""

#: ../../userguide/tasks.rst:1148 ../../userguide/tasks.rst:1149
#: ../../userguide/tasks.rst:1161 ../../userguide/tasks.rst:1182
msgid "Yes"
msgstr ""

#: ../../userguide/tasks.rst
msgid "ready"
msgstr ""

#: ../../userguide/tasks.rst:1154
msgid "FAILURE"
msgstr ""

#: ../../userguide/tasks.rst:1156
msgid "Task execution resulted in failure."
msgstr ""

#: ../../userguide/tasks.rst:1158
msgid ""
"`result` contains the exception occurred, and `traceback` contains the "
"backtrace of the stack at the point when the exception was raised."
msgstr ""

#: ../../userguide/tasks.rst:1166
msgid "RETRY"
msgstr ""

#: ../../userguide/tasks.rst:1168
msgid "Task is being retried."
msgstr ""

#: ../../userguide/tasks.rst:1170
msgid ""
"`result` contains the exception that caused the retry, and `traceback` "
"contains the backtrace of the stack at the point when the exceptions was "
"raised."
msgstr ""

#: ../../userguide/tasks.rst:1173
msgid "No"
msgstr ""

#: ../../userguide/tasks.rst:1178
msgid "REVOKED"
msgstr ""

#: ../../userguide/tasks.rst:1180
msgid "Task has been revoked."
msgstr ""

#: ../../userguide/tasks.rst:1187
msgid "Custom states"
msgstr ""

#: ../../userguide/tasks.rst:1189
msgid ""
"You can easily define your own states, all you need is a unique name. The"
" name of the state is usually an uppercase string. As an example you "
"could have a look at the :mod:`abortable tasks "
"<~celery.contrib.abortable>` which defines a custom :state:`ABORTED` "
"state."
msgstr ""

#: ../../userguide/tasks.rst:1194
msgid "Use :meth:`~@Task.update_state` to update a task's state:."
msgstr ""

#: ../../userguide/tasks.rst:1206
msgid ""
"Here I created the state `\"PROGRESS\"`, telling any application aware of"
" this state that the task is currently in progress, and also where it is "
"in the process by having `current` and `total` counts as part of the "
"state meta-data. This can then be used to create progress bars for "
"example."
msgstr ""

#: ../../userguide/tasks.rst:1214
msgid "Creating pickleable exceptions"
msgstr ""

#: ../../userguide/tasks.rst:1216
msgid ""
"A rarely known Python fact is that exceptions must conform to some simple"
" rules to support being serialized by the pickle module."
msgstr ""

#: ../../userguide/tasks.rst:1219
msgid ""
"Tasks that raise exceptions that aren't pickleable won't work properly "
"when Pickle is used as the serializer."
msgstr ""

#: ../../userguide/tasks.rst:1222
msgid ""
"To make sure that your exceptions are pickleable the exception *MUST* "
"provide the original arguments it was instantiated with in its ``.args`` "
"attribute. The simplest way to ensure this is to have the exception call "
"``Exception.__init__``."
msgstr ""

#: ../../userguide/tasks.rst:1227
msgid "Let's look at some examples that work, and one that doesn't:"
msgstr ""

#: ../../userguide/tasks.rst:1250
msgid ""
"So the rule is: For any exception that supports custom arguments "
"``*args``, ``Exception.__init__(self, *args)`` must be used."
msgstr ""

#: ../../userguide/tasks.rst:1254
msgid ""
"There's no special support for *keyword arguments*, so if you want to "
"preserve keyword arguments when the exception is unpickled you have to "
"pass them as regular args:"
msgstr ""

#: ../../userguide/tasks.rst:1272
msgid "Semipredicates"
msgstr ""

#: ../../userguide/tasks.rst:1274
msgid ""
"The worker wraps the task in a tracing function that records the final "
"state of the task. There are a number of exceptions that can be used to "
"signal this function to change how it treats the return of the task."
msgstr ""

#: ../../userguide/tasks.rst:1281
msgid "Ignore"
msgstr ""

#: ../../userguide/tasks.rst:1283
msgid ""
"The task may raise :exc:`~@Ignore` to force the worker to ignore the "
"task. This means that no state will be recorded for the task, but the "
"message is still acknowledged (removed from queue)."
msgstr ""

#: ../../userguide/tasks.rst:1287
msgid ""
"This can be used if you want to implement custom revoke-like "
"functionality, or manually store the result of a task."
msgstr ""

#: ../../userguide/tasks.rst:1290
msgid "Example keeping revoked tasks in a Redis set:"
msgstr ""

#: ../../userguide/tasks.rst:1301
msgid "Example that stores results manually:"
msgstr ""

#: ../../userguide/tasks.rst:1318
msgid "Reject"
msgstr ""

#: ../../userguide/tasks.rst:1320
msgid ""
"The task may raise :exc:`~@Reject` to reject the task message using AMQPs"
" ``basic_reject`` method. This won't have any effect unless "
":attr:`Task.acks_late` is enabled."
msgstr ""

#: ../../userguide/tasks.rst:1324
msgid ""
"Rejecting a message has the same effect as acking it, but some brokers "
"may implement additional functionality that can be used. For example "
"RabbitMQ supports the concept of `Dead Letter Exchanges`_ where a queue "
"can be configured to use a dead letter exchange that rejected messages "
"are redelivered to."
msgstr ""

#: ../../userguide/tasks.rst:1332
msgid ""
"Reject can also be used to re-queue messages, but please be very careful "
"when using this as it can easily result in an infinite message loop."
msgstr ""

#: ../../userguide/tasks.rst:1335
msgid "Example using reject when a task causes an out of memory condition:"
msgstr ""

#: ../../userguide/tasks.rst:1361
msgid "Example re-queuing the message:"
msgstr ""

#: ../../userguide/tasks.rst:1373
msgid ""
"Consult your broker documentation for more details about the "
"``basic_reject`` method."
msgstr ""

#: ../../userguide/tasks.rst:1380
msgid "Retry"
msgstr ""

#: ../../userguide/tasks.rst:1382
msgid ""
"The :exc:`~@Retry` exception is raised by the ``Task.retry`` method to "
"tell the worker that the task is being retried."
msgstr ""

#: ../../userguide/tasks.rst:1388
msgid "Custom task classes"
msgstr ""

#: ../../userguide/tasks.rst:1390
msgid ""
"All tasks inherit from the :class:`@Task` class. The :meth:`~@Task.run` "
"method becomes the task body."
msgstr ""

#: ../../userguide/tasks.rst:1393
msgid "As an example, the following code,"
msgstr ""

#: ../../userguide/tasks.rst:1402
msgid "will do roughly this behind the scenes:"
msgstr ""

#: ../../userguide/tasks.rst:1414
msgid "Instantiation"
msgstr ""

#: ../../userguide/tasks.rst:1416
msgid ""
"A task is **not** instantiated for every request, but is registered in "
"the task registry as a global instance."
msgstr ""

#: ../../userguide/tasks.rst:1419
msgid ""
"This means that the ``__init__`` constructor will only be called once per"
" process, and that the task class is semantically closer to an Actor."
msgstr ""

#: ../../userguide/tasks.rst:1423
msgid "If you have a task,"
msgstr ""

#: ../../userguide/tasks.rst:1440
msgid ""
"And you route every request to the same process, then it will keep state "
"between requests."
msgstr ""

#: ../../userguide/tasks.rst:1443
msgid ""
"This can also be useful to cache resources, For example, a base Task "
"class that caches a database connection:"
msgstr ""

#: ../../userguide/tasks.rst:1460
msgid "that can be added to tasks like this:"
msgstr ""

#: ../../userguide/tasks.rst:1470
msgid ""
"The ``db`` attribute of the ``process_rows`` task will then always stay "
"the same in each process."
msgstr ""

#: ../../userguide/tasks.rst:1474
msgid "Handlers"
msgstr ""

#: ../../userguide/tasks.rst:1478
msgid "Handler called after the task returns."
msgstr ""

#: ../../userguide/tasks.rst
msgid "Parameters"
msgstr ""

#: ../../userguide/tasks.rst:1480
msgid "Current task state."
msgstr ""

#: ../../userguide/tasks.rst:1481
msgid "Task return value/exception."
msgstr ""

#: ../../userguide/tasks.rst:1482
msgid "Unique id of the task."
msgstr ""

#: ../../userguide/tasks.rst:1483
msgid "Original arguments for the task that returned."
msgstr ""

#: ../../userguide/tasks.rst:1484
msgid "Original keyword arguments for the task that returned."
msgstr ""

#: ../../userguide/tasks.rst:1487
msgid ""
":class:`~billiard.einfo.ExceptionInfo` instance, containing the traceback"
" (if any)."
msgstr ""

#: ../../userguide/tasks.rst:1490 ../../userguide/tasks.rst:1505
#: ../../userguide/tasks.rst:1519 ../../userguide/tasks.rst:1530
msgid "The return value of this handler is ignored."
msgstr ""

#: ../../userguide/tasks.rst:1494
msgid "This is run by the worker when the task fails."
msgstr ""

#: ../../userguide/tasks.rst:1496
msgid "The exception raised by the task."
msgstr ""

#: ../../userguide/tasks.rst:1497
msgid "Unique id of the failed task."
msgstr ""

#: ../../userguide/tasks.rst:1498
msgid "Original arguments for the task that failed."
msgstr ""

#: ../../userguide/tasks.rst:1499
msgid "Original keyword arguments for the task that failed."
msgstr ""

#: ../../userguide/tasks.rst:1502 ../../userguide/tasks.rst:1516
msgid ":class:`~billiard.einfo.ExceptionInfo` instance, containing the traceback."
msgstr ""

#: ../../userguide/tasks.rst:1509
msgid "This is run by the worker when the task is to be retried."
msgstr ""

#: ../../userguide/tasks.rst:1511
msgid "The exception sent to :meth:`~@Task.retry`."
msgstr ""

#: ../../userguide/tasks.rst:1512
msgid "Unique id of the retried task."
msgstr ""

#: ../../userguide/tasks.rst:1513
msgid "Original arguments for the retried task."
msgstr ""

#: ../../userguide/tasks.rst:1514
msgid "Original keyword arguments for the retried task."
msgstr ""

#: ../../userguide/tasks.rst:1523
msgid "Run by the worker if the task executes successfully."
msgstr ""

#: ../../userguide/tasks.rst:1526
msgid "Unique id of the executed task."
msgstr ""

#: ../../userguide/tasks.rst:1527
msgid "Original arguments for the executed task."
msgstr ""

#: ../../userguide/tasks.rst:1528
msgid "Original keyword arguments for the executed task."
msgstr ""

#: ../../userguide/tasks.rst:1535
msgid "Requests and custom requests"
msgstr ""

#: ../../userguide/tasks.rst:1537
msgid ""
"Upon receiving a message to run a task, the `worker <guide-workers>`:ref:"
" creates a `request <celery.worker.request.Request>`:class: to represent "
"such demand."
msgstr ""

#: ../../userguide/tasks.rst:1541
msgid ""
"Custom task classes may override which request class to use by changing "
"the attribute `celery.app.task.Task.Request`:attr:.  You may either "
"assign the custom request class itself, or its fully qualified name."
msgstr ""

#: ../../userguide/tasks.rst:1545
msgid ""
"The request has several responsibilities.  Custom request classes should "
"cover them all -- they are responsible to actually run and trace the "
"task.  We strongly recommend to inherit from "
"`celery.worker.request.Request`:class:."
msgstr ""

#: ../../userguide/tasks.rst:1549
msgid ""
"When using the `pre-forking worker <worker-concurrency>`:ref:, the "
"methods `~celery.worker.request.Request.on_timeout`:meth: and "
"`~celery.worker.request.Request.on_failure`:meth: are executed in the "
"main worker process.  An application may leverage such facility to detect"
" failures which are not detected using "
"`celery.app.task.Task.on_failure`:meth:."
msgstr ""

#: ../../userguide/tasks.rst:1555
msgid ""
"As an example, the following custom request detects and logs hard time "
"limits, and other failures."
msgstr ""

#: ../../userguide/tasks.rst:1598
msgid "How it works"
msgstr ""

#: ../../userguide/tasks.rst:1600
msgid ""
"Here come the technical details. This part isn't something you need to "
"know, but you may be interested."
msgstr ""

#: ../../userguide/tasks.rst:1603
msgid ""
"All defined tasks are listed in a registry. The registry contains a list "
"of task names and their task classes. You can investigate this registry "
"yourself:"
msgstr ""

#: ../../userguide/tasks.rst:1618
msgid ""
"This is the list of tasks built into Celery. Note that tasks will only be"
" registered when the module they're defined in is imported."
msgstr ""

#: ../../userguide/tasks.rst:1621
msgid ""
"The default loader imports any modules listed in the :setting:`imports` "
"setting."
msgstr ""

#: ../../userguide/tasks.rst:1624
msgid ""
"The :meth:`@task` decorator is responsible for registering your task in "
"the applications task registry."
msgstr ""

#: ../../userguide/tasks.rst:1627
msgid ""
"When tasks are sent, no actual function code is sent with it, just the "
"name of the task to execute. When the worker then receives the message it"
" can look up the name in its task registry to find the execution code."
msgstr ""

#: ../../userguide/tasks.rst:1631
msgid ""
"This means that your workers should always be updated with the same "
"software as the client. This is a drawback, but the alternative is a "
"technical challenge that's yet to be solved."
msgstr ""

#: ../../userguide/tasks.rst:1638
msgid "Tips and Best Practices"
msgstr ""

#: ../../userguide/tasks.rst:1643
msgid "Ignore results you don't want"
msgstr ""

#: ../../userguide/tasks.rst:1645
msgid ""
"If you don't care about the results of a task, be sure to set the "
":attr:`~@Task.ignore_result` option, as storing results wastes time and "
"resources."
msgstr ""

#: ../../userguide/tasks.rst:1655
msgid ""
"Results can even be disabled globally using the "
":setting:`task_ignore_result` setting."
msgstr ""

#: ../../userguide/tasks.rst:1660
msgid ""
"Results can be enabled/disabled on a per-execution basis, by passing the "
"``ignore_result`` boolean parameter, when calling ``apply_async`` or "
"``delay``."
msgstr ""

#: ../../userguide/tasks.rst:1677
msgid ""
"By default tasks will *not ignore results* (``ignore_result=False``) when"
" a result backend is configured."
msgstr ""

#: ../../userguide/tasks.rst:1680
msgid "The option precedence order is the following:"
msgstr ""

#: ../../userguide/tasks.rst:1682
msgid "Global :setting:`task_ignore_result`"
msgstr ""

#: ../../userguide/tasks.rst:1683
msgid ":attr:`~@Task.ignore_result` option"
msgstr ""

#: ../../userguide/tasks.rst:1684
msgid "Task execution option ``ignore_result``"
msgstr ""

#: ../../userguide/tasks.rst:1687
msgid "More optimization tips"
msgstr ""

#: ../../userguide/tasks.rst:1689
msgid ""
"You find additional optimization tips in the :ref:`Optimizing Guide "
"<guide-optimizing>`."
msgstr ""

#: ../../userguide/tasks.rst:1695
msgid "Avoid launching synchronous subtasks"
msgstr ""

#: ../../userguide/tasks.rst:1697
msgid ""
"Having a task wait for the result of another task is really inefficient, "
"and may even cause a deadlock if the worker pool is exhausted."
msgstr ""

#: ../../userguide/tasks.rst:1700
msgid "Make your design asynchronous instead, for example by using *callbacks*."
msgstr ""

#: ../../userguide/tasks.rst:1702
msgid "**Bad**:"
msgstr ""

#: ../../userguide/tasks.rst:1725
msgid "**Good**:"
msgstr ""

#: ../../userguide/tasks.rst:1747
msgid ""
"Here I instead created a chain of tasks by linking together different "
":func:`~celery.signature`'s. You can read about chains and other powerful"
" constructs at :ref:`designing-workflows`."
msgstr ""

#: ../../userguide/tasks.rst:1752
msgid ""
"By default Celery will not allow you to run subtasks synchronously within"
" a task, but in rare or extreme cases you might need to do so. "
"**WARNING**: enabling subtasks to run synchronously is not recommended!"
msgstr ""

#: ../../userguide/tasks.rst:1781
msgid "Performance and Strategies"
msgstr ""

#: ../../userguide/tasks.rst:1786
msgid "Granularity"
msgstr ""

#: ../../userguide/tasks.rst:1788
msgid ""
"The task granularity is the amount of computation needed by each subtask."
" In general it is better to split the problem up into many small tasks "
"rather than have a few long running tasks."
msgstr ""

#: ../../userguide/tasks.rst:1792
msgid ""
"With smaller tasks you can process more tasks in parallel and the tasks "
"won't run long enough to block the worker from processing other waiting "
"tasks."
msgstr ""

#: ../../userguide/tasks.rst:1795
msgid ""
"However, executing a task does have overhead. A message needs to be sent,"
" data may not be local, etc. So if the tasks are too fine-grained the "
"overhead added probably removes any benefit."
msgstr ""

#: ../../userguide/tasks.rst:1801
msgid ""
"The book `Art of Concurrency`_ has a section dedicated to the topic of "
"task granularity [AOC1]_."
msgstr ""

#: ../../userguide/tasks.rst:1806
msgid ""
"Breshears, Clay. Section 2.2.1, \"The Art of Concurrency\". O'Reilly "
"Media, Inc. May 15, 2009. ISBN-13 978-0-596-52153-0."
msgstr ""

#: ../../userguide/tasks.rst:1812
msgid "Data locality"
msgstr ""

#: ../../userguide/tasks.rst:1814
msgid ""
"The worker processing the task should be as close to the data as "
"possible. The best would be to have a copy in memory, the worst would be "
"a full transfer from another continent."
msgstr ""

#: ../../userguide/tasks.rst:1818
msgid ""
"If the data is far away, you could try to run another worker at location,"
" or if that's not possible - cache often used data, or preload data you "
"know is going to be used."
msgstr ""

#: ../../userguide/tasks.rst:1822
msgid ""
"The easiest way to share data between workers is to use a distributed "
"cache system, like `memcached`_."
msgstr ""

#: ../../userguide/tasks.rst:1827
msgid ""
"The paper `Distributed Computing Economics`_ by Jim Gray is an excellent "
"introduction to the topic of data locality."
msgstr ""

#: ../../userguide/tasks.rst:1838
msgid "State"
msgstr ""

#: ../../userguide/tasks.rst:1840
msgid ""
"Since Celery is a distributed system, you can't know which process, or on"
" what machine the task will be executed. You can't even know if the task "
"will run in a timely manner."
msgstr ""

#: ../../userguide/tasks.rst:1844
msgid ""
"The ancient async sayings tells us that “asserting the world is the "
"responsibility of the task”. What this means is that the world view may "
"have changed since the task was requested, so the task is responsible for"
" making sure the world is how it should be;  If you have a task that re-"
"indexes a search engine, and the search engine should only be re-indexed "
"at maximum every 5 minutes, then it must be the tasks responsibility to "
"assert that, not the callers."
msgstr ""

#: ../../userguide/tasks.rst:1852
msgid ""
"Another gotcha is Django model objects. They shouldn't be passed on as "
"arguments to tasks. It's almost always better to re-fetch the object from"
" the database when the task is running instead,  as using old data may "
"lead to race conditions."
msgstr ""

#: ../../userguide/tasks.rst:1857
msgid ""
"Imagine the following scenario where you have an article and a task that "
"automatically expands some abbreviations in it:"
msgstr ""

#: ../../userguide/tasks.rst:1871
msgid ""
"First, an author creates an article and saves it, then the author clicks "
"on a button that initiates the abbreviation task:"
msgstr ""

#: ../../userguide/tasks.rst:1879
msgid ""
"Now, the queue is very busy, so the task won't be run for another 2 "
"minutes. In the meantime another author makes changes to the article, so "
"when the task is finally run, the body of the article is reverted to the "
"old version because the task had the old body in its argument."
msgstr ""

#: ../../userguide/tasks.rst:1884
msgid ""
"Fixing the race condition is easy, just use the article id instead, and "
"re-fetch the article in the task body:"
msgstr ""

#: ../../userguide/tasks.rst:1899
msgid ""
"There might even be performance benefits to this approach, as sending "
"large messages may be expensive."
msgstr ""

#: ../../userguide/tasks.rst:1905
msgid "Database transactions"
msgstr ""

#: ../../userguide/tasks.rst:1907
msgid "Let's have a look at another example:"
msgstr ""

#: ../../userguide/tasks.rst:1918
msgid ""
"This is a Django view creating an article object in the database, then "
"passing the primary key to a task. It uses the `commit_on_success` "
"decorator, that will commit the transaction when the view returns, or "
"roll back if the view raises an exception."
msgstr ""

#: ../../userguide/tasks.rst:1923
msgid ""
"There's a race condition if the task starts executing before the "
"transaction has been committed; The database object doesn't exist yet!"
msgstr ""

#: ../../userguide/tasks.rst:1927
msgid ""
"The solution is to use the ``on_commit`` callback to launch your Celery "
"task once all transactions have been committed successfully."
msgstr ""

#: ../../userguide/tasks.rst:1939
msgid ""
"``on_commit`` is available in Django 1.9 and above, if you are using a "
"version prior to that then the `django-transaction-hooks`_ library adds "
"support for this."
msgstr ""

#: ../../userguide/tasks.rst:1950
msgid ""
"Let's take a real world example: a blog where comments posted need to be "
"filtered for spam. When the comment is created, the spam filter runs in "
"the background, so the user doesn't have to wait for it to finish."
msgstr ""

#: ../../userguide/tasks.rst:1954
msgid ""
"I have a Django blog application allowing comments on blog posts. I'll "
"describe parts of the models/views and tasks for this application."
msgstr ""

#: ../../userguide/tasks.rst:1959
msgid "``blog/models.py``"
msgstr ""

#: ../../userguide/tasks.rst:1961
msgid "The comment model looks like this:"
msgstr ""

#: ../../userguide/tasks.rst:1985
msgid ""
"In the view where the comment is posted, I first write the comment to the"
" database, then I launch the spam filter task in the background."
msgstr ""

#: ../../userguide/tasks.rst:1991
msgid "``blog/views.py``"
msgstr ""

#: ../../userguide/tasks.rst:2029
msgid ""
"To filter spam in comments I use `Akismet`_, the service used to filter "
"spam in comments posted to the free blog platform `Wordpress`. `Akismet`_"
" is free for personal use, but for commercial use you need to pay. You "
"have to sign up to their service to get an API key."
msgstr ""

#: ../../userguide/tasks.rst:2034
msgid ""
"To make API calls to `Akismet`_ I use the `akismet.py`_ library written "
"by `Michael Foord`_."
msgstr ""

#: ../../userguide/tasks.rst:2040
msgid "``blog/tasks.py``"
msgstr ""

#: ../../userguide/testing.rst:5
msgid "Testing with Celery"
msgstr ""

#: ../../userguide/testing.rst:8
msgid "Tasks and unit tests"
msgstr ""

#: ../../userguide/testing.rst:10
msgid "To test task behavior in unit tests the preferred method is mocking."
msgstr ""

#: ../../userguide/testing.rst:12
msgid "Eager mode"
msgstr ""

#: ../../userguide/testing.rst:14
msgid ""
"The eager mode enabled by the :setting:`task_always_eager` setting is by "
"definition not suitable for unit tests."
msgstr ""

#: ../../userguide/testing.rst:17
msgid ""
"When testing with eager mode you are only testing an emulation of what "
"happens in a worker, and there are many discrepancies between the "
"emulation and what happens in reality."
msgstr ""

#: ../../userguide/testing.rst:21
msgid ""
"A Celery task is much like a web view, in that it should only define how "
"to perform the action in the context of being called as a task."
msgstr ""

#: ../../userguide/testing.rst:24
msgid ""
"This means optimally tasks only handle things like serialization, message"
" headers, retries, and so on, with the actual logic implemented "
"elsewhere."
msgstr ""

#: ../../userguide/testing.rst:27
msgid "Say we had a task like this:"
msgstr ""

#: ../../userguide/testing.rst:47
msgid ""
"You could write unit tests for this task, using mocking like in this "
"example:"
msgstr ""

#: ../../userguide/testing.rst:88
msgid "Py.test"
msgstr ""

#: ../../userguide/testing.rst:92
msgid ""
"Celery is also a :pypi:`pytest` plugin that adds fixtures that you can "
"use in your integration (or unit) test suites."
msgstr ""

#: ../../userguide/testing.rst:97
msgid "Marks"
msgstr ""

#: ../../userguide/testing.rst:100
msgid "``celery`` - Set test app configuration."
msgstr ""

#: ../../userguide/testing.rst:102
msgid ""
"The ``celery`` mark enables you to override the configuration used for a "
"single test case:"
msgstr ""

#: ../../userguide/testing.rst:112
msgid "or for all the test cases in a class:"
msgstr ""

#: ../../userguide/testing.rst:126
msgid "Fixtures"
msgstr ""

#: ../../userguide/testing.rst:129
msgid "Function scope"
msgstr ""

#: ../../userguide/testing.rst:132
msgid "``celery_app`` - Celery app used for testing."
msgstr ""

#: ../../userguide/testing.rst:134
msgid "This fixture returns a Celery app you can use for testing."
msgstr ""

#: ../../userguide/testing.rst:148
msgid "``celery_worker`` - Embed live worker."
msgstr ""

#: ../../userguide/testing.rst:150
msgid ""
"This fixture starts a Celery worker instance that you can use for "
"integration tests.  The worker will be started in a *separate thread* and"
" will be shutdown as soon as the test returns."
msgstr ""

#: ../../userguide/testing.rst:177
msgid "Session scope"
msgstr ""

#: ../../userguide/testing.rst:180
msgid "``celery_config`` - Override to setup Celery test app configuration."
msgstr ""

#: ../../userguide/testing.rst:181
msgid "You can redefine this fixture to configure the test Celery app."
msgstr ""

#: ../../userguide/testing.rst:183 ../../userguide/testing.rst:205
msgid ""
"The config returned by your fixture will then be used to configure the "
":func:`celery_app`, and :func:`celery_session_app` fixtures."
msgstr ""

#: ../../userguide/testing.rst:199
msgid "``celery_parameters`` - Override to setup Celery test app parameters."
msgstr ""

#: ../../userguide/testing.rst:201
msgid ""
"You can redefine this fixture to change the ``__init__`` parameters of "
"test Celery app. In contrast to :func:`celery_config`, these are directly"
" passed to when instantiating :class:`~celery.Celery`."
msgstr ""

#: ../../userguide/testing.rst:220
msgid "``celery_worker_parameters`` - Override to setup Celery worker parameters."
msgstr ""

#: ../../userguide/testing.rst:222
msgid ""
"You can redefine this fixture to change the ``__init__`` parameters of "
"test Celery workers. These are directly passed to "
":class:`~celery.worker.WorkController` when it is instantiated."
msgstr ""

#: ../../userguide/testing.rst:226
msgid ""
"The config returned by your fixture will then be used to configure the "
":func:`celery_worker`, and :func:`celery_session_worker` fixtures."
msgstr ""

#: ../../userguide/testing.rst:243
msgid ""
"``celery_enable_logging`` - Override to enable logging in embedded "
"workers."
msgstr ""

#: ../../userguide/testing.rst:245
msgid "This is a fixture you can override to enable logging in embedded workers."
msgstr ""

#: ../../userguide/testing.rst:256
msgid "``celery_includes`` - Add additional imports for embedded workers."
msgstr ""

#: ../../userguide/testing.rst:257
msgid ""
"You can override fixture to include modules when an embedded worker "
"starts."
msgstr ""

#: ../../userguide/testing.rst:259
msgid ""
"You can have this return a list of module names to import, which can be "
"task modules, modules registering signals, and so on."
msgstr ""

#: ../../userguide/testing.rst:274
msgid "``celery_worker_pool`` - Override the pool used for embedded workers."
msgstr ""

#: ../../userguide/testing.rst:275
msgid ""
"You can override fixture to configure the execution pool used for "
"embedded workers."
msgstr ""

#: ../../userguide/testing.rst:288
msgid ""
"You cannot use the gevent/eventlet pools, that is unless your whole test "
"suite is running with the monkeypatches enabled."
msgstr ""

#: ../../userguide/testing.rst:292
msgid ""
"``celery_session_worker`` - Embedded worker that lives throughout the "
"session."
msgstr ""

#: ../../userguide/testing.rst:294
msgid ""
"This fixture starts a worker that lives throughout the testing session "
"(it won't be started/stopped for every test)."
msgstr ""

#: ../../userguide/testing.rst:315
msgid "It's probably a bad idea to mix session and ephemeral workers..."
msgstr ""

#: ../../userguide/testing.rst:318
msgid "``celery_session_app`` - Celery app used for testing (session scope)."
msgstr ""

#: ../../userguide/testing.rst:320
msgid ""
"This can be used by other session scoped fixtures when they need to refer"
" to a Celery app instance."
msgstr ""

#: ../../userguide/testing.rst:324
msgid "``use_celery_app_trap`` - Raise exception on falling back to default app."
msgstr ""

#: ../../userguide/testing.rst:326
msgid ""
"This is a fixture you can override in your ``conftest.py``, to enable the"
" \"app trap\": if something tries to access the default or current_app, "
"an exception is raised."
msgstr ""

#: ../../userguide/testing.rst:339
msgid ""
"If a test wants to access the default app, you would have to mark it "
"using the ``depends_on_current_app`` fixture:"
msgstr ""

#: ../../userguide/workers.rst:5
msgid "Workers Guide"
msgstr ""

#: ../../userguide/workers.rst:14
msgid "Starting the worker"
msgstr ""

msgid "Daemonizing"
msgstr ""

#: ../../userguide/workers.rst:18
msgid ""
"You probably want to use a daemonization tool to start the worker in the "
"background. See :ref:`daemonizing` for help starting the worker as a "
"daemon using popular service managers."
msgstr ""

#: ../../userguide/workers.rst:22
msgid "You can start the worker in the foreground by executing the command:"
msgstr ""

#: ../../userguide/workers.rst:28
msgid ""
"For a full list of available command-line options see "
":mod:`~celery.bin.worker`, or simply do:"
msgstr ""

#: ../../userguide/workers.rst:35
msgid ""
"You can start multiple workers on the same machine, but be sure to name "
"each individual worker by specifying a node name with the "
":option:`--hostname <celery worker --hostname>` argument:"
msgstr ""

#: ../../userguide/workers.rst:45
msgid "The ``hostname`` argument can expand the following variables:"
msgstr ""

#: ../../userguide/workers.rst:47 ../../userguide/workers.rst:167
msgid "``%h``:  Hostname, including domain name."
msgstr ""

#: ../../userguide/workers.rst:48 ../../userguide/workers.rst:168
msgid "``%n``:  Hostname only."
msgstr ""

#: ../../userguide/workers.rst:49 ../../userguide/workers.rst:169
#, python-format
msgid "``%d``:  Domain name only."
msgstr ""

#: ../../userguide/workers.rst:51
msgid "If the current hostname is *george.example.com*, these will expand to:"
msgstr ""

#: ../../userguide/workers.rst:54
msgid "Variable"
msgstr ""

#: ../../userguide/workers.rst:54
msgid "Template"
msgstr ""

#: ../../userguide/workers.rst:54
msgid "Result"
msgstr ""

#: ../../userguide/workers.rst:56
msgid "``%h``"
msgstr ""

#: ../../userguide/workers.rst:56
msgid "``worker1@%h``"
msgstr ""

#: ../../userguide/workers.rst:56
msgid "*worker1@george.example.com*"
msgstr ""

#: ../../userguide/workers.rst:58
msgid "``%n``"
msgstr ""

#: ../../userguide/workers.rst:58
msgid "``worker1@%n``"
msgstr ""

#: ../../userguide/workers.rst:58
msgid "*worker1@george*"
msgstr ""

#: ../../userguide/workers.rst:60
#, python-format
msgid "``%d``"
msgstr ""

#: ../../userguide/workers.rst:60
#, python-format
msgid "``worker1@%d``"
msgstr ""

#: ../../userguide/workers.rst:60
msgid "*worker1@example.com*"
msgstr ""

#: ../../userguide/workers.rst:63
msgid "Note for :pypi:`supervisor` users"
msgstr ""

#: ../../userguide/workers.rst:65
#, python-format
msgid "The ``%`` sign must be escaped by adding a second one: `%%h`."
msgstr ""

#: ../../userguide/workers.rst:70
msgid "Stopping the worker"
msgstr ""

#: ../../userguide/workers.rst:72
msgid "Shutdown should be accomplished using the :sig:`TERM` signal."
msgstr ""

#: ../../userguide/workers.rst:74
msgid ""
"When shutdown is initiated the worker will finish all currently executing"
" tasks before it actually terminates. If these tasks are important, you "
"should wait for it to finish before doing anything drastic, like sending "
"the :sig:`KILL` signal."
msgstr ""

#: ../../userguide/workers.rst:79
msgid ""
"If the worker won't shutdown after considerate time, for being stuck in "
"an infinite-loop or similar, you can use the :sig:`KILL` signal to force "
"terminate the worker: but be aware that currently executing tasks will be"
" lost (i.e., unless the tasks have the :attr:`~@Task.acks_late` option "
"set)."
msgstr ""

#: ../../userguide/workers.rst:85
msgid ""
"Also as processes can't override the :sig:`KILL` signal, the worker will "
"not be able to reap its children; make sure to do so manually. This "
"command usually does the trick:"
msgstr ""

#: ../../userguide/workers.rst:93
msgid ""
"If you don't have the :command:`pkill` command on your system, you can "
"use the slightly longer version:"
msgstr ""

#: ../../userguide/workers.rst:103
msgid "Restarting the worker"
msgstr ""

#: ../../userguide/workers.rst:105
msgid ""
"To restart the worker you should send the `TERM` signal and start a new "
"instance. The easiest way to manage workers for development is by using "
"`celery multi`:"
msgstr ""

#: ../../userguide/workers.rst:114
msgid ""
"For production deployments you should be using init-scripts or a process "
"supervision system (see :ref:`daemonizing`)."
msgstr ""

#: ../../userguide/workers.rst:117
msgid ""
"Other than stopping, then starting the worker to restart, you can also "
"restart the worker using the :sig:`HUP` signal. Note that the worker will"
" be responsible for restarting itself so this is prone to problems and "
"isn't recommended in production:"
msgstr ""

#: ../../userguide/workers.rst:128
msgid ""
"Restarting by :sig:`HUP` only works if the worker is running in the "
"background as a daemon (it doesn't have a controlling terminal)."
msgstr ""

#: ../../userguide/workers.rst:132
msgid ":sig:`HUP` is disabled on macOS because of a limitation on that platform."
msgstr ""

#: ../../userguide/workers.rst:139
msgid "Process Signals"
msgstr ""

#: ../../userguide/workers.rst:141
msgid "The worker's main process overrides the following signals:"
msgstr ""

#: ../../userguide/workers.rst:144
msgid ":sig:`TERM`"
msgstr ""

#: ../../userguide/workers.rst:144
msgid "Warm shutdown, wait for tasks to complete."
msgstr ""

#: ../../userguide/workers.rst:146
msgid ":sig:`QUIT`"
msgstr ""

#: ../../userguide/workers.rst:146
msgid "Cold shutdown, terminate ASAP"
msgstr ""

#: ../../userguide/workers.rst:148
msgid ":sig:`USR1`"
msgstr ""

#: ../../userguide/workers.rst:148
msgid "Dump traceback for all active threads."
msgstr ""

#: ../../userguide/workers.rst:150
msgid ":sig:`USR2`"
msgstr ""

#: ../../userguide/workers.rst:150
msgid "Remote debug, see :mod:`celery.contrib.rdb`."
msgstr ""

#: ../../userguide/workers.rst:156
msgid "Variables in file paths"
msgstr ""

#: ../../userguide/workers.rst:158
msgid ""
"The file path arguments for :option:`--logfile <celery worker "
"--logfile>`, :option:`--pidfile <celery worker --pidfile>`, and "
":option:`--statedb <celery worker --statedb>` can contain variables that "
"the worker will expand:"
msgstr ""

#: ../../userguide/workers.rst:164
msgid "Node name replacements"
msgstr ""

#: ../../userguide/workers.rst:166
msgid "``%p``:  Full node name."
msgstr ""

#: ../../userguide/workers.rst:170
#, python-format
msgid "``%i``:  Prefork pool process index or 0 if MainProcess."
msgstr ""

#: ../../userguide/workers.rst:171
msgid "``%I``:  Prefork pool process index with separator."
msgstr ""

#: ../../userguide/workers.rst:173
msgid ""
"For example, if the current hostname is ``george@foo.example.com`` then "
"these will expand to:"
msgstr ""

#: ../../userguide/workers.rst:176
msgid "``--logfile=%p.log`` -> :file:`george@foo.example.com.log`"
msgstr ""

#: ../../userguide/workers.rst:177
msgid "``--logfile=%h.log`` -> :file:`foo.example.com.log`"
msgstr ""

#: ../../userguide/workers.rst:178
msgid "``--logfile=%n.log`` -> :file:`george.log`"
msgstr ""

#: ../../userguide/workers.rst:179
#, python-format
msgid "``--logfile=%d.log`` -> :file:`example.com.log`"
msgstr ""

#: ../../userguide/workers.rst:184
msgid "Prefork pool process index"
msgstr ""

#: ../../userguide/workers.rst:186
msgid ""
"The prefork pool process index specifiers will expand into a different "
"filename depending on the process that'll eventually need to open the "
"file."
msgstr ""

#: ../../userguide/workers.rst:189
msgid "This can be used to specify one log file per child process."
msgstr ""

#: ../../userguide/workers.rst:191
msgid ""
"Note that the numbers will stay within the process limit even if "
"processes exit or if autoscale/``maxtasksperchild``/time limits are used."
"  That is, the number is the *process index* not the process count or "
"pid."
msgstr ""

#: ../../userguide/workers.rst:195
#, python-format
msgid "``%i`` - Pool process index or 0 if MainProcess."
msgstr ""

#: ../../userguide/workers.rst:197
#, python-format
msgid ""
"Where ``-n worker1@example.com -c2 -f %n-%i.log`` will result in three "
"log files:"
msgstr ""

#: ../../userguide/workers.rst:200
msgid ":file:`worker1-0.log` (main process)"
msgstr ""

#: ../../userguide/workers.rst:201 ../../userguide/workers.rst:210
msgid ":file:`worker1-1.log` (pool process 1)"
msgstr ""

#: ../../userguide/workers.rst:202 ../../userguide/workers.rst:211
msgid ":file:`worker1-2.log` (pool process 2)"
msgstr ""

#: ../../userguide/workers.rst:204
msgid "``%I`` - Pool process index with separator."
msgstr ""

#: ../../userguide/workers.rst:206
msgid ""
"Where ``-n worker1@example.com -c2 -f %n%I.log`` will result in three log"
" files:"
msgstr ""

#: ../../userguide/workers.rst:209
msgid ":file:`worker1.log` (main process)"
msgstr ""

#: ../../userguide/workers.rst:218
msgid ""
"By default multiprocessing is used to perform concurrent execution of "
"tasks, but you can also use :ref:`Eventlet <concurrency-eventlet>`. The "
"number of worker processes/threads can be changed using the "
":option:`--concurrency <celery worker --concurrency>` argument and "
"defaults to the number of CPUs available on the machine."
msgstr ""

#: ../../userguide/workers.rst:224
msgid "Number of processes (multiprocessing/prefork pool)"
msgstr ""

#: ../../userguide/workers.rst:226
msgid ""
"More pool processes are usually better, but there's a cut-off point where"
" adding more pool processes affects performance in negative ways. There's"
" even some evidence to support that having multiple worker instances "
"running, may perform better than having a single worker. For example 3 "
"workers with 10 pool processes each. You need to experiment to find the "
"numbers that works best for you, as this varies based on application, "
"work load, task run times and other factors."
msgstr ""

#: ../../userguide/workers.rst:237
msgid "Remote control"
msgstr ""

msgid "The ``celery`` command"
msgstr ""

#: ../../userguide/workers.rst:243
msgid ""
"The :program:`celery` program is used to execute remote control commands "
"from the command-line. It supports all of the commands listed below. See "
":ref:`monitoring-control` for more information."
msgstr ""

#: ../../userguide/workers.rst
msgid "pool support"
msgstr ""

#: ../../userguide/workers.rst:247
msgid "*prefork, eventlet, gevent*, blocking:*solo* (see note)"
msgstr ""

#: ../../userguide/workers.rst
msgid "broker support"
msgstr ""

#: ../../userguide/workers.rst:248 ../../userguide/workers.rst:328
#: ../../userguide/workers.rst:482
msgid "*amqp, redis*"
msgstr ""

#: ../../userguide/workers.rst:250
msgid ""
"Workers have the ability to be remote controlled using a high-priority "
"broadcast message queue. The commands can be directed to all, or a "
"specific list of workers."
msgstr ""

#: ../../userguide/workers.rst:254
msgid ""
"Commands can also have replies. The client can then wait for and collect "
"those replies. Since there's no central authority to know how many "
"workers are available in the cluster, there's also no way to estimate how"
" many workers may send a reply, so the client has a configurable timeout "
"— the deadline in seconds for replies to arrive in. This timeout defaults"
" to one second. If the worker doesn't reply within the deadline it "
"doesn't necessarily mean the worker didn't reply, or worse is dead, but "
"may simply be caused by network latency or the worker being slow at "
"processing commands, so adjust the timeout accordingly."
msgstr ""

#: ../../userguide/workers.rst:264
msgid ""
"In addition to timeouts, the client can specify the maximum number of "
"replies to wait for. If a destination is specified, this limit is set to "
"the number of destination hosts."
msgstr ""

#: ../../userguide/workers.rst:270
msgid ""
"The ``solo`` pool supports remote control commands, but any task "
"executing will block any waiting control command, so it is of limited use"
" if the worker is very busy. In that case you must increase the timeout "
"waiting for replies in the client."
msgstr ""

#: ../../userguide/workers.rst:278
msgid "The :meth:`~@control.broadcast` function"
msgstr ""

#: ../../userguide/workers.rst:280
msgid ""
"This is the client function used to send commands to the workers. Some "
"remote control commands also have higher-level interfaces using "
":meth:`~@control.broadcast` in the background, like "
":meth:`~@control.rate_limit`, and :meth:`~@control.ping`."
msgstr ""

#: ../../userguide/workers.rst:285
msgid "Sending the :control:`rate_limit` command and keyword arguments:"
msgstr ""

#: ../../userguide/workers.rst:293
msgid ""
"This will send the command asynchronously, without waiting for a reply. "
"To request a reply you have to use the `reply` argument:"
msgstr ""

#: ../../userguide/workers.rst:304
msgid ""
"Using the `destination` argument you can specify a list of workers to "
"receive the command:"
msgstr ""

#: ../../userguide/workers.rst:316
msgid ""
"Of course, using the higher-level interface to set rate limits is much "
"more convenient, but there are commands that can only be requested using "
":meth:`~@control.broadcast`."
msgstr ""

#: ../../userguide/workers.rst:326
msgid "``revoke``: Revoking tasks"
msgstr ""

#: ../../userguide/workers.rst:327
msgid "all, terminate only supported by prefork"
msgstr ""

#: ../../userguide/workers.rst
msgid "command"
msgstr ""

#: ../../userguide/workers.rst:329
msgid ":program:`celery -A proj control revoke <task_id>`"
msgstr ""

#: ../../userguide/workers.rst:331
msgid ""
"All worker nodes keeps a memory of revoked task ids, either in-memory or "
"persistent on disk (see :ref:`worker-persistent-revokes`)."
msgstr ""

#: ../../userguide/workers.rst:334
msgid ""
"When a worker receives a revoke request it will skip executing the task, "
"but it won't terminate an already executing task unless the `terminate` "
"option is set."
msgstr ""

#: ../../userguide/workers.rst:340
msgid ""
"The terminate option is a last resort for administrators when a task is "
"stuck. It's not for terminating the task, it's for terminating the "
"process that's executing the task, and that process may have already "
"started processing another task at the point when the signal is sent, so "
"for this reason you must never call this programmatically."
msgstr ""

#: ../../userguide/workers.rst:347
msgid ""
"If `terminate` is set the worker child process processing the task will "
"be terminated. The default signal sent is `TERM`, but you can specify "
"this using the `signal` argument. Signal can be the uppercase name of any"
" signal defined in the :mod:`signal` module in the Python Standard "
"Library."
msgstr ""

#: ../../userguide/workers.rst:353
msgid "Terminating a task also revokes it."
msgstr ""

#: ../../userguide/workers.rst:375
msgid "Revoking multiple tasks"
msgstr ""

#: ../../userguide/workers.rst:380
msgid ""
"The revoke method also accepts a list argument, where it will revoke "
"several tasks at once."
msgstr ""

#: ../../userguide/workers.rst:394
msgid ""
"The ``GroupResult.revoke`` method takes advantage of this since version "
"3.1."
msgstr ""

#: ../../userguide/workers.rst:400
msgid "Persistent revokes"
msgstr ""

#: ../../userguide/workers.rst:402
msgid ""
"Revoking tasks works by sending a broadcast message to all the workers, "
"the workers then keep a list of revoked tasks in memory. When a worker "
"starts up it will synchronize revoked tasks with other workers in the "
"cluster."
msgstr ""

#: ../../userguide/workers.rst:406
msgid ""
"The list of revoked tasks is in-memory so if all workers restart the list"
" of revoked ids will also vanish. If you want to preserve this list "
"between restarts you need to specify a file for these to be stored in by "
"using the `--statedb` argument to :program:`celery worker`:"
msgstr ""

#: ../../userguide/workers.rst:415
msgid ""
"or if you use :program:`celery multi` you want to create one file per "
"worker instance so use the `%n` format to expand the current node name:"
msgstr ""

#: ../../userguide/workers.rst:424
msgid "See also :ref:`worker-files`"
msgstr ""

#: ../../userguide/workers.rst:426
msgid ""
"Note that remote control commands must be working for revokes to work. "
"Remote control commands are only supported by the RabbitMQ (amqp) and "
"Redis at this point."
msgstr ""

#: ../../userguide/workers.rst:433
msgid "Time Limits"
msgstr ""

#: ../../userguide/workers.rst:437
msgid "*prefork/gevent*"
msgstr ""

msgid "Soft, or hard?"
msgstr ""

#: ../../userguide/workers.rst:441
msgid ""
"The time limit is set in two values, `soft` and `hard`. The soft time "
"limit allows the task to catch an exception to clean up before it is "
"killed: the hard timeout isn't catch-able and force terminates the task."
msgstr ""

#: ../../userguide/workers.rst:446
msgid ""
"A single task can potentially run forever, if you have lots of tasks "
"waiting for some event that'll never happen you'll block the worker from "
"processing new tasks indefinitely. The best way to defend against this "
"scenario happening is enabling time limits."
msgstr ""

#: ../../userguide/workers.rst:451
msgid ""
"The time limit (`--time-limit`) is the maximum number of seconds a task "
"may run before the process executing it is terminated and replaced by a "
"new process. You can also enable a soft time limit (`--soft-time-limit`),"
" this raises an exception the task can catch to clean up before the hard "
"time limit kills it:"
msgstr ""

#: ../../userguide/workers.rst:469
msgid ""
"Time limits can also be set using the :setting:`task_time_limit` / "
":setting:`task_soft_time_limit` settings."
msgstr ""

#: ../../userguide/workers.rst:474
msgid ""
"Time limits don't currently work on platforms that don't support the "
":sig:`SIGUSR1` signal."
msgstr ""

#: ../../userguide/workers.rst:479
msgid "Changing time limits at run-time"
msgstr ""

#: ../../userguide/workers.rst:484
msgid ""
"There's a remote control command that enables you to change both soft and"
" hard time limits for a task — named ``time_limit``."
msgstr ""

#: ../../userguide/workers.rst:487
msgid ""
"Example changing the time limit for the ``tasks.crawl_the_web`` task to "
"have a soft time limit of one minute, and a hard time limit of two "
"minutes:"
msgstr ""

#: ../../userguide/workers.rst:497
msgid ""
"Only tasks that starts executing after the time limit change will be "
"affected."
msgstr ""

#: ../../userguide/workers.rst:502
msgid "Rate Limits"
msgstr ""

#: ../../userguide/workers.rst:507
msgid "Changing rate-limits at run-time"
msgstr ""

#: ../../userguide/workers.rst:509
msgid ""
"Example changing the rate limit for the `myapp.mytask` task to execute at"
" most 200 tasks of that type every minute:"
msgstr ""

#: ../../userguide/workers.rst:516
msgid ""
"The above doesn't specify a destination, so the change request will "
"affect all worker instances in the cluster. If you only want to affect a "
"specific list of workers you can include the ``destination`` argument:"
msgstr ""

#: ../../userguide/workers.rst:527
msgid ""
"This won't affect workers with the :setting:`worker_disable_rate_limits` "
"setting enabled."
msgstr ""

#: ../../userguide/workers.rst:533
msgid "Max tasks per child setting"
msgstr ""

#: ../../userguide/workers.rst:537 ../../userguide/workers.rst:556
msgid "*prefork*"
msgstr ""

#: ../../userguide/workers.rst:539
msgid ""
"With this option you can configure the maximum number of tasks a worker "
"can execute before it's replaced by a new process."
msgstr ""

#: ../../userguide/workers.rst:542 ../../userguide/workers.rst:561
msgid ""
"This is useful if you have memory leaks you have no control over for "
"example from closed source C extensions."
msgstr ""

#: ../../userguide/workers.rst:545
msgid ""
"The option can be set using the workers :option:`--max-tasks-per-child "
"<celery worker --max-tasks-per-child>` argument or using the "
":setting:`worker_max_tasks_per_child` setting."
msgstr ""

#: ../../userguide/workers.rst:552
msgid "Max memory per child setting"
msgstr ""

#: ../../userguide/workers.rst:558
msgid ""
"With this option you can configure the maximum amount of resident memory "
"a worker can execute before it's replaced by a new process."
msgstr ""

#: ../../userguide/workers.rst:564
msgid ""
"The option can be set using the workers :option:`--max-memory-per-child "
"<celery worker --max-memory-per-child>` argument or using the "
":setting:`worker_max_memory_per_child` setting."
msgstr ""

#: ../../userguide/workers.rst:571
msgid "Autoscaling"
msgstr ""

#: ../../userguide/workers.rst:575
msgid "*prefork*, *gevent*"
msgstr ""

#: ../../userguide/workers.rst:577
msgid ""
"The *autoscaler* component is used to dynamically resize the pool based "
"on load:"
msgstr ""

#: ../../userguide/workers.rst:581
msgid "The autoscaler adds more pool processes when there is work to do,"
msgstr ""

#: ../../userguide/workers.rst:581
msgid "and starts removing processes when the workload is low."
msgstr ""

#: ../../userguide/workers.rst:583
msgid ""
"It's enabled by the :option:`--autoscale <celery worker --autoscale>` "
"option, which needs two numbers: the maximum and minimum number of pool "
"processes:"
msgstr ""

#: ../../userguide/workers.rst:594
msgid ""
"You can also define your own rules for the autoscaler by subclassing "
":class:`~celery.worker.autoscaler.Autoscaler`. Some ideas for metrics "
"include load average or the amount of memory available. You can specify a"
" custom autoscaler with the :setting:`worker_autoscaler` setting."
msgstr ""

#: ../../userguide/workers.rst:602
msgid "Queues"
msgstr ""

#: ../../userguide/workers.rst:604
msgid ""
"A worker instance can consume from any number of queues. By default it "
"will consume from all queues defined in the :setting:`task_queues` "
"setting (that if not specified falls back to the default queue named "
"``celery``)."
msgstr ""

#: ../../userguide/workers.rst:609
msgid ""
"You can specify what queues to consume from at start-up, by giving a "
"comma separated list of queues to the :option:`-Q <celery worker -Q>` "
"option:"
msgstr ""

#: ../../userguide/workers.rst:616
msgid ""
"If the queue name is defined in :setting:`task_queues` it will use that "
"configuration, but if it's not defined in the list of queues Celery will "
"automatically generate a new queue for you (depending on the "
":setting:`task_create_missing_queues` option)."
msgstr ""

#: ../../userguide/workers.rst:621
msgid ""
"You can also tell the worker to start and stop consuming from a queue at "
"run-time using the remote control commands :control:`add_consumer` and "
":control:`cancel_consumer`."
msgstr ""

#: ../../userguide/workers.rst:628
msgid "Queues: Adding consumers"
msgstr ""

#: ../../userguide/workers.rst:630
msgid ""
"The :control:`add_consumer` control command will tell one or more workers"
" to start consuming from a queue. This operation is idempotent."
msgstr ""

#: ../../userguide/workers.rst:633
msgid ""
"To tell all workers in the cluster to start consuming from a queue named "
"\"``foo``\" you can use the :program:`celery control` program:"
msgstr ""

#: ../../userguide/workers.rst:642
msgid ""
"If you want to specify a specific worker you can use the "
":option:`--destination <celery control --destination>` argument:"
msgstr ""

#: ../../userguide/workers.rst:649
msgid ""
"The same can be accomplished dynamically using the "
":meth:`@control.add_consumer` method:"
msgstr ""

#: ../../userguide/workers.rst:661
msgid ""
"By now we've only shown examples using automatic queues, If you need more"
" control you can also specify the exchange, routing_key and even other "
"options:"
msgstr ""

#: ../../userguide/workers.rst:683
msgid "Queues: Canceling consumers"
msgstr ""

#: ../../userguide/workers.rst:685
msgid ""
"You can cancel a consumer by queue name using the "
":control:`cancel_consumer` control command."
msgstr ""

#: ../../userguide/workers.rst:688
msgid ""
"To force all workers in the cluster to cancel consuming from a queue you "
"can use the :program:`celery control` program:"
msgstr ""

#: ../../userguide/workers.rst:695
msgid ""
"The :option:`--destination <celery control --destination>` argument can "
"be used to specify a worker, or a list of workers, to act on the command:"
msgstr ""

#: ../../userguide/workers.rst:703
msgid ""
"You can also cancel consumers programmatically using the "
":meth:`@control.cancel_consumer` method:"
msgstr ""

#: ../../userguide/workers.rst:714
msgid "Queues: List of active queues"
msgstr ""

#: ../../userguide/workers.rst:716
msgid ""
"You can get a list of queues that a worker consumes from by using the "
":control:`active_queues` control command:"
msgstr ""

#: ../../userguide/workers.rst:724
msgid ""
"Like all other remote control commands this also supports the "
":option:`--destination <celery inspect --destination>` argument used to "
"specify the workers that should reply to the request:"
msgstr ""

#: ../../userguide/workers.rst:734
msgid ""
"This can also be done programmatically by using the "
":meth:`@control.inspect.active_queues` method:"
msgstr ""

#: ../../userguide/workers.rst:748
msgid "Inspecting workers"
msgstr ""

#: ../../userguide/workers.rst:750
msgid ""
":class:`@control.inspect` lets you inspect running workers. It uses "
"remote control commands under the hood."
msgstr ""

#: ../../userguide/workers.rst:753
msgid ""
"You can also use the ``celery`` command to inspect workers, and it "
"supports the same commands as the :class:`@control` interface."
msgstr ""

#: ../../userguide/workers.rst:771
msgid "Dump of registered tasks"
msgstr ""

#: ../../userguide/workers.rst:773
msgid ""
"You can get a list of tasks registered in the worker using the "
":meth:`~@control.inspect.registered`:"
msgstr ""

#: ../../userguide/workers.rst:785
msgid "Dump of currently executing tasks"
msgstr ""

#: ../../userguide/workers.rst:787
msgid "You can get a list of active tasks using :meth:`~@control.inspect.active`:"
msgstr ""

#: ../../userguide/workers.rst:802
msgid "Dump of scheduled (ETA) tasks"
msgstr ""

#: ../../userguide/workers.rst:804
msgid ""
"You can get a list of tasks waiting to be scheduled by using "
":meth:`~@control.inspect.scheduled`:"
msgstr ""

#: ../../userguide/workers.rst:826
msgid "These are tasks with an ETA/countdown argument, not periodic tasks."
msgstr ""

#: ../../userguide/workers.rst:831
msgid "Dump of reserved tasks"
msgstr ""

#: ../../userguide/workers.rst:833
msgid ""
"Reserved tasks are tasks that have been received, but are still waiting "
"to be executed."
msgstr ""

#: ../../userguide/workers.rst:836
msgid "You can get a list of these using :meth:`~@control.inspect.reserved`:"
msgstr ""

#: ../../userguide/workers.rst:852
msgid "Statistics"
msgstr ""

#: ../../userguide/workers.rst:854
msgid ""
"The remote control command ``inspect stats`` (or "
":meth:`~@control.inspect.stats`) will give you a long list of useful (or "
"not so useful) statistics about the worker:"
msgstr ""

#: ../../userguide/workers.rst:862
msgid "The output will include the following fields:"
msgstr ""

#: ../../userguide/workers.rst:864
msgid "``broker``"
msgstr ""

#: ../../userguide/workers.rst:866
msgid "Section for broker information."
msgstr ""

#: ../../userguide/workers.rst:868
msgid "``connect_timeout``"
msgstr ""

#: ../../userguide/workers.rst:870
msgid "Timeout in seconds (int/float) for establishing a new connection."
msgstr ""

#: ../../userguide/workers.rst:872
msgid "``heartbeat``"
msgstr ""

#: ../../userguide/workers.rst:874
msgid "Current heartbeat value (set by client)."
msgstr ""

#: ../../userguide/workers.rst:876
msgid "``hostname``"
msgstr ""

#: ../../userguide/workers.rst:878
msgid "Node name of the remote broker."
msgstr ""

#: ../../userguide/workers.rst:880
msgid "``insist``"
msgstr ""

#: ../../userguide/workers.rst:882
msgid "No longer used."
msgstr ""

#: ../../userguide/workers.rst:884
msgid "``login_method``"
msgstr ""

#: ../../userguide/workers.rst:886
msgid "Login method used to connect to the broker."
msgstr ""

#: ../../userguide/workers.rst:890
msgid "Port of the remote broker."
msgstr ""

#: ../../userguide/workers.rst:892
msgid "``ssl``"
msgstr ""

#: ../../userguide/workers.rst:894
msgid "SSL enabled/disabled."
msgstr ""

#: ../../userguide/workers.rst:896
msgid "``transport``"
msgstr ""

#: ../../userguide/workers.rst:898
msgid "Name of transport used (e.g., ``amqp`` or ``redis``)"
msgstr ""

#: ../../userguide/workers.rst:900
msgid "``transport_options``"
msgstr ""

#: ../../userguide/workers.rst:902
msgid "Options passed to transport."
msgstr ""

#: ../../userguide/workers.rst:904
msgid "``uri_prefix``"
msgstr ""

#: ../../userguide/workers.rst:906
msgid "Some transports expects the host name to be a URL."
msgstr ""

#: ../../userguide/workers.rst:912
msgid "In this example the URI-prefix will be ``redis``."
msgstr ""

#: ../../userguide/workers.rst:914
msgid "``userid``"
msgstr ""

#: ../../userguide/workers.rst:916
msgid "User id used to connect to the broker with."
msgstr ""

#: ../../userguide/workers.rst:918
msgid "``virtual_host``"
msgstr ""

#: ../../userguide/workers.rst:920
msgid "Virtual host used."
msgstr ""

#: ../../userguide/workers.rst:922
msgid "``clock``"
msgstr ""

#: ../../userguide/workers.rst:924
msgid ""
"Value of the workers logical clock. This is a positive integer and should"
" be increasing every time you receive statistics."
msgstr ""

#: ../../userguide/workers.rst:929
msgid "Process id of the worker instance (Main process)."
msgstr ""

#: ../../userguide/workers.rst:931
msgid "``pool``"
msgstr ""

#: ../../userguide/workers.rst:933
msgid "Pool-specific section."
msgstr ""

#: ../../userguide/workers.rst:935
msgid "``max-concurrency``"
msgstr ""

#: ../../userguide/workers.rst:937
msgid "Max number of processes/threads/green threads."
msgstr ""

#: ../../userguide/workers.rst:939
msgid "``max-tasks-per-child``"
msgstr ""

#: ../../userguide/workers.rst:941
msgid "Max number of tasks a thread may execute before being recycled."
msgstr ""

#: ../../userguide/workers.rst:943
msgid "``processes``"
msgstr ""

#: ../../userguide/workers.rst:945
msgid "List of PIDs (or thread-id's)."
msgstr ""

#: ../../userguide/workers.rst:947
msgid "``put-guarded-by-semaphore``"
msgstr ""

#: ../../userguide/workers.rst:949
msgid "Internal"
msgstr ""

#: ../../userguide/workers.rst:951
msgid "``timeouts``"
msgstr ""

#: ../../userguide/workers.rst:953
msgid "Default values for time limits."
msgstr ""

#: ../../userguide/workers.rst:955
msgid "``writes``"
msgstr ""

#: ../../userguide/workers.rst:957
msgid ""
"Specific to the prefork pool, this shows the distribution of writes to "
"each process in the pool when using async I/O."
msgstr ""

#: ../../userguide/workers.rst:960
msgid "``prefetch_count``"
msgstr ""

#: ../../userguide/workers.rst:962
msgid "Current prefetch count value for the task consumer."
msgstr ""

#: ../../userguide/workers.rst:964
msgid "``rusage``"
msgstr ""

#: ../../userguide/workers.rst:966
msgid ""
"System usage statistics. The fields available may be different on your "
"platform."
msgstr ""

#: ../../userguide/workers.rst:969
msgid "From :manpage:`getrusage(2)`:"
msgstr ""

#: ../../userguide/workers.rst:971
msgid "``stime``"
msgstr ""

#: ../../userguide/workers.rst:973
msgid "Time spent in operating system code on behalf of this process."
msgstr ""

#: ../../userguide/workers.rst:975
msgid "``utime``"
msgstr ""

#: ../../userguide/workers.rst:977
msgid "Time spent executing user instructions."
msgstr ""

#: ../../userguide/workers.rst:979
msgid "``maxrss``"
msgstr ""

#: ../../userguide/workers.rst:981
msgid "The maximum resident size used by this process (in kilobytes)."
msgstr ""

#: ../../userguide/workers.rst:983
msgid "``idrss``"
msgstr ""

#: ../../userguide/workers.rst:985
msgid ""
"Amount of non-shared memory used for data (in kilobytes times ticks of "
"execution)"
msgstr ""

#: ../../userguide/workers.rst:988
msgid "``isrss``"
msgstr ""

#: ../../userguide/workers.rst:990
msgid ""
"Amount of non-shared memory used for stack space (in kilobytes times "
"ticks of execution)"
msgstr ""

#: ../../userguide/workers.rst:993
msgid "``ixrss``"
msgstr ""

#: ../../userguide/workers.rst:995
msgid ""
"Amount of memory shared with other processes (in kilobytes times ticks of"
" execution)."
msgstr ""

#: ../../userguide/workers.rst:998
msgid "``inblock``"
msgstr ""

#: ../../userguide/workers.rst:1000
msgid ""
"Number of times the file system had to read from the disk on behalf of "
"this process."
msgstr ""

#: ../../userguide/workers.rst:1003
msgid "``oublock``"
msgstr ""

#: ../../userguide/workers.rst:1005
msgid ""
"Number of times the file system has to write to disk on behalf of this "
"process."
msgstr ""

#: ../../userguide/workers.rst:1008
msgid "``majflt``"
msgstr ""

#: ../../userguide/workers.rst:1010
msgid "Number of page faults that were serviced by doing I/O."
msgstr ""

#: ../../userguide/workers.rst:1012
msgid "``minflt``"
msgstr ""

#: ../../userguide/workers.rst:1014
msgid "Number of page faults that were serviced without doing I/O."
msgstr ""

#: ../../userguide/workers.rst:1016
msgid "``msgrcv``"
msgstr ""

#: ../../userguide/workers.rst:1018
msgid "Number of IPC messages received."
msgstr ""

#: ../../userguide/workers.rst:1020
msgid "``msgsnd``"
msgstr ""

#: ../../userguide/workers.rst:1022
msgid "Number of IPC messages sent."
msgstr ""

#: ../../userguide/workers.rst:1024
msgid "``nvcsw``"
msgstr ""

#: ../../userguide/workers.rst:1026
msgid "Number of times this process voluntarily invoked a context switch."
msgstr ""

#: ../../userguide/workers.rst:1028
msgid "``nivcsw``"
msgstr ""

#: ../../userguide/workers.rst:1030
msgid "Number of times an involuntary context switch took place."
msgstr ""

#: ../../userguide/workers.rst:1032
msgid "``nsignals``"
msgstr ""

#: ../../userguide/workers.rst:1034
msgid "Number of signals received."
msgstr ""

#: ../../userguide/workers.rst:1036
msgid "``nswap``"
msgstr ""

#: ../../userguide/workers.rst:1038
msgid "The number of times this process was swapped entirely out of memory."
msgstr ""

#: ../../userguide/workers.rst:1041
msgid "``total``"
msgstr ""

#: ../../userguide/workers.rst:1043
msgid ""
"Map of task names and the total number of tasks with that type the worker"
" has accepted since start-up."
msgstr ""

#: ../../userguide/workers.rst:1048
msgid "Additional Commands"
msgstr ""

#: ../../userguide/workers.rst:1053
msgid "Remote shutdown"
msgstr ""

#: ../../userguide/workers.rst:1055
msgid "This command will gracefully shut down the worker remotely:"
msgstr ""

#: ../../userguide/workers.rst:1065
msgid "Ping"
msgstr ""

#: ../../userguide/workers.rst:1067
msgid ""
"This command requests a ping from alive workers. The workers reply with "
"the string 'pong', and that's just about it. It will use the default one "
"second timeout for replies unless you specify a custom timeout:"
msgstr ""

#: ../../userguide/workers.rst:1079
msgid ""
":meth:`~@control.ping` also supports the `destination` argument, so you "
"can specify the workers to ping:"
msgstr ""

#: ../../userguide/workers.rst:1094
msgid "Enable/disable events"
msgstr ""

#: ../../userguide/workers.rst:1096
msgid ""
"You can enable/disable events by using the `enable_events`, "
"`disable_events` commands. This is useful to temporarily monitor a worker"
" using :program:`celery events`/:program:`celerymon`."
msgstr ""

#: ../../userguide/workers.rst:1108
msgid "Writing your own remote control commands"
msgstr ""

#: ../../userguide/workers.rst:1110
msgid "There are two types of remote control commands:"
msgstr ""

#: ../../userguide/workers.rst:1112
msgid "Inspect command"
msgstr ""

#: ../../userguide/workers.rst:1114
msgid ""
"Does not have side effects, will usually just return some value found in "
"the worker, like the list of currently registered tasks, the list of "
"active tasks, etc."
msgstr ""

#: ../../userguide/workers.rst:1118
msgid "Control command"
msgstr ""

#: ../../userguide/workers.rst:1120
msgid "Performs side effects, like adding a new queue to consume from."
msgstr ""

#: ../../userguide/workers.rst:1122
msgid ""
"Remote control commands are registered in the control panel and they take"
" a single argument: the current "
":class:`~celery.worker.control.ControlDispatch` instance. From there you "
"have access to the active :class:`~celery.worker.consumer.Consumer` if "
"needed."
msgstr ""

#: ../../userguide/workers.rst:1128
msgid "Here's an example control command that increments the task prefetch count:"
msgstr ""

#: ../../userguide/workers.rst:1142
msgid ""
"Make sure you add this code to a module that is imported by the worker: "
"this could be the same module as where your Celery app is defined, or you"
" can add the module to the :setting:`imports` setting."
msgstr ""

#: ../../userguide/workers.rst:1146
msgid ""
"Restart the worker so that the control command is registered, and now you"
" can call your command using the :program:`celery control` utility:"
msgstr ""

#: ../../userguide/workers.rst:1153
msgid ""
"You can also add actions to the :program:`celery inspect` program, for "
"example one that reads the current prefetch count:"
msgstr ""

#: ../../userguide/workers.rst:1165
msgid ""
"After restarting the worker you can now query this value using the "
":program:`celery inspect` program:"
msgstr ""

