# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2009-2018, Ask Solem & contributors
# This file is distributed under the same license as the Celery package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Celery 4.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-22 13:44+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../userguide/tasks.rst:5
msgid "Tasks"
msgstr ""

#: ../../userguide/tasks.rst:7
msgid "Tasks are the building blocks of Celery applications."
msgstr ""

#: ../../userguide/tasks.rst:9
msgid ""
"A task is a class that can be created out of any callable. It performs "
"dual roles in that it defines both what happens when a task is called "
"(sends a message), and what happens when a worker receives that message."
msgstr ""

#: ../../userguide/tasks.rst:13
msgid ""
"Every task class has a unique name, and this name is referenced in "
"messages so the worker can find the right function to execute."
msgstr ""

#: ../../userguide/tasks.rst:16
msgid ""
"A task message is not removed from the queue until that message has been "
":term:`acknowledged` by a worker. A worker can reserve many messages in "
"advance and even if the worker is killed -- by power failure or some "
"other reason -- the message will be redelivered to another worker."
msgstr ""

#: ../../userguide/tasks.rst:21
msgid ""
"Ideally task functions should be :term:`idempotent`: meaning the function"
" won't cause unintended effects even if called multiple times with the "
"same arguments. Since the worker cannot detect if your tasks are "
"idempotent, the default behavior is to acknowledge the message in "
"advance, just before it's executed, so that a task invocation that "
"already started is never executed again."
msgstr ""

#: ../../userguide/tasks.rst:28
msgid ""
"If your task is idempotent you can set the :attr:`~Task.acks_late` option"
" to have the worker acknowledge the message *after* the task returns "
"instead. See also the FAQ entry :ref:`faq-acks_late-vs-retry`."
msgstr ""

#: ../../userguide/tasks.rst:32
msgid ""
"Note that the worker will acknowledge the message if the child process "
"executing the task is terminated (either by the task calling "
":func:`sys.exit`, or by signal) even when :attr:`~Task.acks_late` is "
"enabled.  This behavior is by purpose as..."
msgstr ""

#: ../../userguide/tasks.rst:37
msgid ""
"We don't want to rerun tasks that forces the kernel to send a "
":sig:`SIGSEGV` (segmentation fault) or similar signals to the process."
msgstr ""

#: ../../userguide/tasks.rst:39
msgid ""
"We assume that a system administrator deliberately killing the task does "
"not want it to automatically restart."
msgstr ""

#: ../../userguide/tasks.rst:41
msgid ""
"A task that allocates too much memory is in danger of triggering the "
"kernel OOM killer, the same may happen again."
msgstr ""

#: ../../userguide/tasks.rst:43
msgid ""
"A task that always fails when redelivered may cause a high-frequency "
"message loop taking down the system."
msgstr ""

#: ../../userguide/tasks.rst:46
msgid ""
"If you really want a task to be redelivered in these scenarios you should"
" consider enabling the :setting:`task_reject_on_worker_lost` setting."
msgstr ""

#: ../../userguide/tasks.rst:51
msgid ""
"A task that blocks indefinitely may eventually stop the worker instance "
"from doing any other work."
msgstr ""

#: ../../userguide/tasks.rst:54
msgid ""
"If your task does I/O then make sure you add timeouts to these "
"operations, like adding a timeout to a web request using the "
":pypi:`requests` library:"
msgstr ""

#: ../../userguide/tasks.rst:62
msgid ""
":ref:`Time limits <worker-time-limits>` are convenient for making sure "
"all tasks return in a timely manner, but a time limit event will actually"
" kill the process by force so only use them to detect cases where you "
"haven't used manual timeouts yet."
msgstr ""

#: ../../userguide/tasks.rst:67
msgid ""
"The default prefork pool scheduler is not friendly to long-running tasks,"
" so if you have tasks that run for minutes/hours make sure you enable the"
" :option:`-Ofair <celery worker -O>` command-line argument to the "
":program:`celery worker`. See :ref:`prefork-pool-prefetch` for more "
"information, and for the best performance route long-running and short-"
"running tasks to dedicated workers (:ref:`routing-automatic`)."
msgstr ""

#: ../../userguide/tasks.rst:74
msgid ""
"If your worker hangs then please investigate what tasks are running "
"before submitting an issue, as most likely the hanging is caused by one "
"or more tasks hanging on a network operation."
msgstr ""

#: ../../userguide/tasks.rst:78
msgid "--"
msgstr ""

#: ../../userguide/tasks.rst:80
msgid ""
"In this chapter you'll learn all about defining tasks, and this is the "
"**table of contents**:"
msgstr ""

#: ../../userguide/tasks.rst:91
msgid "Basics"
msgstr ""

#: ../../userguide/tasks.rst:93
msgid ""
"You can easily create a task from any callable by using the "
":meth:`~@task` decorator:"
msgstr ""

#: ../../userguide/tasks.rst:105
msgid ""
"There are also many :ref:`options <task-options>` that can be set for the"
" task, these can be specified as arguments to the decorator:"
msgstr ""

#: ../../userguide/tasks.rst:117
msgid ""
"The task decorator is available on your :class:`@Celery` application "
"instance, if you don't know what this is then please read :ref:`first-"
"steps`."
msgstr ""

#: ../../userguide/tasks.rst:120
msgid ""
"If you're using Django (see :ref:`django-first-steps`), or you're the "
"author of a library then you probably want to use the "
":func:`@shared_task` decorator:"
msgstr ""

#: ../../userguide/tasks.rst:133
msgid ""
"When using multiple decorators in combination with the task decorator you"
" must make sure that the `task` decorator is applied last (oddly, in "
"Python this means it must be first in the list):"
msgstr ""

#: ../../userguide/tasks.rst:147
msgid "Bound tasks"
msgstr ""

#: ../../userguide/tasks.rst:149
msgid ""
"A task being bound means the first argument to the task will always be "
"the task instance (``self``), just like Python bound methods:"
msgstr ""

#: ../../userguide/tasks.rst:160
msgid ""
"Bound tasks are needed for retries (using :meth:`Task.retry() "
"<@Task.retry>`), for accessing information about the current task "
"request, and for any additional functionality you add to custom task base"
" classes."
msgstr ""

#: ../../userguide/tasks.rst:165
msgid "Task inheritance"
msgstr ""

#: ../../userguide/tasks.rst:167
msgid ""
"The ``base`` argument to the task decorator specifies the base class of "
"the task:"
msgstr ""

#: ../../userguide/tasks.rst:185
msgid "Names"
msgstr ""

#: ../../userguide/tasks.rst:187
msgid "Every task must have a unique name."
msgstr ""

#: ../../userguide/tasks.rst:189
msgid ""
"If no explicit name is provided the task decorator will generate one for "
"you, and this name will be based on 1) the module the task is defined in,"
" and 2) the name of the task function."
msgstr ""

#: ../../userguide/tasks.rst:193
msgid "Example setting explicit name:"
msgstr ""

#: ../../userguide/tasks.rst:204
msgid ""
"A best practice is to use the module name as a name-space, this way names"
" won't collide if there's already a task with that name defined in "
"another module."
msgstr ""

#: ../../userguide/tasks.rst:214
msgid ""
"You can tell the name of the task by investigating its ``.name`` "
"attribute:"
msgstr ""

#: ../../userguide/tasks.rst:221
msgid ""
"The name we specified here (``tasks.add``) is exactly the name that "
"would've been automatically generated for us if the task was defined in a"
" module named :file:`tasks.py`:"
msgstr ""

#: ../../userguide/tasks.rst:225
msgid ":file:`tasks.py`:"
msgstr ""

#: ../../userguide/tasks.rst:242
msgid "Automatic naming and relative imports"
msgstr ""

msgid "Absolute Imports"
msgstr ""

#: ../../userguide/tasks.rst:246
msgid ""
"The best practice for developers targeting Python 2 is to add the "
"following to the top of **every module**:"
msgstr ""

#: ../../userguide/tasks.rst:253
msgid ""
"This will force you to always use absolute imports so you will never have"
" any problems with tasks using relative names."
msgstr ""

#: ../../userguide/tasks.rst:256
msgid ""
"Absolute imports are the default in Python 3 so you don't need this if "
"you target that version."
msgstr ""

#: ../../userguide/tasks.rst:259
msgid ""
"Relative imports and automatic name generation don't go well together, so"
" if you're using relative imports you should set the name explicitly."
msgstr ""

#: ../../userguide/tasks.rst:262
msgid ""
"For example if the client imports the module ``\"myapp.tasks\"`` as "
"``\".tasks\"``, and the worker imports the module as ``\"myapp.tasks\"``,"
" the generated names won't match and an :exc:`~@NotRegistered` error will"
" be raised by the worker."
msgstr ""

#: ../../userguide/tasks.rst:267
msgid ""
"This is also the case when using Django and using ``project.myapp``-style"
" naming in ``INSTALLED_APPS``:"
msgstr ""

#: ../../userguide/tasks.rst:274
msgid ""
"If you install the app under the name ``project.myapp`` then the tasks "
"module will be imported as ``project.myapp.tasks``, so you must make sure"
" you always import the tasks using the same name:"
msgstr ""

#: ../../userguide/tasks.rst:284
msgid ""
"The second example will cause the task to be named differently since the "
"worker and the client imports the modules under different names:"
msgstr ""

#: ../../userguide/tasks.rst:297
msgid ""
"For this reason you must be consistent in how you import modules, and "
"that is also a Python best practice."
msgstr ""

#: ../../userguide/tasks.rst:300
msgid "Similarly, you shouldn't use old-style relative imports:"
msgstr ""

#: ../../userguide/tasks.rst:308
msgid "New-style relative imports are fine and can be used:"
msgstr ""

#: ../../userguide/tasks.rst:314
msgid ""
"If you want to use Celery with a project already using these patterns "
"extensively and you don't have the time to refactor the existing code "
"then you can consider specifying the names explicitly instead of relying "
"on the automatic naming:"
msgstr ""

#: ../../userguide/tasks.rst:328
msgid "Changing the automatic naming behavior"
msgstr ""

#: ../../userguide/tasks.rst:332
msgid ""
"There are some cases when the default automatic naming isn't suitable. "
"Consider having many tasks within many different modules::"
msgstr ""

#: ../../userguide/tasks.rst:345
msgid ""
"Using the default automatic naming, each task will have a generated name "
"like `moduleA.tasks.taskA`, `moduleA.tasks.taskB`, `moduleB.tasks.test`, "
"and so on. You may want to get rid of having `tasks` in all task names. "
"As pointed above, you can explicitly give names for all tasks, or you can"
" change the automatic naming behavior by overriding "
":meth:`@gen_task_name`. Continuing with the example, `celery.py` may "
"contain:"
msgstr ""

#: ../../userguide/tasks.rst:366
msgid ""
"So each task will have a name like `moduleA.taskA`, `moduleA.taskB` and "
"`moduleB.test`."
msgstr ""

#: ../../userguide/tasks.rst:371
msgid ""
"Make sure that your :meth:`@gen_task_name` is a pure function: meaning "
"that for the same input it must always return the same output."
msgstr ""

#: ../../userguide/tasks.rst:377
msgid "Task Request"
msgstr ""

#: ../../userguide/tasks.rst:379
msgid ""
":attr:`Task.request <@Task.request>` contains information and state "
"related to the currently executing task."
msgstr ""

#: ../../userguide/tasks.rst:382
msgid "The request defines the following attributes:"
msgstr ""

#: ../../userguide/tasks.rst
msgid "id"
msgstr ""

#: ../../userguide/tasks.rst:384
msgid "The unique id of the executing task."
msgstr ""

#: ../../userguide/tasks.rst
msgid "group"
msgstr ""

#: ../../userguide/tasks.rst:386
msgid ""
"The unique id of the task's :ref:`group <canvas-group>`, if this task is "
"a member."
msgstr ""

#: ../../userguide/tasks.rst
msgid "chord"
msgstr ""

#: ../../userguide/tasks.rst:388
msgid ""
"The unique id of the chord this task belongs to (if the task is part of "
"the header)."
msgstr ""

#: ../../userguide/tasks.rst
msgid "correlation_id"
msgstr ""

#: ../../userguide/tasks.rst:391
msgid "Custom ID used for things like de-duplication."
msgstr ""

#: ../../userguide/tasks.rst
msgid "args"
msgstr ""

#: ../../userguide/tasks.rst:393
msgid "Positional arguments."
msgstr ""

#: ../../userguide/tasks.rst
msgid "kwargs"
msgstr ""

#: ../../userguide/tasks.rst:395
msgid "Keyword arguments."
msgstr ""

#: ../../userguide/tasks.rst
msgid "origin"
msgstr ""

#: ../../userguide/tasks.rst:397
msgid "Name of host that sent this task."
msgstr ""

#: ../../userguide/tasks.rst
msgid "retries"
msgstr ""

#: ../../userguide/tasks.rst:399
msgid ""
"How many times the current task has been retried. An integer starting at "
"`0`."
msgstr ""

#: ../../userguide/tasks.rst
msgid "is_eager"
msgstr ""

#: ../../userguide/tasks.rst:402
msgid ""
"Set to :const:`True` if the task is executed locally in the client, not "
"by a worker."
msgstr ""

#: ../../userguide/tasks.rst
msgid "eta"
msgstr ""

#: ../../userguide/tasks.rst:405
msgid ""
"The original ETA of the task (if any). This is in UTC time (depending on "
"the :setting:`enable_utc` setting)."
msgstr ""

#: ../../userguide/tasks.rst
msgid "expires"
msgstr ""

#: ../../userguide/tasks.rst:409
msgid ""
"The original expiry time of the task (if any). This is in UTC time "
"(depending on the :setting:`enable_utc` setting)."
msgstr ""

#: ../../userguide/tasks.rst
msgid "hostname"
msgstr ""

#: ../../userguide/tasks.rst:413
msgid "Node name of the worker instance executing the task."
msgstr ""

#: ../../userguide/tasks.rst
msgid "delivery_info"
msgstr ""

#: ../../userguide/tasks.rst:415
msgid ""
"Additional message delivery information. This is a mapping containing the"
" exchange and routing key used to deliver this task. Used by for example "
":meth:`Task.retry() <@Task.retry>` to resend the task to the same "
"destination queue. Availability of keys in this dict depends on the "
"message broker used."
msgstr ""

#: ../../userguide/tasks.rst
msgid "reply-to"
msgstr ""

#: ../../userguide/tasks.rst:422
msgid ""
"Name of queue to send replies back to (used with RPC result backend for "
"example)."
msgstr ""

#: ../../userguide/tasks.rst
msgid "called_directly"
msgstr ""

#: ../../userguide/tasks.rst:425
msgid "This flag is set to true if the task wasn't executed by the worker."
msgstr ""

#: ../../userguide/tasks.rst
msgid "timelimit"
msgstr ""

#: ../../userguide/tasks.rst:428
msgid ""
"A tuple of the current ``(soft, hard)`` time limits active for this task "
"(if any)."
msgstr ""

#: ../../userguide/tasks.rst
msgid "callbacks"
msgstr ""

#: ../../userguide/tasks.rst:431
msgid "A list of signatures to be called if this task returns successfully."
msgstr ""

#: ../../userguide/tasks.rst
msgid "errback"
msgstr ""

#: ../../userguide/tasks.rst:433
msgid "A list of signatures to be called if this task fails."
msgstr ""

#: ../../userguide/tasks.rst
msgid "utc"
msgstr ""

#: ../../userguide/tasks.rst:435
msgid "Set to true the caller has UTC enabled (:setting:`enable_utc`)."
msgstr ""

#: ../../userguide/tasks.rst
msgid "headers"
msgstr ""

#: ../../userguide/tasks.rst:440
msgid ""
"Mapping of message headers sent with this task message (may be "
":const:`None`)."
msgstr ""

#: ../../userguide/tasks.rst
msgid "reply_to"
msgstr ""

#: ../../userguide/tasks.rst:443
msgid "Where to send reply to (queue name)."
msgstr ""

#: ../../userguide/tasks.rst:445
msgid ""
"Usually the same as the task id, often used in amqp to keep track of what"
" a reply is for."
msgstr ""

#: ../../userguide/tasks.rst
msgid "root_id"
msgstr ""

#: ../../userguide/tasks.rst:450
msgid ""
"The unique id of the first task in the workflow this task is part of (if "
"any)."
msgstr ""

#: ../../userguide/tasks.rst
msgid "parent_id"
msgstr ""

#: ../../userguide/tasks.rst:453
msgid "The unique id of the task that called this task (if any)."
msgstr ""

#: ../../userguide/tasks.rst
msgid "chain"
msgstr ""

#: ../../userguide/tasks.rst:455
msgid ""
"Reversed list of tasks that form a chain (if any). The last item in this "
"list will be the next task to succeed the current task.  If using version"
" one of the task protocol the chain tasks will be in "
"``request.callbacks`` instead."
msgstr ""

#: ../../userguide/tasks.rst:461 ../../userguide/tasks.rst:1948
msgid "Example"
msgstr ""

#: ../../userguide/tasks.rst:463
msgid "An example task accessing information in the context is:"
msgstr ""

#: ../../userguide/tasks.rst:473
msgid ""
"The ``bind`` argument means that the function will be a \"bound method\" "
"so that you can access attributes and methods on the task type instance."
msgstr ""

#: ../../userguide/tasks.rst:479
msgid "Logging"
msgstr ""

#: ../../userguide/tasks.rst:481
msgid ""
"The worker will automatically set up logging for you, or you can "
"configure logging manually."
msgstr ""

#: ../../userguide/tasks.rst:484
msgid ""
"A special logger is available named \"celery.task\", you can inherit from"
" this logger to automatically get the task name and unique id as part of "
"the logs."
msgstr ""

#: ../../userguide/tasks.rst:488
msgid ""
"The best practice is to create a common logger for all of your tasks at "
"the top of your module:"
msgstr ""

#: ../../userguide/tasks.rst:502
msgid ""
"Celery uses the standard Python logger library, and the documentation can"
" be found :mod:`here <logging>`."
msgstr ""

#: ../../userguide/tasks.rst:505
msgid ""
"You can also use :func:`print`, as anything written to standard out/-err "
"will be redirected to the logging system (you can disable this, see "
":setting:`worker_redirect_stdouts`)."
msgstr ""

#: ../../userguide/tasks.rst:511
msgid ""
"The worker won't update the redirection if you create a logger instance "
"somewhere in your task or task module."
msgstr ""

#: ../../userguide/tasks.rst:514
msgid ""
"If you want to redirect ``sys.stdout`` and ``sys.stderr`` to a custom "
"logger you have to enable this manually, for example:"
msgstr ""

#: ../../userguide/tasks.rst:537
msgid ""
"If a specific Celery logger you need is not emitting logs, you should "
"check that the logger is propagating properly. In this example "
"\"celery.app.trace\" is enabled so that \"succeeded in\" logs are "
"emitted:"
msgstr ""

#: ../../userguide/tasks.rst:558
msgid "Argument checking"
msgstr ""

#: ../../userguide/tasks.rst:562
msgid ""
"Celery will verify the arguments passed when you call the task, just like"
" Python does when calling a normal function:"
msgstr ""

#: ../../userguide/tasks.rst:585
msgid ""
"You can disable the argument checking for any task by setting its "
":attr:`~@Task.typing` attribute to :const:`False`:"
msgstr ""

#: ../../userguide/tasks.rst:601
msgid "Hiding sensitive information in arguments"
msgstr ""

#: ../../userguide/tasks.rst:605
msgid ""
"When using :setting:`task_protocol` 2 or higher (default since 4.0), you "
"can override how positional arguments and keyword arguments are "
"represented in logs and monitoring events using the ``argsrepr`` and "
"``kwargsrepr`` calling arguments:"
msgstr ""

#: ../../userguide/tasks.rst:621
msgid ""
"Sensitive information will still be accessible to anyone able to read "
"your task message from the broker, or otherwise able intercept it."
msgstr ""

#: ../../userguide/tasks.rst:624
msgid ""
"For this reason you should probably encrypt your message if it contains "
"sensitive information, or in this example with a credit card number the "
"actual number could be stored encrypted in a secure store that you "
"retrieve and decrypt in the task itself."
msgstr ""

#: ../../userguide/tasks.rst:632
msgid "Retrying"
msgstr ""

#: ../../userguide/tasks.rst:634
msgid ""
":meth:`Task.retry() <@Task.retry>` can be used to re-execute the task, "
"for example in the event of recoverable errors."
msgstr ""

#: ../../userguide/tasks.rst:637
msgid ""
"When you call ``retry`` it'll send a new message, using the same task-id,"
" and it'll take care to make sure the message is delivered to the same "
"queue as the originating task."
msgstr ""

#: ../../userguide/tasks.rst:641
msgid ""
"When a task is retried this is also recorded as a task state, so that you"
" can track the progress of the task using the result instance (see :ref"
":`task-states`)."
msgstr ""

#: ../../userguide/tasks.rst:645
msgid "Here's an example using ``retry``:"
msgstr ""

#: ../../userguide/tasks.rst:659
msgid ""
"The :meth:`Task.retry() <@Task.retry>` call will raise an exception so "
"any code after the retry won't be reached. This is the :exc:`~@Retry` "
"exception, it isn't handled as an error but rather as a semi-predicate to"
" signify to the worker that the task is to be retried, so that it can "
"store the correct state when a result backend is enabled."
msgstr ""

#: ../../userguide/tasks.rst:665
msgid ""
"This is normal operation and always happens unless the ``throw`` argument"
" to retry is set to :const:`False`."
msgstr ""

#: ../../userguide/tasks.rst:668
msgid ""
"The bind argument to the task decorator will give access to ``self`` (the"
" task type instance)."
msgstr ""

#: ../../userguide/tasks.rst:671
msgid ""
"The ``exc`` argument is used to pass exception information that's used in"
" logs, and when storing task results. Both the exception and the "
"traceback will be available in the task state (if a result backend is "
"enabled)."
msgstr ""

#: ../../userguide/tasks.rst:676
msgid ""
"If the task has a ``max_retries`` value the current exception will be re-"
"raised if the max number of retries has been exceeded, but this won't "
"happen if:"
msgstr ""

#: ../../userguide/tasks.rst:680
msgid "An ``exc`` argument wasn't given."
msgstr ""

#: ../../userguide/tasks.rst:682
msgid ""
"In this case the :exc:`~@MaxRetriesExceededError` exception will be "
"raised."
msgstr ""

#: ../../userguide/tasks.rst:685
msgid "There's no current exception"
msgstr ""

#: ../../userguide/tasks.rst:687
msgid ""
"If there's no original exception to re-raise the ``exc`` argument will be"
" used instead, so:"
msgstr ""

#: ../../userguide/tasks.rst:694
msgid "will raise the ``exc`` argument given."
msgstr ""

#: ../../userguide/tasks.rst:699
msgid "Using a custom retry delay"
msgstr ""

#: ../../userguide/tasks.rst:701
msgid ""
"When a task is to be retried, it can wait for a given amount of time "
"before doing so, and the default delay is defined by the "
":attr:`~@Task.default_retry_delay` attribute. By default this is set to 3"
" minutes. Note that the unit for setting the delay is in seconds (int or "
"float)."
msgstr ""

#: ../../userguide/tasks.rst:707
msgid ""
"You can also provide the `countdown` argument to :meth:`~@Task.retry` to "
"override this default."
msgstr ""

#: ../../userguide/tasks.rst:723
msgid "Automatic retry for known exceptions"
msgstr ""

#: ../../userguide/tasks.rst:727
msgid ""
"Sometimes you just want to retry a task whenever a particular exception "
"is raised."
msgstr ""

#: ../../userguide/tasks.rst:730
msgid ""
"Fortunately, you can tell Celery to automatically retry a task using "
"`autoretry_for` argument in the :meth:`~@Celery.task` decorator:"
msgstr ""

#: ../../userguide/tasks.rst:741
msgid ""
"If you want to specify custom arguments for an internal "
":meth:`~@Task.retry` call, pass `retry_kwargs` argument to "
":meth:`~@Celery.task` decorator:"
msgstr ""

#: ../../userguide/tasks.rst:751
msgid ""
"This is provided as an alternative to manually handling the exceptions, "
"and the example above will do the same as wrapping the task body in a "
":keyword:`try` ... :keyword:`except` statement:"
msgstr ""

#: ../../userguide/tasks.rst:764
msgid "If you want to automatically retry on any error, simply use:"
msgstr ""

#: ../../userguide/tasks.rst:774
msgid ""
"If your tasks depend on another service, like making a request to an API,"
" then it's a good idea to use `exponential backoff`_ to avoid "
"overwhelming the service with your requests. Fortunately, Celery's "
"automatic retry support makes it easy. Just specify the "
":attr:`~Task.retry_backoff` argument, like this:"
msgstr ""

#: ../../userguide/tasks.rst:787
msgid ""
"By default, this exponential backoff will also introduce random jitter_ "
"to avoid having all the tasks run at the same moment. It will also cap "
"the maximum backoff delay to 10 minutes. All these settings can be "
"customized via options documented below."
msgstr ""

#: ../../userguide/tasks.rst:794
msgid ""
"A list/tuple of exception classes. If any of these exceptions are raised "
"during the execution of the task, the task will automatically be retried."
" By default, no exceptions will be autoretried."
msgstr ""

#: ../../userguide/tasks.rst:800
msgid ""
"A dictionary. Use this to customize how autoretries are executed. Note "
"that if you use the exponential backoff options below, the `countdown` "
"task option will be determined by Celery's autoretry system, and any "
"`countdown` included in this dictionary will be ignored."
msgstr ""

#: ../../userguide/tasks.rst:807
msgid ""
"A boolean, or a number. If this option is set to ``True``, autoretries "
"will be delayed following the rules of `exponential backoff`_. The first "
"retry will have a delay of 1 second, the second retry will have a delay "
"of 2 seconds, the third will delay 4 seconds, the fourth will delay 8 "
"seconds, and so on. (However, this delay value is modified by "
":attr:`~Task.retry_jitter`, if it is enabled.) If this option is set to a"
" number, it is used as a delay factor. For example, if this option is set"
" to ``3``, the first retry will delay 3 seconds, the second will delay 6 "
"seconds, the third will delay 12 seconds, the fourth will delay 24 "
"seconds, and so on. By default, this option is set to ``False``, and "
"autoretries will not be delayed."
msgstr ""

#: ../../userguide/tasks.rst:821
msgid ""
"A number. If ``retry_backoff`` is enabled, this option will set a maximum"
" delay in seconds between task autoretries. By default, this option is "
"set to ``600``, which is 10 minutes."
msgstr ""

#: ../../userguide/tasks.rst:827
msgid ""
"A boolean. `Jitter`_ is used to introduce randomness into exponential "
"backoff delays, to prevent all tasks in the queue from being executed "
"simultaneously. If this option is set to ``True``, the delay value "
"calculated by :attr:`~Task.retry_backoff` is treated as a maximum, and "
"the actual delay value will be a random number between zero and that "
"maximum. By default, this option is set to ``True``."
msgstr ""

#: ../../userguide/tasks.rst:837
msgid "List of Options"
msgstr ""

#: ../../userguide/tasks.rst:839
msgid ""
"The task decorator can take a number of options that change the way the "
"task behaves, for example you can set the rate limit for a task using the"
" :attr:`rate_limit` option."
msgstr ""

#: ../../userguide/tasks.rst:843
msgid ""
"Any keyword argument passed to the task decorator will actually be set as"
" an attribute of the resulting task class, and this is a list of the "
"built-in attributes."
msgstr ""

#: ../../userguide/tasks.rst:848
msgid "General"
msgstr ""

#: ../../userguide/tasks.rst:854
msgid "The name the task is registered as."
msgstr ""

#: ../../userguide/tasks.rst:856
msgid ""
"You can set this name manually, or a name will be automatically generated"
" using the module and class name."
msgstr ""

#: ../../userguide/tasks.rst:859
msgid "See also :ref:`task-names`."
msgstr ""

#: ../../userguide/tasks.rst:863
msgid ""
"If the task is being executed this will contain information about the "
"current request. Thread local storage is used."
msgstr ""

#: ../../userguide/tasks.rst:866
msgid "See :ref:`task-request-info`."
msgstr ""

#: ../../userguide/tasks.rst:870
msgid ""
"Only applies if the task calls ``self.retry`` or if the task is decorated"
" with the :ref:`autoretry_for <task-autoretry>` argument."
msgstr ""

#: ../../userguide/tasks.rst:873
msgid ""
"The maximum number of attempted retries before giving up. If the number "
"of retries exceeds this value a :exc:`~@MaxRetriesExceededError` "
"exception will be raised."
msgstr ""

#: ../../userguide/tasks.rst:879
msgid ""
"You have to call :meth:`~@Task.retry` manually, as it won't automatically"
" retry on exception.."
msgstr ""

#: ../../userguide/tasks.rst:882
msgid ""
"The default is ``3``. A value of :const:`None` will disable the retry "
"limit and the task will retry forever until it succeeds."
msgstr ""

#: ../../userguide/tasks.rst:888
msgid ""
"Optional tuple of expected error classes that shouldn't be regarded as an"
" actual error."
msgstr ""

#: ../../userguide/tasks.rst:891
msgid ""
"Errors in this list will be reported as a failure to the result backend, "
"but the worker won't log the event as an error, and no traceback will be "
"included."
msgstr ""

#: ../../userguide/tasks.rst:895
msgid "Example:"
msgstr ""

#: ../../userguide/tasks.rst:903
msgid "Error types:"
msgstr ""

#: ../../userguide/tasks.rst:905
msgid "Expected errors (in ``Task.throws``)"
msgstr ""

#: ../../userguide/tasks.rst:907
msgid "Logged with severity ``INFO``, traceback excluded."
msgstr ""

#: ../../userguide/tasks.rst:909
msgid "Unexpected errors"
msgstr ""

#: ../../userguide/tasks.rst:911
msgid "Logged with severity ``ERROR``, with traceback included."
msgstr ""

#: ../../userguide/tasks.rst:915
msgid ""
"Default time in seconds before a retry of the task should be executed. "
"Can be either :class:`int` or :class:`float`. Default is a three minute "
"delay."
msgstr ""

#: ../../userguide/tasks.rst:921
msgid ""
"Set the rate limit for this task type (limits the number of tasks that "
"can be run in a given time frame). Tasks will still complete when a rate "
"limit is in effect, but it may take some time before it's allowed to "
"start."
msgstr ""

#: ../../userguide/tasks.rst:926
msgid ""
"If this is :const:`None` no rate limit is in effect. If it is an integer "
"or float, it is interpreted as \"tasks per second\"."
msgstr ""

#: ../../userguide/tasks.rst:929
msgid ""
"The rate limits can be specified in seconds, minutes or hours by "
"appending `\"/s\"`, `\"/m\"` or `\"/h\"` to the value. Tasks will be "
"evenly distributed over the specified time frame."
msgstr ""

#: ../../userguide/tasks.rst:933
msgid ""
"Example: `\"100/m\"` (hundred tasks a minute). This will enforce a "
"minimum delay of 600ms between starting two tasks on the same worker "
"instance."
msgstr ""

#: ../../userguide/tasks.rst:936
msgid ""
"Default is the :setting:`task_default_rate_limit` setting: if not "
"specified means rate limiting for tasks is disabled by default."
msgstr ""

#: ../../userguide/tasks.rst:939
msgid ""
"Note that this is a *per worker instance* rate limit, and not a global "
"rate limit. To enforce a global rate limit (e.g., for an API with a "
"maximum number of  requests per second), you must restrict to a given "
"queue."
msgstr ""

#: ../../userguide/tasks.rst:946
msgid ""
"The hard time limit, in seconds, for this task. When not set the workers "
"default is used."
msgstr ""

#: ../../userguide/tasks.rst:951
msgid ""
"The soft time limit for this task. When not set the workers default is "
"used."
msgstr ""

#: ../../userguide/tasks.rst:956
msgid ""
"Don't store task state. Note that this means you can't use "
":class:`~celery.result.AsyncResult` to check if the task is ready, or get"
" its return value."
msgstr ""

#: ../../userguide/tasks.rst:962
msgid ""
"If :const:`True`, errors will be stored even if the task is configured to"
" ignore results."
msgstr ""

#: ../../userguide/tasks.rst:967
msgid ""
"A string identifying the default serialization method to use. Defaults to"
" the :setting:`task_serializer` setting. Can be `pickle`, `json`, `yaml`,"
" or any custom serialization methods that have been registered with "
":mod:`kombu.serialization.registry`."
msgstr ""

#: ../../userguide/tasks.rst:973
msgid "Please see :ref:`calling-serializers` for more information."
msgstr ""

#: ../../userguide/tasks.rst:977
msgid "A string identifying the default compression scheme to use."
msgstr ""

#: ../../userguide/tasks.rst:979
msgid ""
"Defaults to the :setting:`task_compression` setting. Can be `gzip`, or "
"`bzip2`, or any custom compression schemes that have been registered with"
" the :mod:`kombu.compression` registry."
msgstr ""

#: ../../userguide/tasks.rst:983
msgid "Please see :ref:`calling-compression` for more information."
msgstr ""

#: ../../userguide/tasks.rst:987
msgid ""
"The result store backend to use for this task. An instance of one of the "
"backend classes in `celery.backends`. Defaults to `app.backend`, defined "
"by the :setting:`result_backend` setting."
msgstr ""

#: ../../userguide/tasks.rst:993
msgid ""
"If set to :const:`True` messages for this task will be acknowledged "
"**after** the task has been executed, not *just before* (the default "
"behavior)."
msgstr ""

#: ../../userguide/tasks.rst:997
msgid ""
"Note: This means the task may be executed multiple times should the "
"worker crash in the middle of execution.  Make sure your tasks are "
":term:`idempotent`."
msgstr ""

#: ../../userguide/tasks.rst:1001
msgid ""
"The global default can be overridden by the :setting:`task_acks_late` "
"setting."
msgstr ""

#: ../../userguide/tasks.rst:1008
msgid ""
"If :const:`True` the task will report its status as \"started\" when the "
"task is executed by a worker. The default value is :const:`False` as the "
"normal behavior is to not report that level of granularity. Tasks are "
"either pending, finished, or waiting to be retried. Having a \"started\" "
"status can be useful for when there are long running tasks and there's a "
"need to report what task is currently running."
msgstr ""

#: ../../userguide/tasks.rst:1016
msgid ""
"The host name and process id of the worker executing the task will be "
"available in the state meta-data (e.g., `result.info['pid']`)"
msgstr ""

#: ../../userguide/tasks.rst:1019
msgid ""
"The global default can be overridden by the :setting:`task_track_started`"
" setting."
msgstr ""

#: ../../userguide/tasks.rst:1025
msgid "The API reference for :class:`~@Task`."
msgstr ""

#: ../../userguide/tasks.rst:1030
msgid "States"
msgstr ""

#: ../../userguide/tasks.rst:1032
msgid ""
"Celery can keep track of the tasks current state. The state also contains"
" the result of a successful task, or the exception and traceback "
"information of a failed task."
msgstr ""

#: ../../userguide/tasks.rst:1036
msgid ""
"There are several *result backends* to choose from, and they all have "
"different strengths and weaknesses (see :ref:`task-result-backends`)."
msgstr ""

#: ../../userguide/tasks.rst:1039
msgid ""
"During its lifetime a task will transition through several possible "
"states, and each state may have arbitrary meta-data attached to it. When "
"a task moves into a new state the previous state is forgotten about, but "
"some transitions can be deduced, (e.g., a task now in the :state:`FAILED`"
" state, is implied to have been in the :state:`STARTED` state at some "
"point)."
msgstr ""

#: ../../userguide/tasks.rst:1046
msgid ""
"There are also sets of states, like the set of :state:`FAILURE_STATES`, "
"and the set of :state:`READY_STATES`."
msgstr ""

#: ../../userguide/tasks.rst:1049
msgid ""
"The client uses the membership of these sets to decide whether the "
"exception should be re-raised (:state:`PROPAGATE_STATES`), or whether the"
" state can be cached (it can if the task is ready)."
msgstr ""

#: ../../userguide/tasks.rst:1053
msgid "You can also define :ref:`custom-states`."
msgstr ""

#: ../../userguide/tasks.rst:1058
msgid "Result Backends"
msgstr ""

#: ../../userguide/tasks.rst:1060
msgid ""
"If you want to keep track of tasks or need the return values, then Celery"
" must store or send the states somewhere so that they can be retrieved "
"later. There are several built-in result backends to choose from: "
"SQLAlchemy/Django ORM, Memcached, RabbitMQ/QPid (``rpc``), and Redis -- "
"or you can define your own."
msgstr ""

#: ../../userguide/tasks.rst:1065
msgid ""
"No backend works well for every use case. You should read about the "
"strengths and weaknesses of each backend, and choose the most appropriate"
" for your needs."
msgstr ""

#: ../../userguide/tasks.rst:1071
msgid ""
"Backends use resources to store and transmit results. To ensure that "
"resources are released, you must eventually call "
":meth:`~@AsyncResult.get` or :meth:`~@AsyncResult.forget` on EVERY "
":class:`~@AsyncResult` instance returned after calling a task."
msgstr ""

#: ../../userguide/tasks.rst:1079
msgid ":ref:`conf-result-backend`"
msgstr ""

#: ../../userguide/tasks.rst:1082
msgid "RPC Result Backend (RabbitMQ/QPid)"
msgstr ""

#: ../../userguide/tasks.rst:1084
msgid ""
"The RPC result backend (`rpc://`) is special as it doesn't actually "
"*store* the states, but rather sends them as messages. This is an "
"important difference as it means that a result *can only be retrieved "
"once*, and *only by the client that initiated the task*. Two different "
"processes can't wait for the same result."
msgstr ""

#: ../../userguide/tasks.rst:1089
msgid ""
"Even with that limitation, it is an excellent choice if you need to "
"receive state changes in real-time. Using messaging means the client "
"doesn't have to poll for new states."
msgstr ""

#: ../../userguide/tasks.rst:1093
msgid ""
"The messages are transient (non-persistent) by default, so the results "
"will disappear if the broker restarts. You can configure the result "
"backend to send persistent messages using the "
":setting:`result_persistent` setting."
msgstr ""

#: ../../userguide/tasks.rst:1098
msgid "Database Result Backend"
msgstr ""

#: ../../userguide/tasks.rst:1100
msgid ""
"Keeping state in the database can be convenient for many, especially for "
"web applications with a database already in place, but it also comes with"
" limitations."
msgstr ""

#: ../../userguide/tasks.rst:1104
msgid ""
"Polling the database for new states is expensive, and so you should "
"increase the polling intervals of operations, such as `result.get()`."
msgstr ""

#: ../../userguide/tasks.rst:1107
msgid ""
"Some databases use a default transaction isolation level that isn't "
"suitable for polling tables for changes."
msgstr ""

#: ../../userguide/tasks.rst:1110
msgid ""
"In MySQL the default transaction isolation level is `REPEATABLE-READ`: "
"meaning the transaction won't see changes made by other transactions "
"until the current transaction is committed."
msgstr ""

#: ../../userguide/tasks.rst:1114
msgid "Changing that to the `READ-COMMITTED` isolation level is recommended."
msgstr ""

#: ../../userguide/tasks.rst:1119
msgid "Built-in States"
msgstr ""

#: ../../userguide/tasks.rst:1124
msgid "PENDING"
msgstr ""

#: ../../userguide/tasks.rst:1126
msgid ""
"Task is waiting for execution or unknown. Any task id that's not known is"
" implied to be in the pending state."
msgstr ""

#: ../../userguide/tasks.rst:1132
msgid "STARTED"
msgstr ""

#: ../../userguide/tasks.rst:1134
msgid ""
"Task has been started. Not reported by default, to enable please see "
":attr:`@Task.track_started`."
msgstr ""

#: ../../userguide/tasks.rst
msgid "meta-data"
msgstr ""

#: ../../userguide/tasks.rst:1137
msgid "`pid` and `hostname` of the worker process executing the task."
msgstr ""

#: ../../userguide/tasks.rst:1143
msgid "SUCCESS"
msgstr ""

#: ../../userguide/tasks.rst:1145
msgid "Task has been successfully executed."
msgstr ""

#: ../../userguide/tasks.rst:1147
msgid "`result` contains the return value of the task."
msgstr ""

#: ../../userguide/tasks.rst
msgid "propagates"
msgstr ""

#: ../../userguide/tasks.rst:1148 ../../userguide/tasks.rst:1149
#: ../../userguide/tasks.rst:1161 ../../userguide/tasks.rst:1182
msgid "Yes"
msgstr ""

#: ../../userguide/tasks.rst
msgid "ready"
msgstr ""

#: ../../userguide/tasks.rst:1154
msgid "FAILURE"
msgstr ""

#: ../../userguide/tasks.rst:1156
msgid "Task execution resulted in failure."
msgstr ""

#: ../../userguide/tasks.rst:1158
msgid ""
"`result` contains the exception occurred, and `traceback` contains the "
"backtrace of the stack at the point when the exception was raised."
msgstr ""

#: ../../userguide/tasks.rst:1166
msgid "RETRY"
msgstr ""

#: ../../userguide/tasks.rst:1168
msgid "Task is being retried."
msgstr ""

#: ../../userguide/tasks.rst:1170
msgid ""
"`result` contains the exception that caused the retry, and `traceback` "
"contains the backtrace of the stack at the point when the exceptions was "
"raised."
msgstr ""

#: ../../userguide/tasks.rst:1173
msgid "No"
msgstr ""

#: ../../userguide/tasks.rst:1178
msgid "REVOKED"
msgstr ""

#: ../../userguide/tasks.rst:1180
msgid "Task has been revoked."
msgstr ""

#: ../../userguide/tasks.rst:1187
msgid "Custom states"
msgstr ""

#: ../../userguide/tasks.rst:1189
msgid ""
"You can easily define your own states, all you need is a unique name. The"
" name of the state is usually an uppercase string. As an example you "
"could have a look at the :mod:`abortable tasks "
"<~celery.contrib.abortable>` which defines a custom :state:`ABORTED` "
"state."
msgstr ""

#: ../../userguide/tasks.rst:1194
msgid "Use :meth:`~@Task.update_state` to update a task's state:."
msgstr ""

#: ../../userguide/tasks.rst:1206
msgid ""
"Here I created the state `\"PROGRESS\"`, telling any application aware of"
" this state that the task is currently in progress, and also where it is "
"in the process by having `current` and `total` counts as part of the "
"state meta-data. This can then be used to create progress bars for "
"example."
msgstr ""

#: ../../userguide/tasks.rst:1214
msgid "Creating pickleable exceptions"
msgstr ""

#: ../../userguide/tasks.rst:1216
msgid ""
"A rarely known Python fact is that exceptions must conform to some simple"
" rules to support being serialized by the pickle module."
msgstr ""

#: ../../userguide/tasks.rst:1219
msgid ""
"Tasks that raise exceptions that aren't pickleable won't work properly "
"when Pickle is used as the serializer."
msgstr ""

#: ../../userguide/tasks.rst:1222
msgid ""
"To make sure that your exceptions are pickleable the exception *MUST* "
"provide the original arguments it was instantiated with in its ``.args`` "
"attribute. The simplest way to ensure this is to have the exception call "
"``Exception.__init__``."
msgstr ""

#: ../../userguide/tasks.rst:1227
msgid "Let's look at some examples that work, and one that doesn't:"
msgstr ""

#: ../../userguide/tasks.rst:1250
msgid ""
"So the rule is: For any exception that supports custom arguments "
"``*args``, ``Exception.__init__(self, *args)`` must be used."
msgstr ""

#: ../../userguide/tasks.rst:1254
msgid ""
"There's no special support for *keyword arguments*, so if you want to "
"preserve keyword arguments when the exception is unpickled you have to "
"pass them as regular args:"
msgstr ""

#: ../../userguide/tasks.rst:1272
msgid "Semipredicates"
msgstr ""

#: ../../userguide/tasks.rst:1274
msgid ""
"The worker wraps the task in a tracing function that records the final "
"state of the task. There are a number of exceptions that can be used to "
"signal this function to change how it treats the return of the task."
msgstr ""

#: ../../userguide/tasks.rst:1281
msgid "Ignore"
msgstr ""

#: ../../userguide/tasks.rst:1283
msgid ""
"The task may raise :exc:`~@Ignore` to force the worker to ignore the "
"task. This means that no state will be recorded for the task, but the "
"message is still acknowledged (removed from queue)."
msgstr ""

#: ../../userguide/tasks.rst:1287
msgid ""
"This can be used if you want to implement custom revoke-like "
"functionality, or manually store the result of a task."
msgstr ""

#: ../../userguide/tasks.rst:1290
msgid "Example keeping revoked tasks in a Redis set:"
msgstr ""

#: ../../userguide/tasks.rst:1301
msgid "Example that stores results manually:"
msgstr ""

#: ../../userguide/tasks.rst:1318
msgid "Reject"
msgstr ""

#: ../../userguide/tasks.rst:1320
msgid ""
"The task may raise :exc:`~@Reject` to reject the task message using AMQPs"
" ``basic_reject`` method. This won't have any effect unless "
":attr:`Task.acks_late` is enabled."
msgstr ""

#: ../../userguide/tasks.rst:1324
msgid ""
"Rejecting a message has the same effect as acking it, but some brokers "
"may implement additional functionality that can be used. For example "
"RabbitMQ supports the concept of `Dead Letter Exchanges`_ where a queue "
"can be configured to use a dead letter exchange that rejected messages "
"are redelivered to."
msgstr ""

#: ../../userguide/tasks.rst:1332
msgid ""
"Reject can also be used to re-queue messages, but please be very careful "
"when using this as it can easily result in an infinite message loop."
msgstr ""

#: ../../userguide/tasks.rst:1335
msgid "Example using reject when a task causes an out of memory condition:"
msgstr ""

#: ../../userguide/tasks.rst:1361
msgid "Example re-queuing the message:"
msgstr ""

#: ../../userguide/tasks.rst:1373
msgid ""
"Consult your broker documentation for more details about the "
"``basic_reject`` method."
msgstr ""

#: ../../userguide/tasks.rst:1380
msgid "Retry"
msgstr ""

#: ../../userguide/tasks.rst:1382
msgid ""
"The :exc:`~@Retry` exception is raised by the ``Task.retry`` method to "
"tell the worker that the task is being retried."
msgstr ""

#: ../../userguide/tasks.rst:1388
msgid "Custom task classes"
msgstr ""

#: ../../userguide/tasks.rst:1390
msgid ""
"All tasks inherit from the :class:`@Task` class. The :meth:`~@Task.run` "
"method becomes the task body."
msgstr ""

#: ../../userguide/tasks.rst:1393
msgid "As an example, the following code,"
msgstr ""

#: ../../userguide/tasks.rst:1402
msgid "will do roughly this behind the scenes:"
msgstr ""

#: ../../userguide/tasks.rst:1414
msgid "Instantiation"
msgstr ""

#: ../../userguide/tasks.rst:1416
msgid ""
"A task is **not** instantiated for every request, but is registered in "
"the task registry as a global instance."
msgstr ""

#: ../../userguide/tasks.rst:1419
msgid ""
"This means that the ``__init__`` constructor will only be called once per"
" process, and that the task class is semantically closer to an Actor."
msgstr ""

#: ../../userguide/tasks.rst:1423
msgid "If you have a task,"
msgstr ""

#: ../../userguide/tasks.rst:1440
msgid ""
"And you route every request to the same process, then it will keep state "
"between requests."
msgstr ""

#: ../../userguide/tasks.rst:1443
msgid ""
"This can also be useful to cache resources, For example, a base Task "
"class that caches a database connection:"
msgstr ""

#: ../../userguide/tasks.rst:1460
msgid "that can be added to tasks like this:"
msgstr ""

#: ../../userguide/tasks.rst:1470
msgid ""
"The ``db`` attribute of the ``process_rows`` task will then always stay "
"the same in each process."
msgstr ""

#: ../../userguide/tasks.rst:1474
msgid "Handlers"
msgstr ""

#: ../../userguide/tasks.rst:1478
msgid "Handler called after the task returns."
msgstr ""

#: ../../userguide/tasks.rst
msgid "Parameters"
msgstr ""

#: ../../userguide/tasks.rst:1480
msgid "Current task state."
msgstr ""

#: ../../userguide/tasks.rst:1481
msgid "Task return value/exception."
msgstr ""

#: ../../userguide/tasks.rst:1482
msgid "Unique id of the task."
msgstr ""

#: ../../userguide/tasks.rst:1483
msgid "Original arguments for the task that returned."
msgstr ""

#: ../../userguide/tasks.rst:1484
msgid "Original keyword arguments for the task that returned."
msgstr ""

#: ../../userguide/tasks.rst
msgid "Keyword Arguments"
msgstr ""

#: ../../userguide/tasks.rst:1487
msgid ""
":class:`~billiard.einfo.ExceptionInfo` instance, containing the traceback"
" (if any)."
msgstr ""

#: ../../userguide/tasks.rst:1490 ../../userguide/tasks.rst:1505
#: ../../userguide/tasks.rst:1519 ../../userguide/tasks.rst:1530
msgid "The return value of this handler is ignored."
msgstr ""

#: ../../userguide/tasks.rst:1494
msgid "This is run by the worker when the task fails."
msgstr ""

#: ../../userguide/tasks.rst:1496
msgid "The exception raised by the task."
msgstr ""

#: ../../userguide/tasks.rst:1497
msgid "Unique id of the failed task."
msgstr ""

#: ../../userguide/tasks.rst:1498
msgid "Original arguments for the task that failed."
msgstr ""

#: ../../userguide/tasks.rst:1499
msgid "Original keyword arguments for the task that failed."
msgstr ""

#: ../../userguide/tasks.rst:1502 ../../userguide/tasks.rst:1516
msgid ":class:`~billiard.einfo.ExceptionInfo` instance, containing the traceback."
msgstr ""

#: ../../userguide/tasks.rst:1509
msgid "This is run by the worker when the task is to be retried."
msgstr ""

#: ../../userguide/tasks.rst:1511
msgid "The exception sent to :meth:`~@Task.retry`."
msgstr ""

#: ../../userguide/tasks.rst:1512
msgid "Unique id of the retried task."
msgstr ""

#: ../../userguide/tasks.rst:1513
msgid "Original arguments for the retried task."
msgstr ""

#: ../../userguide/tasks.rst:1514
msgid "Original keyword arguments for the retried task."
msgstr ""

#: ../../userguide/tasks.rst:1523
msgid "Run by the worker if the task executes successfully."
msgstr ""

#: ../../userguide/tasks.rst:1525
msgid "The return value of the task."
msgstr ""

#: ../../userguide/tasks.rst:1526
msgid "Unique id of the executed task."
msgstr ""

#: ../../userguide/tasks.rst:1527
msgid "Original arguments for the executed task."
msgstr ""

#: ../../userguide/tasks.rst:1528
msgid "Original keyword arguments for the executed task."
msgstr ""

#: ../../userguide/tasks.rst:1535
msgid "Requests and custom requests"
msgstr ""

#: ../../userguide/tasks.rst:1537
msgid ""
"Upon receiving a message to run a task, the `worker <guide-workers>`:ref:"
" creates a `request <celery.worker.request.Request>`:class: to represent "
"such demand."
msgstr ""

#: ../../userguide/tasks.rst:1541
msgid ""
"Custom task classes may override which request class to use by changing "
"the attribute `celery.app.task.Task.Request`:attr:.  You may either "
"assign the custom request class itself, or its fully qualified name."
msgstr ""

#: ../../userguide/tasks.rst:1545
msgid ""
"The request has several responsibilities.  Custom request classes should "
"cover them all -- they are responsible to actually run and trace the "
"task.  We strongly recommend to inherit from "
"`celery.worker.request.Request`:class:."
msgstr ""

#: ../../userguide/tasks.rst:1549
msgid ""
"When using the `pre-forking worker <worker-concurrency>`:ref:, the "
"methods `~celery.worker.request.Request.on_timeout`:meth: and "
"`~celery.worker.request.Request.on_failure`:meth: are executed in the "
"main worker process.  An application may leverage such facility to detect"
" failures which are not detected using "
"`celery.app.task.Task.on_failure`:meth:."
msgstr ""

#: ../../userguide/tasks.rst:1555
msgid ""
"As an example, the following custom request detects and logs hard time "
"limits, and other failures."
msgstr ""

#: ../../userguide/tasks.rst:1598
msgid "How it works"
msgstr ""

#: ../../userguide/tasks.rst:1600
msgid ""
"Here come the technical details. This part isn't something you need to "
"know, but you may be interested."
msgstr ""

#: ../../userguide/tasks.rst:1603
msgid ""
"All defined tasks are listed in a registry. The registry contains a list "
"of task names and their task classes. You can investigate this registry "
"yourself:"
msgstr ""

#: ../../userguide/tasks.rst:1618
msgid ""
"This is the list of tasks built into Celery. Note that tasks will only be"
" registered when the module they're defined in is imported."
msgstr ""

#: ../../userguide/tasks.rst:1621
msgid ""
"The default loader imports any modules listed in the :setting:`imports` "
"setting."
msgstr ""

#: ../../userguide/tasks.rst:1624
msgid ""
"The :meth:`@task` decorator is responsible for registering your task in "
"the applications task registry."
msgstr ""

#: ../../userguide/tasks.rst:1627
msgid ""
"When tasks are sent, no actual function code is sent with it, just the "
"name of the task to execute. When the worker then receives the message it"
" can look up the name in its task registry to find the execution code."
msgstr ""

#: ../../userguide/tasks.rst:1631
msgid ""
"This means that your workers should always be updated with the same "
"software as the client. This is a drawback, but the alternative is a "
"technical challenge that's yet to be solved."
msgstr ""

#: ../../userguide/tasks.rst:1638
msgid "Tips and Best Practices"
msgstr ""

#: ../../userguide/tasks.rst:1643
msgid "Ignore results you don't want"
msgstr ""

#: ../../userguide/tasks.rst:1645
msgid ""
"If you don't care about the results of a task, be sure to set the "
":attr:`~@Task.ignore_result` option, as storing results wastes time and "
"resources."
msgstr ""

#: ../../userguide/tasks.rst:1655
msgid ""
"Results can even be disabled globally using the "
":setting:`task_ignore_result` setting."
msgstr ""

#: ../../userguide/tasks.rst:1660
msgid ""
"Results can be enabled/disabled on a per-execution basis, by passing the "
"``ignore_result`` boolean parameter, when calling ``apply_async`` or "
"``delay``."
msgstr ""

#: ../../userguide/tasks.rst:1677
msgid ""
"By default tasks will *not ignore results* (``ignore_result=False``) when"
" a result backend is configured."
msgstr ""

#: ../../userguide/tasks.rst:1680
msgid "The option precedence order is the following:"
msgstr ""

#: ../../userguide/tasks.rst:1682
msgid "Global :setting:`task_ignore_result`"
msgstr ""

#: ../../userguide/tasks.rst:1683
msgid ":attr:`~@Task.ignore_result` option"
msgstr ""

#: ../../userguide/tasks.rst:1684
msgid "Task execution option ``ignore_result``"
msgstr ""

#: ../../userguide/tasks.rst:1687
msgid "More optimization tips"
msgstr ""

#: ../../userguide/tasks.rst:1689
msgid ""
"You find additional optimization tips in the :ref:`Optimizing Guide "
"<guide-optimizing>`."
msgstr ""

#: ../../userguide/tasks.rst:1695
msgid "Avoid launching synchronous subtasks"
msgstr ""

#: ../../userguide/tasks.rst:1697
msgid ""
"Having a task wait for the result of another task is really inefficient, "
"and may even cause a deadlock if the worker pool is exhausted."
msgstr ""

#: ../../userguide/tasks.rst:1700
msgid "Make your design asynchronous instead, for example by using *callbacks*."
msgstr ""

#: ../../userguide/tasks.rst:1702
msgid "**Bad**:"
msgstr ""

#: ../../userguide/tasks.rst:1725
msgid "**Good**:"
msgstr ""

#: ../../userguide/tasks.rst:1747
msgid ""
"Here I instead created a chain of tasks by linking together different "
":func:`~celery.signature`'s. You can read about chains and other powerful"
" constructs at :ref:`designing-workflows`."
msgstr ""

#: ../../userguide/tasks.rst:1752
msgid ""
"By default Celery will not allow you to run subtasks synchronously within"
" a task, but in rare or extreme cases you might need to do so. "
"**WARNING**: enabling subtasks to run synchronously is not recommended!"
msgstr ""

#: ../../userguide/tasks.rst:1781
msgid "Performance and Strategies"
msgstr ""

#: ../../userguide/tasks.rst:1786
msgid "Granularity"
msgstr ""

#: ../../userguide/tasks.rst:1788
msgid ""
"The task granularity is the amount of computation needed by each subtask."
" In general it is better to split the problem up into many small tasks "
"rather than have a few long running tasks."
msgstr ""

#: ../../userguide/tasks.rst:1792
msgid ""
"With smaller tasks you can process more tasks in parallel and the tasks "
"won't run long enough to block the worker from processing other waiting "
"tasks."
msgstr ""

#: ../../userguide/tasks.rst:1795
msgid ""
"However, executing a task does have overhead. A message needs to be sent,"
" data may not be local, etc. So if the tasks are too fine-grained the "
"overhead added probably removes any benefit."
msgstr ""

#: ../../userguide/tasks.rst:1801
msgid ""
"The book `Art of Concurrency`_ has a section dedicated to the topic of "
"task granularity [AOC1]_."
msgstr ""

#: ../../userguide/tasks.rst:1806
msgid ""
"Breshears, Clay. Section 2.2.1, \"The Art of Concurrency\". O'Reilly "
"Media, Inc. May 15, 2009. ISBN-13 978-0-596-52153-0."
msgstr ""

#: ../../userguide/tasks.rst:1812
msgid "Data locality"
msgstr ""

#: ../../userguide/tasks.rst:1814
msgid ""
"The worker processing the task should be as close to the data as "
"possible. The best would be to have a copy in memory, the worst would be "
"a full transfer from another continent."
msgstr ""

#: ../../userguide/tasks.rst:1818
msgid ""
"If the data is far away, you could try to run another worker at location,"
" or if that's not possible - cache often used data, or preload data you "
"know is going to be used."
msgstr ""

#: ../../userguide/tasks.rst:1822
msgid ""
"The easiest way to share data between workers is to use a distributed "
"cache system, like `memcached`_."
msgstr ""

#: ../../userguide/tasks.rst:1827
msgid ""
"The paper `Distributed Computing Economics`_ by Jim Gray is an excellent "
"introduction to the topic of data locality."
msgstr ""

#: ../../userguide/tasks.rst:1838
msgid "State"
msgstr ""

#: ../../userguide/tasks.rst:1840
msgid ""
"Since Celery is a distributed system, you can't know which process, or on"
" what machine the task will be executed. You can't even know if the task "
"will run in a timely manner."
msgstr ""

#: ../../userguide/tasks.rst:1844
msgid ""
"The ancient async sayings tells us that “asserting the world is the "
"responsibility of the task”. What this means is that the world view may "
"have changed since the task was requested, so the task is responsible for"
" making sure the world is how it should be;  If you have a task that re-"
"indexes a search engine, and the search engine should only be re-indexed "
"at maximum every 5 minutes, then it must be the tasks responsibility to "
"assert that, not the callers."
msgstr ""

#: ../../userguide/tasks.rst:1852
msgid ""
"Another gotcha is Django model objects. They shouldn't be passed on as "
"arguments to tasks. It's almost always better to re-fetch the object from"
" the database when the task is running instead,  as using old data may "
"lead to race conditions."
msgstr ""

#: ../../userguide/tasks.rst:1857
msgid ""
"Imagine the following scenario where you have an article and a task that "
"automatically expands some abbreviations in it:"
msgstr ""

#: ../../userguide/tasks.rst:1871
msgid ""
"First, an author creates an article and saves it, then the author clicks "
"on a button that initiates the abbreviation task:"
msgstr ""

#: ../../userguide/tasks.rst:1879
msgid ""
"Now, the queue is very busy, so the task won't be run for another 2 "
"minutes. In the meantime another author makes changes to the article, so "
"when the task is finally run, the body of the article is reverted to the "
"old version because the task had the old body in its argument."
msgstr ""

#: ../../userguide/tasks.rst:1884
msgid ""
"Fixing the race condition is easy, just use the article id instead, and "
"re-fetch the article in the task body:"
msgstr ""

#: ../../userguide/tasks.rst:1899
msgid ""
"There might even be performance benefits to this approach, as sending "
"large messages may be expensive."
msgstr ""

#: ../../userguide/tasks.rst:1905
msgid "Database transactions"
msgstr ""

#: ../../userguide/tasks.rst:1907
msgid "Let's have a look at another example:"
msgstr ""

#: ../../userguide/tasks.rst:1918
msgid ""
"This is a Django view creating an article object in the database, then "
"passing the primary key to a task. It uses the `commit_on_success` "
"decorator, that will commit the transaction when the view returns, or "
"roll back if the view raises an exception."
msgstr ""

#: ../../userguide/tasks.rst:1923
msgid ""
"There's a race condition if the task starts executing before the "
"transaction has been committed; The database object doesn't exist yet!"
msgstr ""

#: ../../userguide/tasks.rst:1927
msgid ""
"The solution is to use the ``on_commit`` callback to launch your Celery "
"task once all transactions have been committed successfully."
msgstr ""

#: ../../userguide/tasks.rst:1939
msgid ""
"``on_commit`` is available in Django 1.9 and above, if you are using a "
"version prior to that then the `django-transaction-hooks`_ library adds "
"support for this."
msgstr ""

#: ../../userguide/tasks.rst:1950
msgid ""
"Let's take a real world example: a blog where comments posted need to be "
"filtered for spam. When the comment is created, the spam filter runs in "
"the background, so the user doesn't have to wait for it to finish."
msgstr ""

#: ../../userguide/tasks.rst:1954
msgid ""
"I have a Django blog application allowing comments on blog posts. I'll "
"describe parts of the models/views and tasks for this application."
msgstr ""

#: ../../userguide/tasks.rst:1959
msgid "``blog/models.py``"
msgstr ""

#: ../../userguide/tasks.rst:1961
msgid "The comment model looks like this:"
msgstr ""

#: ../../userguide/tasks.rst:1985
msgid ""
"In the view where the comment is posted, I first write the comment to the"
" database, then I launch the spam filter task in the background."
msgstr ""

#: ../../userguide/tasks.rst:1991
msgid "``blog/views.py``"
msgstr ""

#: ../../userguide/tasks.rst:2029
msgid ""
"To filter spam in comments I use `Akismet`_, the service used to filter "
"spam in comments posted to the free blog platform `Wordpress`. `Akismet`_"
" is free for personal use, but for commercial use you need to pay. You "
"have to sign up to their service to get an API key."
msgstr ""

#: ../../userguide/tasks.rst:2034
msgid ""
"To make API calls to `Akismet`_ I use the `akismet.py`_ library written "
"by `Michael Foord`_."
msgstr ""

#: ../../userguide/tasks.rst:2040
msgid "``blog/tasks.py``"
msgstr ""

