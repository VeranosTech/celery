# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2009-2018, Ask Solem & contributors
# This file is distributed under the same license as the Celery package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Celery 4.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-22 13:42+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../reference/celery.rst:3
msgid ":mod:`celery` --- Distributed processing"
msgstr ""

#: ../../reference/celery.rst:13
msgid ""
"This module is the main entry-point for the Celery API. It includes "
"commonly needed things for calling tasks, and creating Celery "
"applications."
msgstr ""

#: ../../reference/celery.rst:18
msgid ":class:`Celery`"
msgstr ""

#: ../../reference/celery.rst:18
msgid "Celery application instance"
msgstr ""

#: ../../reference/celery.rst:19
msgid ":class:`group`"
msgstr ""

#: ../../reference/celery.rst:19
msgid "group tasks together"
msgstr ""

#: ../../reference/celery.rst:20
msgid ":class:`chain`"
msgstr ""

#: ../../reference/celery.rst:20
msgid "chain tasks together"
msgstr ""

#: ../../reference/celery.rst:21
msgid ":class:`chord`"
msgstr ""

#: ../../reference/celery.rst:21
msgid "chords enable callbacks for groups"
msgstr ""

#: ../../reference/celery.rst:22
msgid ":func:`signature`"
msgstr ""

#: ../../reference/celery.rst:22
msgid "create a new task signature"
msgstr ""

#: ../../reference/celery.rst:23
msgid ":class:`Signature`"
msgstr ""

#: ../../reference/celery.rst:23
msgid "object describing a task invocation"
msgstr ""

#: ../../reference/celery.rst:24
msgid ":data:`current_app`"
msgstr ""

#: ../../reference/celery.rst:24
msgid "proxy to the current application instance"
msgstr ""

#: ../../reference/celery.rst:25
msgid ":data:`current_task`"
msgstr ""

#: ../../reference/celery.rst:25
msgid "proxy to the currently executing task"
msgstr ""

#: ../../reference/celery.rst:29
msgid ":class:`Celery` application objects"
msgstr ""

#: celery.Celery:1 of
msgid "Celery application."
msgstr ""

#: celery.Celery celery.Celery.autodiscover_tasks
#: celery.Celery.config_from_object celery.Celery.connection
#: celery.Celery.connection_or_acquire celery.Celery.producer_or_acquire
#: celery.Celery.select_queues celery.Celery.send_task
#: celery.Celery.setup_security celery.Signature celery.app.amqp.Queues
#: celery.app.amqp.Queues.add celery.app.amqp.Queues.deselect
#: celery.app.amqp.Queues.select celery.app.control.Control.add_consumer
#: celery.app.control.Control.broadcast celery.app.control.Control.discard_all
#: celery.app.control.Control.purge celery.app.control.Control.rate_limit
#: celery.app.control.Control.revoke celery.app.control.Control.time_limit
#: celery.app.log.Logging.redirect_stdouts_to_logger
#: celery.app.registry.TaskRegistry.unregister celery.app.task.Task.AsyncResult
#: celery.app.task.Task.add_to_chord celery.app.task.Task.after_return
#: celery.app.task.Task.apply celery.app.task.Task.apply_async
#: celery.app.task.Task.delay celery.app.task.Task.on_failure
#: celery.app.task.Task.on_retry celery.app.task.Task.on_success
#: celery.app.task.Task.replace celery.app.task.Task.retry
#: celery.app.task.Task.send_event celery.app.task.Task.shadow_name
#: celery.app.task.Task.update_state celery.app.utils.Settings.find_option
#: celery.beat.EmbeddedService celery.beat.ScheduleEntry celery.beat.Scheduler
#: celery.bin.amqp.AMQShell celery.bin.amqp.Spec celery.bin.base.Command
#: celery.bin.base.Command.ask celery.bin.base.Command.execute_from_commandline
#: celery.bin.base.Command.handle_argv
#: celery.bin.celery.CeleryCommand.execute_from_commandline
#: celery.bin.celery.CeleryCommand.handle_argv celery.bootsteps.Blueprint
#: celery.chain celery.contrib.migrate.move celery.contrib.migrate.move_direct
#: celery.contrib.migrate.move_direct_by_id
#: celery.contrib.migrate.move_task_by_id
#: celery.contrib.testing.manager.humanize_seconds
#: celery.events.EventDispatcher celery.events.EventDispatcher.publish
#: celery.events.EventDispatcher.send celery.events.EventReceiver
#: celery.events.dispatcher.EventDispatcher
#: celery.events.dispatcher.EventDispatcher.publish
#: celery.events.dispatcher.EventDispatcher.send
#: celery.events.event.get_exchange celery.events.get_exchange
#: celery.events.receiver.EventReceiver celery.group celery.result.AsyncResult
#: celery.result.AsyncResult.get celery.result.AsyncResult.revoke
#: celery.result.AsyncResult.wait celery.result.EagerResult.get
#: celery.result.EagerResult.revoke celery.result.EagerResult.wait
#: celery.result.GroupResult celery.result.ResultSet
#: celery.result.ResultSet.join celery.result.ResultSet.revoke
#: celery.schedules.schedule celery.schedules.solar
#: celery.worker.consumer.Consumer.on_decode_error
#: celery.worker.consumer.consumer.Consumer.on_decode_error
#: celery.worker.request.Request.execute
#: celery.worker.request.Request.execute_using_pool of
msgid "Parameters"
msgstr ""

#: celery.Celery:3 of
msgid ""
"Name of the main module if running as `__main__`. This is used as the "
"prefix for auto-generated task names."
msgstr ""

#: celery.Celery celery.app.control.Control.pool_restart
#: celery.app.task.Task.send_event of
msgid "Keyword Arguments"
msgstr ""

#: celery.Celery:7 of
msgid "URL of the default broker used."
msgstr ""

#: celery.Celery:9 of
msgid ""
"The result store backend class, or the name of the backend class to use."
"  Default is the value of the :setting:`result_backend` setting."
msgstr ""

#: celery.Celery:9 of
msgid "The result store backend class, or the name of the backend class to use."
msgstr ""

#: celery.Celery:12 of
msgid "Default is the value of the :setting:`result_backend` setting."
msgstr ""

#: celery.Celery:14 of
msgid ""
"If set to False a :exc:`RuntimeError` will be raised if the task registry"
" or tasks are used before the app is finalized."
msgstr ""

#: celery.Celery:18 of
msgid "Make this the global current app."
msgstr ""

#: celery.Celery:20 of
msgid "List of modules every worker should import."
msgstr ""

#: celery.Celery:22 of
msgid "AMQP object or class name."
msgstr ""

#: celery.Celery:24 of
msgid "Events object or class name."
msgstr ""

#: celery.Celery:27 of
msgid "Log object or class name."
msgstr ""

#: celery.Celery:29 of
msgid "Control object or class name."
msgstr ""

#: celery.Celery:32 of
msgid "A task registry, or the name of a registry class."
msgstr ""

#: celery.Celery:35 of
msgid "List of fix-up plug-ins (e.g., see :mod:`celery.fixups.django`)."
msgstr ""

#: celery.Celery:38 of
msgid ""
"Take configuration from a class, or object.  Attributes may include any "
"settings described in the documentation."
msgstr ""

#: celery.Celery.user_options:1 of
msgid ""
"Custom options for command-line programs. See :ref:`extending-"
"commandoptions`"
msgstr ""

#: celery.Celery.steps:1 of
msgid ""
"Custom bootsteps to extend and modify the worker. See :ref:`extending-"
"bootsteps`."
msgstr ""

#: celery.Celery.current_task:1 of
msgid "Instance of task being executed, or :const:`None`."
msgstr ""

#: celery.Celery.current_worker_task:1 of
msgid "The task currently being executed by a worker or :const:`None`."
msgstr ""

#: celery.Celery.current_worker_task:3 of
msgid ""
"Differs from :data:`current_task` in that it's not affected by tasks "
"calling other tasks directly, or eagerly."
msgstr ""

#: celery.Celery.amqp:1 of
msgid ":class:`~@amqp`."
msgstr ""

#: celery.Celery.amqp celery.Celery.control celery.Celery.events
#: celery.Celery.log celery.Celery.pool celery.app.task.Task.rate_limit of
msgid "type"
msgstr ""

#: celery.Celery.amqp:3 of
msgid "AMQP related functionality"
msgstr ""

#: celery.Celery.backend:1 of
msgid "Current backend instance."
msgstr ""

#: celery.Celery.loader:1 of
msgid "Current loader instance."
msgstr ""

#: celery.Celery.control:1 of
msgid ":class:`~@control`."
msgstr ""

#: celery.Celery.control:3 of
msgid "Remote control"
msgstr ""

#: celery.Celery.events:1 of
msgid ":class:`~@events`."
msgstr ""

#: celery.Celery.events:3 of
msgid "Consuming and sending events"
msgstr ""

#: celery.Celery.log:1 of
msgid ":class:`~@log`."
msgstr ""

#: celery.Celery.log:3 of
msgid "Logging"
msgstr ""

#: celery.Celery.tasks:1 of
msgid "Task registry."
msgstr ""

#: celery.Celery.tasks:3 of
msgid "Accessing this attribute will also auto-finalize the app."
msgstr ""

#: celery.Celery.pool:1 of
msgid ":class:`~@pool`."
msgstr ""

#: celery.Celery.pool:3 of
msgid "This attribute is not related to the workers concurrency pool."
msgstr ""

#: celery.Celery.pool:5 of
msgid "Broker connection pool"
msgstr ""

#: celery.Celery.Task:1 of
msgid "Base task class for this app."
msgstr ""

#: celery.Celery.timezone:1 of
msgid "Current timezone for this app."
msgstr ""

#: celery.Celery.timezone:3 of
msgid ""
"This is a cached property taking the time zone from the "
":setting:`timezone` setting."
msgstr ""

#: celery.Celery.oid:1 of
msgid "Universally unique identifier for this app."
msgstr ""

#: celery.Celery.close:1 of
msgid "Clean up after the application."
msgstr ""

#: celery.Celery.close:3 of
msgid ""
"Only necessary for dynamically created apps, and you should probably use "
"the :keyword:`with` statement instead."
msgstr ""

#: celery.Celery.close:7 celery.Celery.config_from_envvar:7
#: celery.Celery.config_from_object:6 celery.app.task.Task.retry:4
#: celery.app.task.Task.shadow_name:4 celery.app.utils.Settings.find_option:4
#: celery.app.utils.Settings.get_by_parts:4
#: celery.bin.amqp.Spec.str_args_to_python:4
#: celery.bin.base.Command.with_pool_option:8
#: celery.bin.celery.CeleryCommand.with_pool_option:8 celery.bin.list.list_:6
#: celery.bin.migrate.migrate:9 celery.bin.worker.worker.with_pool_option:8
#: celery.chain:13 celery.chord:12 celery.contrib.migrate.move_by_idmap:6
#: celery.contrib.migrate.move_by_taskmap:6
#: celery.contrib.testing.mocks.task_message_from_sig:4
#: celery.events.event.group_from:4 celery.events.group_from:4 celery.group:13
#: celery.result.GroupResult.save:4 of
msgid "Example"
msgstr ""

#: celery.Celery.signature:1 of
msgid "Return a new :class:`~celery.Signature` bound to this app."
msgstr ""

#: celery.Celery.bugreport:1 of
msgid "Return information useful in bug reports."
msgstr ""

#: celery.Celery.config_from_object:1 of
msgid "Read configuration from object."
msgstr ""

#: celery.Celery.config_from_object:3 of
msgid "Object is either an actual object or the name of a module to import."
msgstr ""

#: celery.Celery.config_from_object:12 of
msgid "If true then import errors will be ignored."
msgstr ""

#: celery.Celery.config_from_object:14 of
msgid ""
"Force reading configuration immediately. By default the configuration "
"will be read only when required."
msgstr ""

#: celery.Celery.config_from_envvar:1 of
msgid "Read configuration from environment variable."
msgstr ""

#: celery.Celery.config_from_envvar:3 of
msgid ""
"The value of the environment variable must be the name of a module to "
"import."
msgstr ""

#: celery.Celery.autodiscover_tasks:1 of
msgid "Auto-discover task modules."
msgstr ""

#: celery.Celery.autodiscover_tasks:3 of
msgid ""
"Searches a list of packages for a \"tasks.py\" module (or use "
"related_name argument)."
msgstr ""

#: celery.Celery.autodiscover_tasks:6 of
msgid "If the name is empty, this will be delegated to fix-ups (e.g., Django)."
msgstr ""

#: celery.Celery.autodiscover_tasks:8 of
msgid "For example if you have a directory layout like this:"
msgstr ""

#: celery.Celery.autodiscover_tasks:23 of
msgid ""
"Then calling ``app.autodiscover_tasks(['foo', 'bar', 'baz'])`` will "
"result in the modules ``foo.tasks`` and ``bar.tasks`` being imported."
msgstr ""

#: celery.Celery.autodiscover_tasks:26 of
msgid ""
"List of packages to search. This argument may also be a callable, in "
"which case the value returned is used (for lazy evaluation)."
msgstr ""

#: celery.Celery.autodiscover_tasks:30 of
msgid ""
"The name of the module to find.  Defaults to \"tasks\": meaning \"look "
"for 'module.tasks' for every module in ``packages``.\".  If ``None`` will"
" only try to import the package, i.e. \"look for 'module'\"."
msgstr ""

#: celery.Celery.autodiscover_tasks:35 of
msgid ""
"By default this call is lazy so that the actual auto-discovery won't "
"happen until an application imports the default modules.  Forcing will "
"cause the auto-discovery to happen immediately."
msgstr ""

#: celery.Celery.add_defaults:1 of
msgid "Add default configuration from dict ``d``."
msgstr ""

#: celery.Celery.add_defaults:3 of
msgid ""
"If the argument is a callable function then it will be regarded as a "
"promise, and it won't be loaded until the configuration is actually "
"needed."
msgstr ""

#: celery.Celery.add_defaults:7 of
msgid "This method can be compared to:"
msgstr ""

#: celery.Celery.add_defaults:13 of
msgid ""
"with a difference that 1) no copy will be made and 2) the dict will not "
"be transferred when the worker spawns child processes, so it's important "
"that the same configuration happens at import time when pickle restores "
"the object on the other side."
msgstr ""

#: celery.Celery.setup_security:1 of
msgid "Setup the message-signing serializer."
msgstr ""

#: celery.Celery.setup_security:3 of
msgid "This will affect all application instances (a global operation)."
msgstr ""

#: celery.Celery.setup_security:5 of
msgid ""
"Disables untrusted serializers and if configured to use the ``auth`` "
"serializer will register the ``auth`` serializer with the provided "
"settings into the Kombu serializer registry."
msgstr ""

#: celery.Celery.setup_security:9 of
msgid ""
"List of serializer names, or content_types that should be exempt from "
"being disabled."
msgstr ""

#: celery.Celery.setup_security:12 of
msgid ""
"Name of private key file to use. Defaults to the :setting:`security_key` "
"setting."
msgstr ""

#: celery.Celery.setup_security:15 of
msgid ""
"Name of certificate file to use. Defaults to the "
":setting:`security_certificate` setting."
msgstr ""

#: celery.Celery.setup_security:18 of
msgid ""
"Directory containing certificates. Defaults to the "
":setting:`security_cert_store` setting."
msgstr ""

#: celery.Celery.setup_security:21 of
msgid "Digest algorithm used when signing messages. Default is ``sha256``."
msgstr ""

#: celery.Celery.setup_security:24 of
msgid ""
"Serializer used to encode messages after they've been signed.  See "
":setting:`task_serializer` for the serializers supported.  Default is "
"``json``."
msgstr ""

#: celery.Celery.start:1 of
msgid "Run :program:`celery` using `argv`."
msgstr ""

#: celery.Celery.start:3 celery.Celery.worker_main:3 of
msgid "Uses :data:`sys.argv` if `argv` is not specified."
msgstr ""

#: celery.Celery.task:1 of
msgid "Decorator to create a task class out of any callable."
msgstr ""

#: celery.Celery.task:4 celery.bin.amqp.amqp:7 celery.bin.beat.beat:4
#: celery.bin.call.call:4 celery.bin.control.control:6
#: celery.bin.control.inspect:6 celery.bin.events.events:16 celery.bin.multi:6
#: celery.bin.result.result:4 celery.bin.worker.worker:4 of
msgid "Examples"
msgstr ""

#: celery.Celery.task:11 of
msgid "with setting extra options:"
msgstr ""

#: celery.Celery.task:21 of
msgid ""
"App Binding: For custom apps the task decorator will return a proxy "
"object, so that the act of creating the task is not performed until the "
"task is used or the task registry is accessed."
msgstr ""

#: celery.Celery.task:25 of
msgid ""
"If you're depending on binding to be deferred, then you must not access "
"any attributes on the returned object until the application is fully set "
"up (finalized)."
msgstr ""

#: celery.Celery.send_task:1 of
msgid "Send task by name."
msgstr ""

#: celery.Celery.send_task:3 of
msgid "Supports the same arguments as :meth:`@-Task.apply_async`."
msgstr ""

#: celery.Celery.send_task:5 of
msgid "Name of task to call (e.g., `\"tasks.add\"`)."
msgstr ""

#: celery.Celery.send_task:7 of
msgid "Specify custom result class."
msgstr ""

#: celery.Celery.AsyncResult:1 of
msgid "Create new result instance."
msgstr ""

#: celery.Celery.AsyncResult:3 of
msgid ":class:`celery.result.AsyncResult`."
msgstr ""

#: celery.Celery.GroupResult:1 of
msgid "Create new group result instance."
msgstr ""

#: celery.Celery.GroupResult:3 of
msgid ":class:`celery.result.GroupResult`."
msgstr ""

#: celery.Celery.worker_main:1 of
msgid "Run :program:`celery worker` using `argv`."
msgstr ""

#: celery.Celery.Worker:1 of
msgid "Worker application."
msgstr ""

#: celery.Celery.Worker:3 of
msgid ":class:`~@Worker`."
msgstr ""

#: celery.Celery.WorkController:1 of
msgid "Embeddable worker."
msgstr ""

#: celery.Celery.WorkController:3 of
msgid ":class:`~@WorkController`."
msgstr ""

#: celery.Celery.Beat:1 of
msgid ":program:`celery beat` scheduler application."
msgstr ""

#: celery.Celery.Beat:3 of
msgid ":class:`~@Beat`."
msgstr ""

#: celery.Celery.connection_for_read:1 of
msgid "Establish connection used for consuming."
msgstr ""

#: celery.Celery.connection_for_read:3 celery.Celery.connection_for_write:3 of
msgid ":meth:`connection` for supported arguments."
msgstr ""

#: celery.Celery.connection_for_write:1 of
msgid "Establish connection used for producing."
msgstr ""

#: celery.Celery.connection:1 of
msgid "Establish a connection to the message broker."
msgstr ""

#: celery.Celery.connection:3 of
msgid ""
"Please use :meth:`connection_for_read` and :meth:`connection_for_write` "
"instead, to convey the intent of use for this connection."
msgstr ""

#: celery.Celery.connection:7 of
msgid "Either the URL or the hostname of the broker to use."
msgstr ""

#: celery.Celery.connection:8 of
msgid ""
"URL, Hostname/IP-address of the broker. If a URL is used, then the other "
"argument below will be taken from the URL instead."
msgstr ""

#: celery.Celery.connection:12 of
msgid "Username to authenticate as."
msgstr ""

#: celery.Celery.connection:14 of
msgid "Password to authenticate with"
msgstr ""

#: celery.Celery.connection:16 of
msgid "Virtual host to use (domain)."
msgstr ""

#: celery.Celery.connection:18 of
msgid "Port to connect to."
msgstr ""

#: celery.Celery.connection:20 of
msgid "Defaults to the :setting:`broker_use_ssl` setting."
msgstr ""

#: celery.Celery.connection:23 of
msgid "defaults to the :setting:`broker_transport` setting."
msgstr ""

#: celery.Celery.connection:26 of
msgid "Dictionary of transport specific options."
msgstr ""

#: celery.Celery.connection:28 of
msgid "AMQP Heartbeat in seconds (``pyamqp`` only)."
msgstr ""

#: celery.Celery.connection:30 of
msgid "Custom login method to use (AMQP only)."
msgstr ""

#: celery.Celery.connection:32 of
msgid "Custom failover strategy."
msgstr ""

#: celery.Celery.connection:34 of
msgid "Additional arguments to :class:`kombu.Connection`."
msgstr ""

#: celery.Celery.connection celery.app.control.Control.discard_all
#: celery.app.control.Control.ping celery.app.control.Control.purge
#: celery.app.task.Task.after_return celery.app.task.Task.apply
#: celery.app.task.Task.apply_async celery.app.task.Task.delay
#: celery.app.task.Task.on_failure celery.app.task.Task.on_retry
#: celery.app.task.Task.on_success celery.app.task.Task.signature
#: celery.app.task.Task.subtask celery.app.utils.Settings.find_option
#: celery.beat.Scheduler.tick celery.bin.amqp.AMQShell.get_amqp_api_command
#: celery.bin.amqp.AMQShell.parseline celery.chain
#: celery.events.state.State.get_or_create_worker celery.group
#: celery.result.ResultSet.completed_count celery.result.ResultSet.failed
#: celery.result.ResultSet.ready celery.result.ResultSet.successful
#: celery.result.ResultSet.waiting celery.schedules.solar.remaining_estimate
#: celery.signature of
msgid "Returns"
msgstr ""

#: celery.Celery.connection:36 of
msgid "the lazy connection instance."
msgstr ""

#: celery.Celery.connection celery.app.control.Control.discard_all
#: celery.app.control.Control.ping celery.app.control.Control.purge
#: celery.app.task.Task.after_return celery.app.task.Task.apply
#: celery.app.task.Task.apply_async celery.app.task.Task.delay
#: celery.app.task.Task.on_failure celery.app.task.Task.on_retry
#: celery.app.task.Task.on_success celery.app.task.Task.signature
#: celery.app.task.Task.subtask celery.app.utils.Settings.find_option
#: celery.beat.Scheduler.tick celery.bin.amqp.AMQShell.get_amqp_api_command
#: celery.bin.amqp.AMQShell.parseline celery.chain
#: celery.events.state.State.get_or_create_worker celery.group
#: celery.result.ResultSet.completed_count celery.result.ResultSet.failed
#: celery.result.ResultSet.ready celery.result.ResultSet.successful
#: celery.result.ResultSet.waiting celery.schedules.solar.remaining_estimate
#: celery.signature of
msgid "Return type"
msgstr ""

#: celery.Celery.connection_or_acquire:1 of
msgid "Context used to acquire a connection from the pool."
msgstr ""

#: celery.Celery.connection_or_acquire:3 of
msgid ""
"For use within a :keyword:`with` statement to get a connection from the "
"pool if one is not already provided."
msgstr ""

#: celery.Celery.connection_or_acquire:6 of
msgid "If not provided, a connection will be acquired from the connection pool."
msgstr ""

#: celery.Celery.producer_or_acquire:1 of
msgid "Context used to acquire a producer from the pool."
msgstr ""

#: celery.Celery.producer_or_acquire:3 of
msgid ""
"For use within a :keyword:`with` statement to get a producer from the "
"pool if one is not already provided"
msgstr ""

#: celery.Celery.producer_or_acquire:6 of
msgid "If not provided, a producer will be acquired from the producer pool."
msgstr ""

#: celery.Celery.select_queues:1 of
msgid "Select subset of queues."
msgstr ""

#: celery.Celery.select_queues:3 of
msgid "a list of queue names to keep."
msgstr ""

#: celery.Celery.now:1 of
msgid "Return the current time and date as a datetime."
msgstr ""

#: celery.Celery.set_current:1 of
msgid "Make this the current app for this thread."
msgstr ""

#: celery.Celery.set_default:1 of
msgid "Make this the default app for all threads."
msgstr ""

#: celery.Celery.finalize:1 of
msgid "Finalize the app."
msgstr ""

#: celery.Celery.finalize:3 of
msgid ""
"This loads built-in tasks, evaluates pending task decorators, reads "
"configuration, etc."
msgstr ""

#: celery.Celery.on_init:1 of
msgid "Optional callback called at init."
msgstr ""

#: celery.Celery.prepare_config:1 of
msgid "Prepare configuration before it is merged with the defaults."
msgstr ""

#: ../../reference/celery.rst:125
msgid "Signal sent when app is loading configuration."
msgstr ""

#: ../../reference/celery.rst:129
msgid "Signal sent after app has prepared the configuration."
msgstr ""

#: ../../reference/celery.rst:133
msgid "Signal sent after app has been finalized."
msgstr ""

#: ../../reference/celery.rst:137
msgid "Signal sent in child process after fork."
msgstr ""

#: ../../reference/celery.rst:140
msgid "Canvas primitives"
msgstr ""

#: ../../reference/celery.rst:142
msgid "See :ref:`guide-canvas` for more about creating task work-flows."
msgstr ""

#: celery.group:1 of
msgid "Creates a group of tasks to be executed in parallel."
msgstr ""

#: celery.group:3 of
msgid "A group is lazy so you must call it to take action and evaluate the group."
msgstr ""

#: celery.group:8 of
msgid ""
"If only one argument is passed, and that argument is an iterable then "
"that'll be used as the list of tasks instead: this allows us to use "
"``group`` with generator expressions."
msgstr ""

#: celery.group:19 of
msgid ""
"A list of signatures that this group will call. If there's only one "
"argument, and that argument is an iterable, then that'll define the list "
"of signatures instead."
msgstr ""

#: celery.group:23 of
msgid "Execution options applied to all tasks in the group."
msgstr ""

#: celery.group:27 of
msgid ""
"signature that when called will then call all of the     tasks in the "
"group (and return a :class:`GroupResult` instance     that can be used to"
" inspect the state of the group)."
msgstr ""

#: celery.group:30 of
msgid "signature that when called will then call all of the"
msgstr ""

#: celery.group:30 of
msgid ""
"tasks in the group (and return a :class:`GroupResult` instance that can "
"be used to inspect the state of the group)."
msgstr ""

#: celery.chain:1 of
msgid "Chain tasks together."
msgstr ""

#: celery.chain:3 of
msgid ""
"Each tasks follows one another, by being applied as a callback of the "
"previous task."
msgstr ""

#: celery.chain:8 of
msgid ""
"If called with only one argument, then that argument must be an iterable "
"of tasks to chain: this allows us to use generator expressions."
msgstr ""

#: celery.chain:14 of
msgid "This is effectively :math:`((2 + 2) + 4)`:"
msgstr ""

#: celery.chain:22 of
msgid ""
"Calling a chain will return the result of the last task in the chain. You"
" can get to the other tasks by following the ``result.parent``'s:"
msgstr ""

#: celery.chain:30 of
msgid "Using a generator expression:"
msgstr ""

#: celery.chain:37 of
msgid ""
"List of task signatures to chain. If only one argument is passed and that"
" argument is an iterable, then that'll be used as the list of signatures "
"to chain instead.  This means that you can use a generator expression."
msgstr ""

#: celery.chain:44 of
msgid ""
"A lazy signature that can be called to apply the first     task in the "
"chain.  When that task succeeed the next task in the     chain is "
"applied, and so on."
msgstr ""

#: celery.chain:47 of
msgid "A lazy signature that can be called to apply the first"
msgstr ""

#: celery.chain:47 of
msgid ""
"task in the chain.  When that task succeeed the next task in the chain is"
" applied, and so on."
msgstr ""

#: celery.chord:1 of
msgid "Barrier synchronization primitive."
msgstr ""

#: celery.chord:3 of
msgid "A chord consists of a header and a body."
msgstr ""

#: celery.chord:5 of
msgid ""
"The header is a group of tasks that must complete before the callback is "
"called.  A chord is essentially a callback for a group of tasks."
msgstr ""

#: celery.chord:8 of
msgid ""
"The body is applied with the return values of all the header tasks as a "
"list."
msgstr ""

#: celery.chord:13 of
msgid "The chord:"
msgstr ""

#: celery.chord:19 of
msgid "is effectively :math:`\\Sigma ((2 + 2) + (4 + 4))`:"
msgstr ""

#: celery.signature:1 of
msgid "Create new signature."
msgstr ""

#: celery.signature:3 of
msgid "if the first argument is a signature already then it's cloned."
msgstr ""

#: celery.signature:4 of
msgid "if the first argument is a dict, then a Signature version is returned."
msgstr ""

#: celery.signature:6 of
msgid "The resulting signature."
msgstr ""

#: celery.Signature:1 of
msgid "Task Signature."
msgstr ""

#: celery.Signature:3 of
msgid ""
"Class that wraps the arguments and execution options for a single task "
"invocation."
msgstr ""

#: celery.Signature:6 of
msgid ""
"Used as the parts in a :class:`group` and other constructs, or to pass "
"tasks around as callbacks while being compatible with serializers with a "
"strict type subset."
msgstr ""

#: celery.Signature:10 of
msgid "Signatures can also be created from tasks:"
msgstr ""

#: celery.Signature:12 of
msgid ""
"Using the ``.signature()`` method that has the same signature as "
"``Task.apply_async``:"
msgstr ""

#: celery.Signature:19 of
msgid "or the ``.s()`` shortcut that works for star arguments:"
msgstr ""

#: celery.Signature:25 of
msgid ""
"the ``.s()`` shortcut does not allow you to specify execution options but"
" there's a chaning `.set` method that returns the signature:"
msgstr ""

#: celery.Signature:34 of
msgid ""
"You should use :func:`~celery.signature` to create new signatures. The "
"``Signature`` class is the type returned by that function and should be "
"used for ``isinstance`` checks for signatures."
msgstr ""

#: celery.Signature:38 of
msgid ":ref:`guide-canvas` for the complete guide."
msgstr ""

#: celery.Signature:40 of
msgid "Either a task class/instance, or the name of a task."
msgstr ""

#: celery.Signature:43 celery.beat.ScheduleEntry.args:1 of
msgid "Positional arguments to apply."
msgstr ""

#: celery.Signature:45 celery.beat.ScheduleEntry.kwargs:1 of
msgid "Keyword arguments to apply."
msgstr ""

#: celery.Signature:47 of
msgid "Additional options to :meth:`Task.apply_async`."
msgstr ""

#: celery.Signature:52 of
msgid ""
"If the first argument is a :class:`dict`, the other arguments will be "
"ignored and the values in the dict will be used instead::"
msgstr ""

#: ../../reference/celery.app.rst:9 ../../reference/celery.rst:155
msgid "Proxies"
msgstr ""

#: ../../reference/celery.rst:159
msgid "The currently set app for this thread."
msgstr ""

#: ../../reference/celery.rst:163
msgid ""
"The task currently being executed (only set in the worker, or when "
"eager/apply is used)."
msgstr ""

#: celery.app:1 of
msgid "Celery Application."
msgstr ""

#: celery.app.default_app:1 of
msgid "Proxy always returning the app set as default."
msgstr ""

#: ../../reference/celery.app.rst:15
msgid "Functions"
msgstr ""

#: celery.app.app_or_default:1 of
msgid "Function returning the app provided or the default app if none."
msgstr ""

#: celery.app.app_or_default:3 of
msgid ""
"The environment variable :envvar:`CELERY_TRACE_APP` is used to trace app "
"leaks.  When enabled an exception is raised if there is no active app."
msgstr ""

#: celery.app.enable_trace:1 of
msgid "Enable tracing of app instances."
msgstr ""

#: celery.app.disable_trace:1 of
msgid "Disable tracing of app instances."
msgstr ""

#: celery.app.amqp:1 of
msgid "Sending/Receiving Messages (Kombu integration)."
msgstr ""

#: ../../reference/celery.app.amqp.rst:9
msgid "AMQP"
msgstr ""

#: celery.app.amqp.AMQP:1 of
msgid "App AMQP API: app.amqp."
msgstr ""

#: ../../reference/celery.app.amqp.rst:15
msgid "Broker connection class used. Default is :class:`kombu.Connection`."
msgstr ""

#: ../../reference/celery.app.amqp.rst:19
msgid "Base Consumer class used. Default is :class:`kombu.Consumer`."
msgstr ""

#: ../../reference/celery.app.amqp.rst:23
msgid "Base Producer class used. Default is :class:`kombu.Producer`."
msgstr ""

#: ../../reference/celery.app.amqp.rst:27
msgid "All currently defined task queues (a :class:`Queues` instance)."
msgstr ""

#: celery.app.amqp.AMQP.Router:1 of
msgid "Return the current task router."
msgstr ""

#: ../../reference/celery.app.amqp.rst:42
msgid "Queues"
msgstr ""

#: celery.app.amqp.Queues:1 of
msgid "Queue name⇒ declaration mapping."
msgstr ""

#: celery.app.amqp.Queues:3 of
msgid "Initial list/tuple or dict of queues."
msgstr ""

#: celery.app.amqp.Queues:5 of
msgid ""
"By default any unknown queues will be added automatically, but if this "
"flag is disabled the occurrence of unknown queues in `wanted` will raise "
":exc:`KeyError`."
msgstr ""

#: celery.app.amqp.Queues:9 of
msgid "Default HA policy for queues with none set."
msgstr ""

#: celery.app.amqp.Queues:11 of
msgid "Default x-max-priority for queues with none set."
msgstr ""

#: celery.app.amqp.Queues.add:1 of
msgid "Add new queue."
msgstr ""

#: celery.app.amqp.Queues.add:3 of
msgid ""
"The first argument can either be a :class:`kombu.Queue` instance, or the "
"name of a queue.  If the former the rest of the keyword arguments are "
"ignored, and options are simply taken from the queue instance."
msgstr ""

#: celery.app.amqp.Queues.add:8 of
msgid "Queue to add."
msgstr ""

#: celery.app.amqp.Queues.add:10 of
msgid "if queue is str, specifies exchange name."
msgstr ""

#: celery.app.amqp.Queues.add:12 of
msgid "if queue is str, specifies binding key."
msgstr ""

#: celery.app.amqp.Queues.add:14 of
msgid "if queue is str, specifies type of exchange."
msgstr ""

#: celery.app.amqp.Queues.add:16 of
msgid "Additional declaration options used when queue is a str."
msgstr ""

#: celery.app.amqp.Queues.deselect:1 of
msgid "Deselect queues so that they won't be consumed from."
msgstr ""

#: celery.app.amqp.Queues.deselect:3 of
msgid "Names of queues to avoid consuming from."
msgstr ""

#: celery.app.amqp.Queues.format:1 of
msgid "Format routing table into string for log dumps."
msgstr ""

#: celery.app.amqp.Queues.select:1 of
msgid "Select a subset of currently defined queues to consume from."
msgstr ""

#: celery.app.amqp.Queues.select:3 of
msgid "Names of queues to consume from."
msgstr ""

#: celery.app.amqp.Queues.select_add:1 of
msgid "Add new task queue that'll be consumed from."
msgstr ""

#: celery.app.amqp.Queues.select_add:3 of
msgid ""
"The queue will be active even when a subset has been selected using the "
":option:`celery worker -Q` option."
msgstr ""

#: ../../reference/celery.app.backends.rst:3
msgid "``celery.app.backends``"
msgstr ""

#: celery.app.backends:1 of
msgid "Backend selection."
msgstr ""

#: celery.app.backends.by_name:1 of
msgid "Get backend class by name/alias."
msgstr ""

#: celery.app.backends.by_url:1 of
msgid "Get backend class by URL."
msgstr ""

#: ../../reference/celery.app.builtins.rst:3
msgid "``celery.app.builtins``"
msgstr ""

#: celery.app.builtins:1 of
msgid "Built-in Tasks."
msgstr ""

#: celery.app.builtins:3 of
msgid "The built-in tasks are always available in all app instances."
msgstr ""

#: ../../reference/celery.app.control.rst:3
msgid "``celery.app.control``"
msgstr ""

#: celery.app.control:1 of
msgid "Worker Remote Control Client."
msgstr ""

#: celery.app.control:3 of
msgid ""
"Client for worker remote control commands. Server implementation is in "
":mod:`celery.worker.control`."
msgstr ""

#: celery.app.control.Inspect:1 of
msgid "API for app.control.inspect."
msgstr ""

#: celery.app.control.Control:1 of
msgid "Worker remote control client."
msgstr ""

#: celery.app.control.Control.Mailbox:1 of
msgid "Process Mailbox."
msgstr ""

#: celery.app.control.Control.add_consumer:1 of
msgid "Tell all (or specific) workers to start consuming from a new queue."
msgstr ""

#: celery.app.control.Control.add_consumer:3 of
msgid ""
"Only the queue name is required as if only the queue is specified then "
"the exchange/routing key will be set to the same name ( like automatic "
"queues do)."
msgstr ""

#: celery.app.control.Control.add_consumer:9 of
msgid ""
"This command does not respect the default queue/exchange options in the "
"configuration."
msgstr ""

#: celery.app.control.Control.add_consumer:12 of
msgid "Name of queue to start consuming from."
msgstr ""

#: celery.app.control.Control.add_consumer:14 of
msgid "Optional name of exchange."
msgstr ""

#: celery.app.control.Control.add_consumer:16 of
msgid ""
"Type of exchange (defaults to 'direct') command to, when empty broadcast "
"to all workers."
msgstr ""

#: celery.app.control.Control.add_consumer:19 of
msgid "Optional routing key."
msgstr ""

#: celery.app.control.Control.add_consumer:21 of
msgid "Additional options as supported by :meth:`kombu.entitiy.Queue.from_dict`."
msgstr ""

#: celery.app.control.Control.add_consumer:25 celery.app.control.Control.ping:6
#: celery.app.control.Control.rate_limit:11
#: celery.app.control.Control.revoke:15 of
msgid ":meth:`broadcast` for supported keyword arguments."
msgstr ""

#: celery.app.control.Control.autoscale:1 of
msgid "Change worker(s) autoscale setting."
msgstr ""

#: celery.app.control.Control.autoscale:3
#: celery.app.control.Control.cancel_consumer:3
#: celery.app.control.Control.disable_events:3
#: celery.app.control.Control.enable_events:3
#: celery.app.control.Control.pool_grow:3
#: celery.app.control.Control.pool_shrink:3 of
msgid "Supports the same arguments as :meth:`broadcast`."
msgstr ""

#: celery.app.control.Control.broadcast:1 of
msgid "Broadcast a control command to the celery workers."
msgstr ""

#: celery.app.control.Control.broadcast:3 of
msgid "Name of command to send."
msgstr ""

#: celery.app.control.Control.broadcast:5 of
msgid "Keyword arguments for the command."
msgstr ""

#: celery.app.control.Control.broadcast:7 of
msgid ""
"If set, a list of the hosts to send the command to, when empty broadcast "
"to all workers."
msgstr ""

#: celery.app.control.Control.broadcast:10 of
msgid ""
"Custom broker connection to use, if not set, a connection will be "
"acquired from the pool."
msgstr ""

#: celery.app.control.Control.broadcast:13 of
msgid "Wait for and return the reply."
msgstr ""

#: celery.app.control.Control.broadcast:15 of
msgid "Timeout in seconds to wait for the reply."
msgstr ""

#: celery.app.control.Control.broadcast:17 of
msgid "Limit number of replies."
msgstr ""

#: celery.app.control.Control.broadcast:19 of
msgid "Callback called immediately for each reply received."
msgstr ""

#: celery.app.control.Control.broadcast:22 of
msgid "Custom pattern string to match"
msgstr ""

#: celery.app.control.Control.broadcast:24 of
msgid "Custom matcher to run the pattern to match"
msgstr ""

#: celery.app.control.Control.cancel_consumer:1 of
msgid "Tell all (or specific) workers to stop consuming from ``queue``."
msgstr ""

#: celery.app.control.Control.disable_events:1 of
msgid "Tell all (or specific) workers to disable events."
msgstr ""

#: celery.app.control.Control.discard_all:1 celery.app.control.Control.purge:1
#: of
msgid "Discard all waiting tasks."
msgstr ""

#: celery.app.control.Control.discard_all:3 celery.app.control.Control.purge:3
#: of
msgid ""
"This will ignore all tasks waiting for execution, and they will be "
"deleted from the messaging server."
msgstr ""

#: celery.app.control.Control.discard_all:6 celery.app.control.Control.purge:6
#: of
msgid ""
"Optional specific connection instance to use.  If not provided a "
"connection will be acquired from the connection pool."
msgstr ""

#: celery.app.control.Control.discard_all:11
#: celery.app.control.Control.purge:11 of
msgid "the number of tasks discarded."
msgstr ""

#: celery.app.control.Control.enable_events:1 of
msgid "Tell all (or specific) workers to enable events."
msgstr ""

#: celery.app.control.Control.heartbeat:1 of
msgid "Tell worker(s) to send a heartbeat immediately."
msgstr ""

#: celery.app.control.Control.heartbeat:3
#: celery.app.control.Control.pool_restart:13
#: celery.app.control.Control.shutdown:3 of
msgid "Supports the same arguments as :meth:`broadcast`"
msgstr ""

#: celery.app.control.Control.ping:1 of
msgid "Ping all (or specific) workers."
msgstr ""

#: celery.app.control.Control.ping:3 of
msgid "List of ``{'hostname': reply}`` dictionaries."
msgstr ""

#: celery.app.control.Control.pool_grow:1 of
msgid "Tell all (or specific) workers to grow the pool by ``n``."
msgstr ""

#: celery.app.control.Control.pool_restart:1 of
msgid "Restart the execution pools of all or specific workers."
msgstr ""

#: celery.app.control.Control.pool_restart:3 of
msgid "List of modules to reload."
msgstr ""

#: celery.app.control.Control.pool_restart:5 of
msgid "Flag to enable module reloading.  Default is False."
msgstr ""

#: celery.app.control.Control.pool_restart:7 of
msgid "Function to reload a module."
msgstr ""

#: celery.app.control.Control.pool_restart:9 of
msgid "List of worker names to send this command to."
msgstr ""

#: celery.app.control.Control.pool_shrink:1 of
msgid "Tell all (or specific) workers to shrink the pool by ``n``."
msgstr ""

#: celery.app.control.Control.rate_limit:1 of
msgid "Tell workers to set a new rate limit for task by type."
msgstr ""

#: celery.app.control.Control.rate_limit:3 of
msgid "Name of task to change rate limit for."
msgstr ""

#: celery.app.control.Control.rate_limit:5 of
msgid ""
"The rate limit as tasks per second, or a rate limit string (`'100/m'`, "
"etc. see :attr:`celery.task.base.Task.rate_limit` for more information)."
msgstr ""

#: celery.app.control.Control.revoke:1 of
msgid "Tell all (or specific) workers to revoke a task by id."
msgstr ""

#: celery.app.control.Control.revoke:3 of
msgid ""
"If a task is revoked, the workers will ignore the task and not execute it"
" after all."
msgstr ""

#: celery.app.control.Control.revoke:6 of
msgid "Id of the task to revoke."
msgstr ""

#: celery.app.control.Control.revoke:8 celery.result.AsyncResult.revoke:6
#: celery.result.EagerResult.revoke:6 celery.result.ResultSet.revoke:3 of
msgid "Also terminate the process currently working on the task (if any)."
msgstr ""

#: celery.app.control.Control.revoke:11 celery.result.AsyncResult.revoke:9
#: celery.result.EagerResult.revoke:9 celery.result.ResultSet.revoke:6 of
msgid "Name of signal to send to process if terminate. Default is TERM."
msgstr ""

#: celery.app.control.Control.shutdown:1 of
msgid "Shutdown worker(s)."
msgstr ""

#: celery.app.control.Control.terminate:1 of
msgid "Tell all (or specific) workers to terminate a task by id."
msgstr ""

#: celery.app.control.Control.terminate:5 of
msgid ""
"This is just a shortcut to :meth:`revoke` with the terminate argument "
"enabled."
msgstr ""

#: celery.app.control.Control.time_limit:1 of
msgid "Tell workers to set time limits for a task by type."
msgstr ""

#: celery.app.control.Control.time_limit:3 of
msgid "Name of task to change time limits for."
msgstr ""

#: celery.app.control.Control.time_limit:5 of
msgid "New soft time limit (in seconds)."
msgstr ""

#: celery.app.control.Control.time_limit:7 of
msgid "New hard time limit (in seconds)."
msgstr ""

#: celery.app.control.Control.time_limit:9 of
msgid "arguments passed on to :meth:`broadcast`."
msgstr ""

#: celery.app.control.flatten_reply:1 of
msgid "Flatten node replies."
msgstr ""

#: celery.app.control.flatten_reply:3 of
msgid "Convert from a list of replies in this format::"
msgstr ""

#: celery.app.control.flatten_reply:8 of
msgid "into this format::"
msgstr ""

#: ../../reference/celery.app.defaults.rst:3
msgid "``celery.app.defaults``"
msgstr ""

#: celery.app.defaults:1 of
msgid "Configuration introspection and defaults."
msgstr ""

#: celery.app.defaults.Option:1 of
msgid "Decribes a Celery configuration option."
msgstr ""

#: celery.app.defaults.flatten:1 of
msgid "Flatten settings."
msgstr ""

#: celery.app.defaults.find:1 of
msgid "Find setting by name."
msgstr ""

#: ../../reference/celery.app.events.rst:3
msgid "``celery.app.events``"
msgstr ""

#: celery.app.events:1 of
msgid "Implementation for the app.events shortcuts."
msgstr ""

#: celery.app.events.Events:1 of
msgid "Implements app.events."
msgstr ""

#: ../../reference/celery.app.log.rst:3
msgid "``celery.app.log``"
msgstr ""

#: celery.app.log:1 of
msgid "Logging configuration."
msgstr ""

#: celery.app.log:3 of
msgid "The Celery instances logging section: ``Celery.log``."
msgstr ""

#: celery.app.log:5 of
msgid ""
"Sets up logging for the worker and other programs, redirects standard "
"outs, colors log output, patches logging related compatibility fixes, and"
" so on."
msgstr ""

#: celery.app.log.TaskFormatter:1 of
msgid "Formatter for tasks, adding the task name and id."
msgstr ""

#: celery.app.log.TaskFormatter.format:1 of
msgid "Format the specified record as text."
msgstr ""

#: celery.app.log.TaskFormatter.format:3 of
msgid ""
"The record's attribute dictionary is used as the operand to a string "
"formatting operation which yields the returned string. Before formatting "
"the dictionary, a couple of preparatory steps are carried out. The "
"message attribute of the record is computed using LogRecord.getMessage()."
" If the formatting string uses the time (as determined by a call to "
"usesTime(), formatTime() is called to format the event time. If there is "
"exception information, it is formatted using formatException() and "
"appended to the message."
msgstr ""

#: celery.app.log.Logging:1 of
msgid "Application logging setup (app.log)."
msgstr ""

#: celery.app.log.Logging.redirect_stdouts_to_logger:1 of
msgid "Redirect :class:`sys.stdout` and :class:`sys.stderr` to logger."
msgstr ""

#: celery.app.log.Logging.redirect_stdouts_to_logger:3 of
msgid "Logger instance to redirect to."
msgstr ""

#: celery.app.log.Logging.redirect_stdouts_to_logger:5 of
msgid "The loglevel redirected message will be logged as."
msgstr ""

#: celery.app.log.Logging.setup_logger:1 of
msgid "Deprecated: No longer used."
msgstr ""

#: celery.app.log.Logging.setup_task_loggers:1 of
msgid "Setup the task logger."
msgstr ""

#: celery.app.log.Logging.setup_task_loggers:3 of
msgid "If `logfile` is not specified, then `sys.stderr` is used."
msgstr ""

#: celery.app.log.Logging.setup_task_loggers:5 of
msgid "Will return the base task logger object."
msgstr ""

#: ../../reference/celery.app.registry.rst:3
msgid "``celery.app.registry``"
msgstr ""

#: celery.app.registry:1 of
msgid "Registry of available tasks."
msgstr ""

#: celery.app.registry.TaskRegistry:1 of
msgid "Map of registered tasks."
msgstr ""

#: celery.app.registry.TaskRegistry.NotRegistered:1
#: celery.exceptions.NotRegistered:1 of
msgid "The task ain't registered."
msgstr ""

#: celery.app.registry.TaskRegistry.register:1 of
msgid "Register a task in the task registry."
msgstr ""

#: celery.app.registry.TaskRegistry.register:3 of
msgid ""
"The task will be automatically instantiated if not already an instance. "
"Name must be configured prior to registration."
msgstr ""

#: celery.app.registry.TaskRegistry.unregister:1 of
msgid "Unregister task by name."
msgstr ""

#: celery.app.registry.TaskRegistry.unregister:3 of
msgid ""
"name of the task to unregister, or a :class:`celery.task.base.Task` with "
"a valid `name` attribute."
msgstr ""

#: celery.app.registry.TaskRegistry.unregister celery.app.task.Task.apply_async
#: celery.app.task.Task.replace celery.app.task.Task.retry
#: celery.result.AsyncResult.get celery.result.AsyncResult.wait
#: celery.result.EagerResult.get celery.result.EagerResult.wait
#: celery.result.ResultSet.join celery.result.ResultSet.remove
#: celery.worker.request.Request.execute_using_pool of
msgid "raises"
msgstr ""

#: celery.app.registry.TaskRegistry.unregister:7 of
msgid ":exc:`celery.exceptions.NotRegistered` -- if the task is not registered."
msgstr ""

#: ../../reference/celery.app.task.rst:3
msgid "``celery.app.task``"
msgstr ""

#: celery.app.task:1 of
msgid "Task implementation: request context and the task base class."
msgstr ""

#: celery.app.task.Task:1 of
msgid "Task base class."
msgstr ""

#: celery.app.task.Task:5 of
msgid ""
"When called tasks apply the :meth:`run` method.  This method must be "
"defined by all tasks (that is unless the :meth:`__call__` method is "
"overridden)."
msgstr ""

#: celery.app.task.Task.AsyncResult:1 of
msgid "Get AsyncResult instance for this kind of task."
msgstr ""

#: celery.app.task.Task.AsyncResult:3 of
msgid "Task id to get result for."
msgstr ""

#: celery.app.task.Task.MaxRetriesExceededError:1
#: celery.exceptions.MaxRetriesExceededError:1 of
msgid "The tasks max restart limit has been exceeded."
msgstr ""

#: celery.app.task.Task.OperationalError:1 celery.exceptions.OperationalError:1
#: of
msgid "Recoverable message transport connection error."
msgstr ""

#: celery.app.task.Task.Request:1 of
msgid "Request class used, or the qualified name of one."
msgstr ""

#: celery.app.task.Task.Strategy:1 of
msgid "Execution strategy used, or the qualified name of one."
msgstr ""

#: celery.app.task.Task.abstract:1 of
msgid "Deprecated attribute ``abstract`` here for compatibility."
msgstr ""

#: celery.app.task.Task.acks_late:1 of
msgid ""
"When enabled messages for this task will be acknowledged **after** the "
"task has been executed, and not *just before* (the default behavior)."
msgstr ""

#: celery.app.task.Task.acks_late:5 of
msgid ""
"Please note that this means the task may be executed twice if the worker "
"crashes mid execution."
msgstr ""

#: celery.app.task.Task.acks_late:8 of
msgid ""
"The application default can be overridden with the "
":setting:`task_acks_late` setting."
msgstr ""

#: celery.app.task.Task.acks_on_failure_or_timeout:1 of
msgid ""
"When enabled messages for this task will be acknowledged even if it fails"
" or times out."
msgstr ""

#: celery.app.task.Task.acks_on_failure_or_timeout:4 of
msgid ""
"Configuring this setting only applies to tasks that are acknowledged "
"**after** they have been executed and only if :setting:`task_acks_late` "
"is enabled."
msgstr ""

#: celery.app.task.Task.acks_on_failure_or_timeout:8 of
msgid ""
"The application default can be overridden with the "
":setting:`task_acks_on_failure_or_timeout` setting."
msgstr ""

#: celery.app.task.Task.add_to_chord:1 of
msgid "Add signature to the chord the current task is a member of."
msgstr ""

#: celery.app.task.Task.add_to_chord:5 of
msgid "Currently only supported by the Redis result backend."
msgstr ""

#: celery.app.task.Task.add_to_chord:7 of
msgid "Signature to extend chord with."
msgstr ""

#: celery.app.task.Task.add_to_chord:9 of
msgid ""
"If enabled the new task won't actually be called, and ``sig.delay()`` "
"must be called manually."
msgstr ""

#: celery.app.task.Task.after_return:1 of
msgid "Handler called after the task returns."
msgstr ""

#: celery.app.task.Task.after_return:3 of
msgid "Current task state."
msgstr ""

#: celery.app.task.Task.after_return:5 of
msgid "Task return value/exception."
msgstr ""

#: celery.app.task.Task.after_return:7 of
msgid "Unique id of the task."
msgstr ""

#: celery.app.task.Task.after_return:9 of
msgid "Original arguments for the task."
msgstr ""

#: celery.app.task.Task.after_return:11 of
msgid "Original keyword arguments for the task."
msgstr ""

#: celery.app.task.Task.after_return:13 celery.app.task.Task.on_failure:13
#: celery.app.task.Task.on_retry:13 of
msgid "Exception information."
msgstr ""

#: celery.app.task.Task.after_return:16 celery.app.task.Task.on_failure:16
#: celery.app.task.Task.on_retry:16 celery.app.task.Task.on_success:14 of
msgid "The return value of this handler is ignored."
msgstr ""

#: celery.app.task.Task.apply:1 of
msgid "Execute this task locally, by blocking until the task returns."
msgstr ""

#: celery.app.task.Task.apply:3 of
msgid "positional arguments passed on to the task."
msgstr ""

#: celery.app.task.Task.apply:5 of
msgid "keyword arguments passed on to the task."
msgstr ""

#: celery.app.task.Task.apply:7 of
msgid ""
"Re-raise task exceptions. Defaults to the "
":setting:`task_eager_propagates` setting."
msgstr ""

#: celery.app.task.Task.apply:11 of
msgid "pre-evaluated result."
msgstr ""

#: celery.app.task.Task.apply_async:1 of
msgid "Apply tasks asynchronously by sending a message."
msgstr ""

#: celery.app.task.Task.apply_async:3 of
msgid "The positional arguments to pass on to the task."
msgstr ""

#: celery.app.task.Task.apply_async:5 of
msgid "The keyword arguments to pass on to the task."
msgstr ""

#: celery.app.task.Task.apply_async:7 of
msgid ""
"Number of seconds into the future that the task should execute.  Defaults"
" to immediate execution."
msgstr ""

#: celery.app.task.Task.apply_async:10 of
msgid ""
"Absolute time and date of when the task should be executed.  May not be "
"specified if `countdown` is also supplied."
msgstr ""

#: celery.app.task.Task.apply_async:14 of
msgid ""
"Datetime or seconds in the future for the task should expire. The task "
"won't be executed after the expiration time."
msgstr ""

#: celery.app.task.Task.apply_async:18 of
msgid ""
"Override task name used in logs/monitoring. Default is retrieved from "
":meth:`shadow_name`."
msgstr ""

#: celery.app.task.Task.apply_async:21 of
msgid ""
"Re-use existing broker connection instead of acquiring one from the "
"connection pool."
msgstr ""

#: celery.app.task.Task.apply_async:24 of
msgid ""
"If enabled sending of the task message will be retried in the event of "
"connection loss or failure. Default is taken from the "
":setting:`task_publish_retry` setting.  Note that you need to handle the "
"producer/connection manually for this to work."
msgstr ""

#: celery.app.task.Task.apply_async:30 of
msgid ""
"Override the retry policy used. See the "
":setting:`task_publish_retry_policy` setting."
msgstr ""

#: celery.app.task.Task.apply_async:33 of
msgid ""
"The queue to route the task to. This must be a key present in "
":setting:`task_queues`, or :setting:`task_create_missing_queues` must be "
"enabled.  See :ref:`guide-routing` for more information."
msgstr ""

#: celery.app.task.Task.apply_async:39 of
msgid ""
"Named custom exchange to send the task to.  Usually not used in "
"combination with the ``queue`` argument."
msgstr ""

#: celery.app.task.Task.apply_async:43 of
msgid ""
"Custom routing key used to route the task to a worker server.  If in "
"combination with a ``queue`` argument only used to specify custom routing"
" keys to topic exchanges."
msgstr ""

#: celery.app.task.Task.apply_async:47 of
msgid ""
"The task priority, a number between 0 and 9. Defaults to the "
":attr:`priority` attribute."
msgstr ""

#: celery.app.task.Task.apply_async:50 of
msgid ""
"Serialization method to use. Can be `pickle`, `json`, `yaml`, `msgpack` "
"or any custom serialization method that's been registered with "
":mod:`kombu.serialization.registry`. Defaults to the :attr:`serializer` "
"attribute."
msgstr ""

#: celery.app.task.Task.apply_async:56 of
msgid ""
"Optional compression method to use.  Can be one of ``zlib``, ``bzip2``, "
"or any custom compression methods registered with "
":func:`kombu.compression.register`. Defaults to the "
":setting:`task_compression` setting."
msgstr ""

#: celery.app.task.Task.apply_async:62 of
msgid ""
"A single, or a list of tasks signatures to apply if the task returns "
"successfully."
msgstr ""

#: celery.app.task.Task.apply_async:65 of
msgid ""
"A single, or a list of task signatures to apply if an error occurs while "
"executing the task."
msgstr ""

#: celery.app.task.Task.apply_async:68 of
msgid "custom producer to use when publishing the task."
msgstr ""

#: celery.app.task.Task.apply_async:71 of
msgid ""
"If set to True (default) and the task is applied while executing another "
"task, then the result will be appended to the parent tasks "
"``request.children`` attribute.  Trailing can also be disabled by default"
" using the :attr:`trail` attribute"
msgstr ""

#: celery.app.task.Task.apply_async:77 of
msgid "Deprecated alias to ``producer``."
msgstr ""

#: celery.app.task.Task.apply_async:79 of
msgid "Message headers to be included in the message."
msgstr ""

#: celery.app.task.Task.apply_async:82 of
msgid "Promise of future evaluation."
msgstr ""

#: celery.app.task.Task.apply_async:85 of
msgid ""
":exc:`TypeError` -- If not enough arguments are passed, or too many "
"arguments are passed.  Note that signature checks may be disabled by "
"specifying ``@task(typing=False)``."
msgstr ""

#: celery.app.task.Task.apply_async:88 of
msgid ""
":exc:`kombu.exceptions.OperationalError` -- If a connection to the "
"transport cannot be made, or if the connection is lost."
msgstr ""

#: celery.app.task.Task.apply_async:93 of
msgid ""
"Also supports all keyword arguments supported by "
":meth:`kombu.Producer.publish`."
msgstr ""

#: celery.app.task.Task.autoregister:1 of
msgid "If disabled this task won't be registered automatically."
msgstr ""

#: celery.app.task.Task.backend:1 of
msgid "The result store backend used for this task."
msgstr ""

#: celery.app.task.Task.chunks:1 of
msgid "Create a :class:`~celery.canvas.chunks` task for this task."
msgstr ""

#: celery.app.task.Task.default_retry_delay:1 of
msgid ""
"Default time in seconds before a retry of the task should be executed.  3"
" minutes by default."
msgstr ""

#: celery.app.task.Task.delay:1 of
msgid "Star argument version of :meth:`apply_async`."
msgstr ""

#: celery.app.task.Task.delay:3 of
msgid "Does not support the extra options enabled by :meth:`apply_async`."
msgstr ""

#: celery.app.task.Task.delay:5 of
msgid "Positional arguments passed on to the task."
msgstr ""

#: celery.app.task.Task.delay:7 of
msgid "Keyword arguments passed on to the task."
msgstr ""

#: celery.app.task.Task.delay:10 of
msgid "Future promise."
msgstr ""

#: celery.app.task.Task.expires:1 of
msgid "Default task expiry time."
msgstr ""

#: celery.app.task.Task.ignore_result:1 of
msgid ""
"If enabled the worker won't store task state and return values for this "
"task.  Defaults to the :setting:`task_ignore_result` setting."
msgstr ""

#: celery.app.task.Task.map:1 of
msgid "Create a :class:`~celery.canvas.xmap` task from ``it``."
msgstr ""

#: celery.app.task.Task.max_retries:1 of
msgid ""
"Maximum number of retries before giving up.  If set to :const:`None`, it "
"will **never** stop retrying."
msgstr ""

#: celery.app.task.Task.name:1 of
msgid "Name of the task."
msgstr ""

#: celery.app.task.Task.on_bound:1 of
msgid "Called when the task is bound to an app."
msgstr ""

#: celery.app.task.Task.on_bound:5 of
msgid ""
"This class method can be defined to do additional actions when the task "
"class is bound to an app."
msgstr ""

#: celery.app.task.Task.on_failure:1 of
msgid "Error handler."
msgstr ""

#: celery.app.task.Task.on_failure:3 of
msgid "This is run by the worker when the task fails."
msgstr ""

#: celery.app.task.Task.on_failure:5 of
msgid "The exception raised by the task."
msgstr ""

#: celery.app.task.Task.on_failure:7 of
msgid "Unique id of the failed task."
msgstr ""

#: celery.app.task.Task.on_failure:9 of
msgid "Original arguments for the task that failed."
msgstr ""

#: celery.app.task.Task.on_failure:11 of
msgid "Original keyword arguments for the task that failed."
msgstr ""

#: celery.app.task.Task.on_retry:1 of
msgid "Retry handler."
msgstr ""

#: celery.app.task.Task.on_retry:3 of
msgid "This is run by the worker when the task is to be retried."
msgstr ""

#: celery.app.task.Task.on_retry:5 of
msgid "The exception sent to :meth:`retry`."
msgstr ""

#: celery.app.task.Task.on_retry:7 of
msgid "Unique id of the retried task."
msgstr ""

#: celery.app.task.Task.on_retry:9 of
msgid "Original arguments for the retried task."
msgstr ""

#: celery.app.task.Task.on_retry:11 of
msgid "Original keyword arguments for the retried task."
msgstr ""

#: celery.app.task.Task.on_success:1 of
msgid "Success handler."
msgstr ""

#: celery.app.task.Task.on_success:3 of
msgid "Run by the worker if the task executes successfully."
msgstr ""

#: celery.app.task.Task.on_success:5 of
msgid "The return value of the task."
msgstr ""

#: celery.app.task.Task.on_success:7 of
msgid "Unique id of the executed task."
msgstr ""

#: celery.app.task.Task.on_success:9 of
msgid "Original arguments for the executed task."
msgstr ""

#: celery.app.task.Task.on_success:11 of
msgid "Original keyword arguments for the executed task."
msgstr ""

#: celery.app.task.Task.priority:1 of
msgid "Default task priority."
msgstr ""

#: celery.app.task.Task.rate_limit:1 of
msgid ""
":const:`None` (no rate limit), `'100/s'` (hundred tasks a second), "
"`'100/m'` (hundred tasks a minute),`'100/h'` (hundred tasks an hour)"
msgstr ""

#: celery.app.task.Task.rate_limit:5 of
msgid "Rate limit for this task type.  Examples"
msgstr ""

#: celery.app.task.Task.reject_on_worker_lost:1 of
msgid ""
"Even if :attr:`acks_late` is enabled, the worker will acknowledge tasks "
"when the worker process executing them abruptly exits or is signaled "
"(e.g., :sig:`KILL`/:sig:`INT`, etc)."
msgstr ""

#: celery.app.task.Task.reject_on_worker_lost:5 of
msgid ""
"Setting this to true allows the message to be re-queued instead, so that "
"the task will execute again by the same worker, or another worker."
msgstr ""

#: celery.app.task.Task.reject_on_worker_lost:9 of
msgid ""
"Warning: Enabling this can cause message loops; make sure you know what "
"you're doing."
msgstr ""

#: celery.app.task.Task.replace:1 of
msgid "Replace this task, with a new task inheriting the task id."
msgstr ""

#: celery.app.task.Task.replace:5 of
msgid "signature to replace with."
msgstr ""

#: celery.app.task.Task.replace:8 of
msgid ":exc:`~@Ignore` -- This is always raised, so the best practice"
msgstr ""

#: celery.app.task.Task.replace:9 of
msgid "is to always use ``raise self.replace(...)`` to convey"
msgstr ""

#: celery.app.task.Task.replace:10 of
msgid "to the reader that the task won't continue after being replaced."
msgstr ""

#: celery.app.task.Task.request:1 of
msgid "Get current request object."
msgstr ""

#: celery.app.task.Task.request_stack:1 of
msgid "Task request stack, the current request will be the topmost."
msgstr ""

#: celery.app.task.Task.resultrepr_maxsize:1 of
msgid "Max length of result representation used in logs and events."
msgstr ""

#: celery.app.task.Task.retry:1 of
msgid "Retry the task, adding it to the back of the queue."
msgstr ""

#: celery.app.task.Task.retry:19 of
msgid ""
"Although the task will never return above as `retry` raises an exception "
"to notify the worker, we use `raise` in front of the retry to convey that"
" the rest of the block won't be executed."
msgstr ""

#: celery.app.task.Task.retry:23 of
msgid "Positional arguments to retry with."
msgstr ""

#: celery.app.task.Task.retry:25 of
msgid "Keyword arguments to retry with."
msgstr ""

#: celery.app.task.Task.retry:27 of
msgid ""
"Custom exception to report when the max retry limit has been exceeded "
"(default: :exc:`~@MaxRetriesExceededError`).  If this argument is set and"
" retry is called while an exception was raised (``sys.exc_info()`` is "
"set) it will attempt to re-raise the current exception.  If no exception "
"was raised it will raise the ``exc`` argument provided."
msgstr ""

#: celery.app.task.Task.retry:27 of
msgid ""
"Custom exception to report when the max retry limit has been exceeded "
"(default: :exc:`~@MaxRetriesExceededError`)."
msgstr ""

#: celery.app.task.Task.retry:31 of
msgid ""
"If this argument is set and retry is called while an exception was raised"
" (``sys.exc_info()`` is set) it will attempt to re-raise the current "
"exception."
msgstr ""

#: celery.app.task.Task.retry:35 of
msgid "If no exception was raised it will raise the ``exc`` argument provided."
msgstr ""

#: celery.app.task.Task.retry:38 of
msgid "Time in seconds to delay the retry for."
msgstr ""

#: celery.app.task.Task.retry:40 of
msgid "Explicit time and date to run the retry at."
msgstr ""

#: celery.app.task.Task.retry:43 of
msgid ""
"If set, overrides the default retry limit for this execution.  Changes to"
" this parameter don't propagate to subsequent task retry attempts.  A "
"value of :const:`None`, means \"use the default\", so if you want "
"infinite retries you'd have to set the :attr:`max_retries` attribute of "
"the task to :const:`None` first."
msgstr ""

#: celery.app.task.Task.retry:50 of
msgid "If set, overrides the default time limit."
msgstr ""

#: celery.app.task.Task.retry:52 of
msgid "If set, overrides the default soft time limit."
msgstr ""

#: celery.app.task.Task.retry:55 of
msgid ""
"If this is :const:`False`, don't raise the :exc:`~@Retry` exception, that"
" tells the worker to mark the task as being retried.  Note that this "
"means the task will be marked as failed if the task raises an exception, "
"or successful if it returns after the retry call."
msgstr ""

#: celery.app.task.Task.retry:61 of
msgid "Extra options to pass on to :meth:`apply_async`."
msgstr ""

#: celery.app.task.Task.retry:64 of
msgid ""
":exc:`celery.exceptions.Retry` -- To tell the worker that the task has "
"been re-sent for retry. This always happens, unless the `throw` keyword "
"argument has been explicitly set to :const:`False`, and is considered "
"normal operation."
msgstr ""

#: celery.app.task.Task.run:1 of
msgid "The body of the task executed by workers."
msgstr ""

#: celery.app.task.Task.s:1 celery.app.task.Task.signature:1
#: celery.app.task.Task.subtask:1 of
msgid "Create signature."
msgstr ""

#: celery.app.task.Task.s:3 of
msgid "Shortcut for ``.s(*a, **k) -> .signature(a, k)``."
msgstr ""

#: celery.app.task.Task.send_event:1 of
msgid "Send monitoring event message."
msgstr ""

#: celery.app.task.Task.send_event:3 of
msgid ""
"This can be used to add custom event types in :pypi:`Flower` and other "
"monitors."
msgstr ""

#: celery.app.task.Task.send_event:6 of
msgid "Type of event, e.g. ``\"task-failed\"``."
msgstr ""

#: celery.app.task.Task.send_event:9 of
msgid ""
"Retry sending the message if the connection is lost.  Default is taken "
"from the :setting:`task_publish_retry` setting."
msgstr ""

#: celery.app.task.Task.send_event:13 of
msgid ""
"Retry settings.  Default is taken from the "
":setting:`task_publish_retry_policy` setting."
msgstr ""

#: celery.app.task.Task.send_event:16 of
msgid "Map containing information about the event. Must be JSON serializable."
msgstr ""

#: celery.app.task.Task.send_events:1 of
msgid ""
"If enabled the worker will send monitoring events related to this task "
"(but only if the worker is configured to send task related events). Note "
"that this has no effect on the task-failure event case where a task is "
"not registered (as it will have no task class to check this flag)."
msgstr ""

#: celery.app.task.Task.serializer:1 of
msgid ""
"The name of a serializer that are registered with "
":mod:`kombu.serialization.registry`.  Default is `'pickle'`."
msgstr ""

#: celery.app.task.Task.shadow_name:1 of
msgid "Override for custom task name in worker logs/monitoring."
msgstr ""

#: celery.app.task.Task.shadow_name:16 of
msgid "Task positional arguments."
msgstr ""

#: celery.app.task.Task.shadow_name:18 of
msgid "Task keyword arguments."
msgstr ""

#: celery.app.task.Task.shadow_name:20 celery.beat.ScheduleEntry.options:1 of
msgid "Task execution options."
msgstr ""

#: celery.app.task.Task.si:1 of
msgid "Create immutable signature."
msgstr ""

#: celery.app.task.Task.si:3 of
msgid "Shortcut for ``.si(*a, **k) -> .signature(a, k, immutable=True)``."
msgstr ""

#: celery.app.task.Task.signature:3 celery.app.task.Task.subtask:3 of
msgid ""
"object for     this task, wrapping arguments and execution options     "
"for a single task invocation."
msgstr ""

#: celery.app.task.Task.signature:6 celery.app.task.Task.subtask:6 of
msgid "object for"
msgstr ""

#: celery.app.task.Task.signature:6 celery.app.task.Task.subtask:6 of
msgid ""
"this task, wrapping arguments and execution options for a single task "
"invocation."
msgstr ""

#: celery.app.task.Task.signature:8 celery.app.task.Task.subtask:8 of
msgid ":class:`~celery.signature`"
msgstr ""

#: celery.app.task.Task.soft_time_limit:1 of
msgid "Soft time limit. Defaults to the :setting:`task_soft_time_limit` setting."
msgstr ""

#: celery.app.task.Task.starmap:1 of
msgid "Create a :class:`~celery.canvas.xstarmap` task from ``it``."
msgstr ""

#: celery.app.task.Task.store_errors_even_if_ignored:1 of
msgid ""
"When enabled errors will be stored even if the task is otherwise "
"configured to ignore results."
msgstr ""

#: celery.app.task.Task.throws:1 of
msgid "Tuple of expected exceptions."
msgstr ""

#: celery.app.task.Task.throws:3 of
msgid ""
"These are errors that are expected in normal operation and that shouldn't"
" be regarded as a real error by the worker. Currently this means that the"
" state will be updated to an error state, but the worker won't log the "
"event as an error."
msgstr ""

#: celery.app.task.Task.time_limit:1 of
msgid "Hard time limit. Defaults to the :setting:`task_time_limit` setting."
msgstr ""

#: celery.app.task.Task.track_started:1 of
msgid ""
"If enabled the task will report its status as 'started' when the task is "
"executed by a worker.  Disabled by default as the normal behavior is to "
"not report that level of granularity.  Tasks are either pending, "
"finished, or waiting to be retried."
msgstr ""

#: celery.app.task.Task.track_started:6 of
msgid ""
"Having a 'started' status can be useful for when there are long running "
"tasks and there's a need to report what task is currently running."
msgstr ""

#: celery.app.task.Task.track_started:10 of
msgid ""
"The application default can be overridden using the "
":setting:`task_track_started` setting."
msgstr ""

#: celery.app.task.Task.trail:1 of
msgid ""
"If enabled the request will keep track of subtasks started by this task, "
"and this information will be sent with the result (``result.children``)."
msgstr ""

#: celery.app.task.Task.typing:1 of
msgid ""
"Enable argument checking. You can set this to false if you don't want the"
" signature to be checked when calling the task. Defaults to "
":attr:`app.strict_typing <@Celery.strict_typing>`."
msgstr ""

#: celery.app.task.Task.update_state:1 of
msgid "Update task state."
msgstr ""

#: celery.app.task.Task.update_state:3 of
msgid "Id of the task to update. Defaults to the id of the current task."
msgstr ""

#: celery.app.task.Task.update_state:6 of
msgid "New state."
msgstr ""

#: celery.app.task.Task.update_state:8 of
msgid "State meta-data."
msgstr ""

#: celery.app.task.Context:1 of
msgid "Task request variables (Task.request)."
msgstr ""

#: ../../reference/celery.app.utils.rst:3
msgid "``celery.app.utils``"
msgstr ""

#: celery.app.utils:1 of
msgid "App utilities: Compat settings, bug-report tool, pickling apps."
msgstr ""

#: celery.app.utils.Settings:1 of
msgid "Celery settings object."
msgstr ""

#: celery.app.utils.Settings.find_option:1 of
msgid "Search for option by name."
msgstr ""

#: celery.app.utils.Settings.find_option:10 of
msgid "Name of option, cannot be partial."
msgstr ""

#: celery.app.utils.Settings.find_option:12 of
msgid "Preferred name-space (``None`` by default)."
msgstr ""

#: celery.app.utils.Settings.find_option:15 of
msgid "of ``(namespace, key, type)``."
msgstr ""

#: celery.app.utils.Settings.find_value_for_key:1 of
msgid "Shortcut to ``get_by_parts(*find_option(name)[:-1])``."
msgstr ""

#: celery.app.utils.Settings.get_by_parts:1 of
msgid "Return the current value for setting specified as a path."
msgstr ""

#: celery.app.utils.Settings.humanize:1 of
msgid "Return a human readable text showing configuration changes."
msgstr ""

#: celery.app.utils.Settings.without_defaults:1 of
msgid "Return the current configuration, but without defaults."
msgstr ""

#: celery.app.utils.appstr:1 of
msgid "String used in __repr__ etc, to id app instances."
msgstr ""

#: celery.app.utils.bugreport:1 of
msgid "Return a string containing information useful in bug-reports."
msgstr ""

#: celery.app.utils.filter_hidden_settings:1 of
msgid "Filter sensitive settings."
msgstr ""

#: celery.app.utils.find_app:1 of
msgid "Find app by name."
msgstr ""

#: ../../reference/celery.apps.beat.rst:3
msgid "``celery.apps.beat``"
msgstr ""

#: celery.apps.beat:1 of
msgid "Beat command-line program."
msgstr ""

#: celery.apps.beat:3 of
msgid "This module is the 'program-version' of :mod:`celery.beat`."
msgstr ""

#: celery.apps.beat:5 of
msgid ""
"It does everything necessary to run that module as an actual application,"
" like installing signal handlers and so on."
msgstr ""

#: celery.apps.beat.Beat:1 of
msgid "Beat as a service."
msgstr ""

#: celery.apps.beat.Beat.Service:1 celery.beat.Service:1 of
msgid "Celery periodic task service."
msgstr ""

#: celery.apps.beat.Beat.install_sync_handler:1 of
msgid "Install a `SIGTERM` + `SIGINT` handler saving the schedule."
msgstr ""

#: ../../reference/celery.apps.multi.rst:3
msgid "``celery.apps.multi``"
msgstr ""

#: celery.apps.multi:1 of
msgid "Start/stop/manage workers."
msgstr ""

#: celery.apps.multi.Cluster:1 of
msgid "Represent a cluster of workers."
msgstr ""

#: celery.apps.multi.Node:1 celery.bin.multi.MultiTool.MultiParser.Node:1 of
msgid "Represents a node in a cluster."
msgstr ""

#: ../../reference/celery.apps.worker.rst:3
msgid "``celery.apps.worker``"
msgstr ""

#: celery.apps.worker:1 of
msgid "Worker command-line program."
msgstr ""

#: celery.apps.worker:3 of
msgid "This module is the 'program-version' of :mod:`celery.worker`."
msgstr ""

#: celery.apps.worker:5 of
msgid ""
"It does everything necessary to run that module as an actual application,"
" like installing signal handlers, platform tweaks, and so on."
msgstr ""

#: celery.apps.worker.Worker:1 of
msgid "Worker as a program."
msgstr ""

#: celery.apps.worker.Worker.install_platform_tweaks:1 of
msgid "Install platform specific tweaks and workarounds."
msgstr ""

#: celery.apps.worker.Worker.macOS_proxy_detection_workaround:1 of
msgid "See https://github.com/celery/celery/issues#issue/161."
msgstr ""

#: ../../reference/celery.beat.rst:3
msgid "``celery.beat``"
msgstr ""

#: celery.beat:1 of
msgid "The periodic task scheduler."
msgstr ""

#: celery.beat.SchedulingError:1 of
msgid "An error occurred while scheduling a task."
msgstr ""

#: celery.beat.ScheduleEntry:1 of
msgid "An entry in the scheduler."
msgstr ""

#: celery.beat.ScheduleEntry:3 of
msgid "see :attr:`name`."
msgstr ""

#: celery.beat.ScheduleEntry:5 celery.beat.Scheduler:8 of
msgid "see :attr:`schedule`."
msgstr ""

#: celery.beat.ScheduleEntry:7 celery.bin.amqp.Spec:6 of
msgid "see :attr:`args`."
msgstr ""

#: celery.beat.ScheduleEntry:9 of
msgid "see :attr:`kwargs`."
msgstr ""

#: celery.beat.ScheduleEntry:11 of
msgid "see :attr:`options`."
msgstr ""

#: celery.beat.ScheduleEntry:13 of
msgid "see :attr:`last_run_at`."
msgstr ""

#: celery.beat.ScheduleEntry:15 of
msgid "see :attr:`total_run_count`."
msgstr ""

#: celery.beat.ScheduleEntry:17 of
msgid "Is the time relative to when the server starts?"
msgstr ""

#: celery.beat.ScheduleEntry.is_due:1 of
msgid "See :meth:`~celery.schedule.schedule.is_due`."
msgstr ""

#: celery.beat.ScheduleEntry.last_run_at:1 of
msgid "The time and date of when this task was last scheduled."
msgstr ""

#: celery.beat.ScheduleEntry.name:1 of
msgid "The task name"
msgstr ""

#: celery.beat.ScheduleEntry.next:1 of
msgid "Return new instance, with date and count fields updated."
msgstr ""

#: celery.beat.ScheduleEntry.schedule:1 of
msgid "The schedule (:class:`~celery.schedules.schedule`)"
msgstr ""

#: celery.beat.ScheduleEntry.total_run_count:1 of
msgid "Total number of times this task has been scheduled."
msgstr ""

#: celery.beat.ScheduleEntry.update:1 of
msgid "Update values from another entry."
msgstr ""

#: celery.beat.ScheduleEntry.update:3 of
msgid "Will only update \"editable\" fields:"
msgstr ""

#: celery.beat.ScheduleEntry.update:4 of
msgid "``task``, ``schedule``, ``args``, ``kwargs``, ``options``."
msgstr ""

#: celery.beat.Scheduler:1 of
msgid "Scheduler for periodic tasks."
msgstr ""

#: celery.beat.Scheduler:3 of
msgid ""
"The :program:`celery beat` program may instantiate this class multiple "
"times for introspection purposes, but then with the ``lazy`` argument "
"set.  It's important for subclasses to be idempotent when this argument "
"is set."
msgstr ""

#: celery.beat.Scheduler:10 of
msgid "see :attr:`max_interval`."
msgstr ""

#: celery.beat.Scheduler:12 of
msgid "Don't set up the schedule."
msgstr ""

#: celery.beat.Scheduler.max_interval:1 of
msgid "Maximum time to sleep between re-checking the schedule."
msgstr ""

#: celery.beat.Scheduler.populate_heap:1 of
msgid "Populate the heap with the data contained in the schedule."
msgstr ""

#: celery.beat.Scheduler.schedule:1 of
msgid "The schedule dict/shelve."
msgstr ""

#: celery.beat.Scheduler.sync_every:1 of
msgid "How often to sync the schedule (3 minutes by default)"
msgstr ""

#: celery.beat.Scheduler.sync_every_tasks:1 of
msgid "How many tasks can be called before a sync is forced."
msgstr ""

#: celery.beat.Scheduler.tick:1 of
msgid "Run a tick - one iteration of the scheduler."
msgstr ""

#: celery.beat.Scheduler.tick:3 of
msgid "Executes one due task per call."
msgstr ""

#: celery.beat.Scheduler.tick:5 of
msgid "preferred delay in seconds for next call."
msgstr ""

#: celery.beat.PersistentScheduler:1 of
msgid "Scheduler backed by :mod:`shelve` database."
msgstr ""

#: celery.beat.EmbeddedService:1 of
msgid "Return embedded clock service."
msgstr ""

#: celery.beat.EmbeddedService:3 of
msgid ""
"Run threaded instead of as a separate process. Uses "
":mod:`multiprocessing` by default, if available."
msgstr ""

#: ../../reference/celery.bin.amqp.rst:3
msgid "``celery.bin.amqp``"
msgstr ""

#: celery.bin.amqp:1 of
msgid "The :program:`celery amqp` command."
msgstr ""

#: celery.bin.amqp.AMQPAdmin:1 of
msgid "The celery :program:`celery amqp` utility."
msgstr ""

#: celery.bin.amqp.AMQShell:1 of
msgid "AMQP API Shell."
msgstr ""

#: celery.bin.amqp.AMQShell:3 of
msgid ""
"Function used to connect to the server. Must return "
":class:`kombu.Connection` object."
msgstr ""

#: celery.bin.amqp.AMQShell:6 of
msgid ""
"If enabled, the commands won't have annoying output not relevant when "
"running in non-shell mode."
msgstr ""

#: celery.bin.amqp.AMQShell.amqp:1 of
msgid "Map of AMQP API commands and their :class:`Spec`."
msgstr ""

#: celery.bin.amqp.AMQShell.builtins:1 of
msgid "Map of built-in command names -> method names"
msgstr ""

#: celery.bin.amqp.AMQShell.completenames:1 of
msgid "Return all commands starting with `text`, for tab-completion."
msgstr ""

#: celery.bin.amqp.AMQShell.default:1 of
msgid "Called on an input line when the command prefix is not recognized."
msgstr ""

#: celery.bin.amqp.AMQShell.default:3 of
msgid "If this method is not overridden, it prints an error message and returns."
msgstr ""

#: celery.bin.amqp.AMQShell.dispatch:1 of
msgid "Dispatch and execute the command."
msgstr ""

#: celery.bin.amqp.AMQShell.dispatch:3 of
msgid "Look-up order is: :attr:`builtins` -> :attr:`amqp`."
msgstr ""

#: celery.bin.amqp.AMQShell.do_exit:1 of
msgid "The `'exit'` command."
msgstr ""

#: celery.bin.amqp.AMQShell.do_help:1 of
msgid "List available commands with \"help\" or detailed help with \"help cmd\"."
msgstr ""

#: celery.bin.amqp.AMQShell.get_amqp_api_command:1 of
msgid "Get AMQP command wrapper."
msgstr ""

#: celery.bin.amqp.AMQShell.get_amqp_api_command:3 of
msgid ""
"With a command name and a list of arguments, convert the arguments to "
"Python values and find the corresponding method on the AMQP channel "
"object."
msgstr ""

#: celery.bin.amqp.AMQShell.get_amqp_api_command:7 of
msgid "of `(method, processed_args)` pairs."
msgstr ""

#: celery.bin.amqp.AMQShell.note:1 of
msgid "Say something to the user.  Disabled if :attr:`silent`."
msgstr ""

#: celery.bin.amqp.AMQShell.onecmd:1 of
msgid "Parse line and execute command."
msgstr ""

#: celery.bin.amqp.AMQShell.parseline:1 of
msgid "Parse input line."
msgstr ""

#: celery.bin.amqp.AMQShell.parseline:3 of
msgid "of three items:     `(command_name, arglist, original_line)`"
msgstr ""

#: celery.bin.amqp.AMQShell.parseline:5 of
msgid "of three items:"
msgstr ""

#: celery.bin.amqp.AMQShell.parseline:6 of
msgid "`(command_name, arglist, original_line)`"
msgstr ""

#: celery.bin.amqp.AMQShell.prompt:1 of
msgid "str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str"
msgstr ""

#: celery.bin.amqp.AMQShell.prompt:4 of
msgid ""
"Create a new string object from the given object. If encoding or errors "
"is specified, then the object must expose a data buffer that will be "
"decoded using the given encoding and error handler. Otherwise, returns "
"the result of object.__str__() (if defined) or repr(object). encoding "
"defaults to sys.getdefaultencoding(). errors defaults to 'strict'."
msgstr ""

#: celery.bin.amqp.AMQShell.respond:1 of
msgid "What to do with the return value of a command."
msgstr ""

#: celery.bin.amqp.Spec:1 of
msgid "AMQP Command specification."
msgstr ""

#: celery.bin.amqp.Spec:3 of
msgid ""
"Used to convert arguments to Python values and display various help and "
"tool-tips."
msgstr ""

#: celery.bin.amqp.Spec:8 of
msgid "see :attr:`returns`."
msgstr ""

#: celery.bin.amqp.Spec.args:1 of
msgid ""
"List of arguments this command takes. Should contain ``(argument_name, "
"argument_type)`` tuples."
msgstr ""

#: celery.bin.amqp.Spec.coerce:1 of
msgid "Coerce value for argument at index."
msgstr ""

#: celery.bin.amqp.Spec.format_response:1 of
msgid "Format the return value of this command in a human-friendly way."
msgstr ""

#: celery.bin.amqp.Spec.returns:1 of
msgid ""
"Helpful human string representation of what this command returns. May be "
":const:`None`, to signify the return type is unknown."
msgstr ""

#: celery.bin.amqp.Spec.str_args_to_python:1 of
msgid "Process list of string arguments to values according to spec."
msgstr ""

#: celery.bin.amqp.amqp:1 of
msgid "AMQP Administration Shell."
msgstr ""

#: celery.bin.amqp.amqp:3 of
msgid ""
"Also works for non-AMQP transports (but not ones that store declarations "
"in memory)."
msgstr ""

#: ../../reference/celery.bin.base.rst:3
msgid "``celery.bin.base``"
msgstr ""

#: celery.bin.base:1 of
msgid "Base command-line interface."
msgstr ""

#: celery.bin.base.Command.Error:1 celery.bin.base.Error:1 of
msgid "Exception raised by commands."
msgstr ""

#: celery.bin.base.Command.UsageError:1 celery.bin.base.UsageError:1 of
msgid "Exception raised for malformed arguments."
msgstr ""

#: celery.bin.base.Extensions:1 of
msgid "Loads extensions from setuptools entrypoints."
msgstr ""

#: celery.bin.base.Command:1 of
msgid "Base class for command-line applications."
msgstr ""

#: celery.bin.base.Command:3 of
msgid "The app to use."
msgstr ""

#: celery.bin.base.Command:5 of
msgid "Fucntion returning the current app when no app provided."
msgstr ""

#: celery.bin.base.Command.args:1 of
msgid "Arg list used in help."
msgstr ""

#: celery.bin.base.Command.args_name:1 of
msgid "Name of argparse option used for parsing positional args."
msgstr ""

#: celery.bin.base.Command.ask:1 of
msgid "Prompt user to choose from a tuple of string values."
msgstr ""

#: celery.bin.base.Command.ask:3 of
msgid ""
"If a default is not specified the question will be repeated until the "
"user gives a valid choice."
msgstr ""

#: celery.bin.base.Command.ask:6 of
msgid "Matching is case insensitive."
msgstr ""

#: celery.bin.base.Command.ask:8 of
msgid "the question to ask (don't include questionark)"
msgstr ""

#: celery.bin.base.Command.ask:10 of
msgid "tuple of possible choices, must be lowercase."
msgstr ""

#: celery.bin.base.Command.ask:12 of
msgid "Default value if any."
msgstr ""

#: celery.bin.base.Command.description:1 of
msgid "Text to print in --help before option list."
msgstr ""

#: celery.bin.base.Command.enable_config_from_cmdline:1 of
msgid "Enable if the application should support config from the cmdline."
msgstr ""

#: celery.bin.base.Command.epilog:1 of
msgid "Text to print at end of --help"
msgstr ""

#: celery.bin.base.Command.execute_from_commandline:1
#: celery.bin.celery.CeleryCommand.execute_from_commandline:1 of
msgid "Execute application from command-line."
msgstr ""

#: celery.bin.base.Command.execute_from_commandline:3
#: celery.bin.celery.CeleryCommand.execute_from_commandline:3 of
msgid "The list of command-line arguments. Defaults to ``sys.argv``."
msgstr ""

#: celery.bin.base.Command.handle_argv:1
#: celery.bin.celery.CeleryCommand.handle_argv:1 of
msgid "Parse arguments from argv and dispatch to :meth:`run`."
msgstr ""

#: celery.bin.base.Command.handle_argv:5
#: celery.bin.celery.CeleryCommand.handle_argv:5 of
msgid ""
"Exits with an error message if :attr:`supports_args` is disabled and "
"``argv`` contains positional arguments."
msgstr ""

#: celery.bin.base.Command.handle_argv:8
#: celery.bin.celery.CeleryCommand.handle_argv:8 of
msgid "The program name (``argv[0]``)."
msgstr ""

#: celery.bin.base.Command.handle_argv:10
#: celery.bin.celery.CeleryCommand.handle_argv:10 of
msgid "Rest of command-line arguments."
msgstr ""

#: celery.bin.base.Command.leaf:1 of
msgid "Set to true if this command doesn't have sub-commands"
msgstr ""

#: celery.bin.base.Command.namespace:1 of
msgid "Default configuration name-space."
msgstr ""

#: celery.bin.base.Command.option_list:1 of
msgid "List of options (without preload options)."
msgstr ""

#: celery.bin.base.Command.parse_options:1 of
msgid "Parse the available options."
msgstr ""

#: celery.bin.base.Command.supports_args:1 of
msgid ""
"If false the parser will raise an exception if positional args are "
"provided."
msgstr ""

#: celery.bin.base.Command.version:1 of
msgid "Application version."
msgstr ""

#: celery.bin.base.Command.with_pool_option:1
#: celery.bin.celery.CeleryCommand.with_pool_option:1
#: celery.bin.worker.worker.with_pool_option:1 of
msgid "Return tuple of ``(short_opts, long_opts)``."
msgstr ""

#: celery.bin.base.Command.with_pool_option:3
#: celery.bin.celery.CeleryCommand.with_pool_option:3
#: celery.bin.worker.worker.with_pool_option:3 of
msgid ""
"Returns only if the command supports a pool argument, and used to monkey "
"patch eventlet/gevent environments as early as possible."
msgstr ""

#: celery.bin.base.Option:17 of
msgid "Instance attributes:"
msgstr ""

#: celery.bin.base.Option:2 of
msgid "_short_opts : [string] _long_opts : [string]"
msgstr ""

#: celery.bin.base.Option:5 of
msgid ""
"action : string type : string dest : string default : any nargs : int "
"const : any choices : [string] callback : function callback_args : (any*)"
" callback_kwargs : { string : any } help : string metavar : string"
msgstr ""

#: celery.bin.base.daemon_options:1 of
msgid "Add daemon options to argparse parser."
msgstr ""

#: ../../reference/celery.bin.beat.rst:3
msgid "``celery.bin.beat``"
msgstr ""

#: celery.bin.beat:1 of
msgid "The :program:`celery beat` command."
msgstr ""

#: celery.bin.beat:7 celery.bin.events:7 of
msgid "See :ref:`preload-options` and :ref:`daemon-options`."
msgstr ""

#: celery.bin.beat:11 of
msgid "Detach and run in the background as a daemon."
msgstr ""

#: celery.bin.beat:15 of
msgid ""
"Path to the schedule database.  Defaults to `celerybeat-schedule`. The "
"extension '.db' may be appended to the filename. Default is {default}."
msgstr ""

#: celery.bin.beat:21 of
msgid "Scheduler class to use. Default is :class:`{default}`."
msgstr ""

#: celery.bin.beat:26 of
msgid "Max seconds to sleep between schedule iterations."
msgstr ""

#: celery.bin.beat:30 celery.bin.celery:52 celery.bin.events:36
#: celery.bin.worker:141 of
msgid "Path to log file.  If no logfile is specified, `stderr` is used."
msgstr ""

#: celery.bin.beat:34 celery.bin.worker:145 of
msgid ""
"Logging level, choose between `DEBUG`, `INFO`, `WARNING`, `ERROR`, "
"`CRITICAL`, or `FATAL`."
msgstr ""

#: celery.bin.beat:39 of
msgid "File used to store the process pid. Defaults to `celerybeat.pid`."
msgstr ""

#: celery.bin.beat:41 celery.bin.celery:58 celery.bin.events:42
#: celery.bin.worker:152 of
msgid ""
"The program won't start if this file already exists and the pid is still "
"alive."
msgstr ""

#: celery.bin.beat:46 celery.bin.celery:63 celery.bin.events:47
#: celery.bin.worker:157 of
msgid "User id, or user name of the user to run as after detaching."
msgstr ""

#: celery.bin.beat:50 celery.bin.celery:67 celery.bin.events:51
#: celery.bin.worker:161 of
msgid "Group id, or group name of the main group to change to after detaching."
msgstr ""

#: celery.bin.beat:55 celery.bin.celery:72 celery.bin.events:56 of
msgid ""
"Effective umask (in octal) of the process after detaching.  Inherits the "
"umask of the parent process by default."
msgstr ""

#: celery.bin.beat:60 celery.bin.celery:77 celery.bin.events:61
#: celery.bin.worker:171 of
msgid "Optional directory to change to after detaching."
msgstr ""

#: celery.bin.beat:64 celery.bin.celery:81 celery.bin.events:65
#: celery.bin.worker:175 of
msgid "Executable to use for the detached process."
msgstr ""

#: celery.bin.beat.beat:1 of
msgid "Start the beat periodic task scheduler."
msgstr ""

#: celery.bin.beat.beat:11 of
msgid ""
"The last example requires the :pypi:`django-celery-beat` extension "
"package found on PyPI."
msgstr ""

#: ../../reference/celery.bin.call.rst:3
msgid "``celery.bin.call``"
msgstr ""

#: celery.bin.call:1 of
msgid "The ``celery call`` program used to send tasks from the command-line."
msgstr ""

#: celery.bin.call.call:1 of
msgid "Call a task by name."
msgstr ""

#: ../../reference/celery.bin.celery.rst:3
msgid "``celery.bin.celery``"
msgstr ""

#: celery.bin.celery:1 of
msgid "The :program:`celery` umbrella command."
msgstr ""

#: celery.bin.celery:8 of
msgid "Preload Options"
msgstr ""

#: celery.bin.celery:10 of
msgid ""
"These options are supported by all commands, and usually parsed before "
"command-specific arguments."
msgstr ""

#: celery.bin.celery:15 of
msgid "app instance to use (e.g., ``module.attr_name``)"
msgstr ""

#: celery.bin.celery:19 of
msgid "URL to broker.  default is ``amqp://guest@localhost//``"
msgstr ""

#: celery.bin.celery:23 of
msgid "name of custom loader class to use."
msgstr ""

#: celery.bin.celery:27 of
msgid "Name of the configuration module"
msgstr ""

#: celery.bin.celery:31 of
msgid "Disable colors in output."
msgstr ""

#: celery.bin.celery:35 of
msgid "Give less verbose output (behavior depends on the sub command)."
msgstr ""

#: celery.bin.celery:39 of
msgid "Show help and exit."
msgstr ""

#: celery.bin.celery:44 of
msgid "Daemon Options"
msgstr ""

#: celery.bin.celery:46 of
msgid ""
"These options are supported by commands that can detach into the "
"background (daemon).  They will be present in any command that also has a"
" `--detach` option."
msgstr ""

#: celery.bin.celery:56 celery.bin.events:40 celery.bin.worker:150 of
msgid "Optional file used to store the process pid."
msgstr ""

#: celery.bin.celery:84 of
msgid "``celery inspect``"
msgstr ""

#: celery.bin.celery:90 celery.bin.celery:107 of
msgid "Timeout in seconds (float) waiting for reply"
msgstr ""

#: celery.bin.celery:94 celery.bin.celery:111 of
msgid "Comma separated list of destination node names."
msgstr ""

#: celery.bin.celery:98 celery.bin.celery:115 of
msgid "Use json as output format."
msgstr ""

#: celery.bin.celery:101 of
msgid "``celery control``"
msgstr ""

#: celery.bin.celery:118 of
msgid "``celery migrate``"
msgstr ""

#: celery.bin.celery:124 of
msgid "Number of tasks to consume (int)."
msgstr ""

#: celery.bin.celery:128 of
msgid "Timeout in seconds (float) waiting for tasks."
msgstr ""

#: celery.bin.celery:132 of
msgid "Ack messages from source broker."
msgstr ""

#: celery.bin.celery:136 of
msgid "List of task names to filter on."
msgstr ""

#: celery.bin.celery:140 of
msgid "List of queues to migrate."
msgstr ""

#: celery.bin.celery:144 of
msgid "Continually migrate tasks until killed."
msgstr ""

#: celery.bin.celery:147 of
msgid "``celery upgrade``"
msgstr ""

#: celery.bin.celery:153 of
msgid "Upgrade a Django project."
msgstr ""

#: celery.bin.celery:157 of
msgid "Maintain backwards compatibility."
msgstr ""

#: celery.bin.celery:161 of
msgid "Don't backup original files."
msgstr ""

#: celery.bin.celery:164 of
msgid "``celery shell``"
msgstr ""

#: celery.bin.celery:170 of
msgid "Force :pypi:`iPython` implementation."
msgstr ""

#: celery.bin.celery:174 of
msgid "Force :pypi:`bpython` implementation."
msgstr ""

#: celery.bin.celery:178 of
msgid "Force default Python shell."
msgstr ""

#: celery.bin.celery:182 of
msgid "Don't add tasks to locals."
msgstr ""

#: celery.bin.celery:186 of
msgid "Use :pypi:`eventlet` monkey patches."
msgstr ""

#: celery.bin.celery:190 of
msgid "Use :pypi:`gevent` monkey patches."
msgstr ""

#: celery.bin.celery:193 of
msgid "``celery result``"
msgstr ""

#: celery.bin.celery:199 of
msgid "Name of task (if custom backend)."
msgstr ""

#: celery.bin.celery:203 of
msgid "Show traceback if any."
msgstr ""

#: celery.bin.celery:206 of
msgid "``celery purge``"
msgstr ""

#: celery.bin.celery:212 of
msgid "Don't prompt for verification before deleting messages (DANGEROUS)"
msgstr ""

#: celery.bin.celery:215 of
msgid "``celery call``"
msgstr ""

#: celery.bin.celery:221 of
msgid "Positional arguments (json format)."
msgstr ""

#: celery.bin.celery:225 of
msgid "Keyword arguments (json format)."
msgstr ""

#: celery.bin.celery:229 of
msgid "Scheduled time in ISO-8601 format."
msgstr ""

#: celery.bin.celery:233 of
msgid "ETA in seconds from now (float/int)."
msgstr ""

#: celery.bin.celery:237 of
msgid "Expiry time in float/int seconds, or a ISO-8601 date."
msgstr ""

#: celery.bin.celery:241 of
msgid "Specify serializer to use (default is json)."
msgstr ""

#: celery.bin.celery:245 of
msgid "Destination queue."
msgstr ""

#: celery.bin.celery:249 of
msgid "Destination exchange (defaults to the queue exchange)."
msgstr ""

#: celery.bin.celery:253 of
msgid "Destination routing key (defaults to the queue routing key)."
msgstr ""

#: celery.bin.celery.CeleryCommand:1 of
msgid "Base class for commands."
msgstr ""

#: celery.bin.celery.main:1 of
msgid "Start celery umbrella command."
msgstr ""

#: ../../reference/celery.bin.control.rst:3
msgid "``celery.bin.control``"
msgstr ""

#: celery.bin.control:1 of
msgid "The ``celery control``, ``. inspect`` and ``. status`` programs."
msgstr ""

#: celery.bin.control.control:1 of
msgid "Workers remote control."
msgstr ""

#: celery.bin.control.control:3 of
msgid "Availability: RabbitMQ (AMQP), Redis, and MongoDB transports."
msgstr ""

#: celery.bin.control.inspect:1 of
msgid "Inspect the worker at runtime."
msgstr ""

#: celery.bin.control.inspect:3 of
msgid "Availability: RabbitMQ (AMQP) and Redis transports."
msgstr ""

#: celery.bin.control.status:1 of
msgid "Show list of workers that are online."
msgstr ""

#: ../../reference/celery.bin.events.rst:3
msgid "``celery.bin.events``"
msgstr ""

#: celery.bin.events:1 of
msgid "The :program:`celery events` command."
msgstr ""

#: celery.bin.events:11 of
msgid "Dump events to stdout."
msgstr ""

#: celery.bin.events:15 of
msgid "Take snapshots of events using this camera."
msgstr ""

#: celery.bin.events:19 of
msgid "Camera: Detach and run in the background as a daemon."
msgstr ""

#: celery.bin.events:23 of
msgid "Camera: Shutter frequency.  Default is every 1.0 seconds."
msgstr ""

#: celery.bin.events:27 of
msgid "Camera: Optional shutter rate limit (e.g., 10/m)."
msgstr ""

#: celery.bin.events:31 of
msgid ""
"Logging level, choose between `DEBUG`, `INFO`, `WARNING`, `ERROR`, "
"`CRITICAL`, or `FATAL`.  Default is INFO."
msgstr ""

#: celery.bin.events.events:1 of
msgid "Event-stream utilities."
msgstr ""

#: celery.bin.events.events:4 celery.events.Event:4 celery.events.event.Event:4
#: celery.schedules.schedule.is_due:4 celery.schedules.solar:7 of
msgid "Notes"
msgstr ""

#: ../../reference/celery.bin.graph.rst:3
msgid "``celery.bin.graph``"
msgstr ""

#: celery.bin.graph:1 of
msgid "The :program:`celery graph` command."
msgstr ""

#: celery.bin.graph.graph:1 of
msgid "The ``celery graph`` command."
msgstr ""

#: ../../reference/celery.bin.list.rst:3
msgid "``celery.bin.list``"
msgstr ""

#: celery.bin.list:1 of
msgid "The ``celery list bindings`` command, used to inspect queue bindings."
msgstr ""

#: celery.bin.list.list_:1 of
msgid "Get info from broker."
msgstr ""

#: celery.bin.list.list_:3 of
msgid "For RabbitMQ the management plugin is required."
msgstr ""

#: ../../reference/celery.bin.logtool.rst:3
msgid "``celery.bin.logtool``"
msgstr ""

#: celery.bin.logtool:1 of
msgid "The :program:`celery logtool` command."
msgstr ""

#: celery.bin.logtool.logtool:1 of
msgid "The ``celery logtool`` command."
msgstr ""

#: ../../reference/celery.bin.migrate.rst:3
msgid "``celery.bin.migrate``"
msgstr ""

#: celery.bin.migrate:1 of
msgid "The ``celery migrate`` command, used to filter and move messages."
msgstr ""

#: celery.bin.migrate.migrate:1 celery.contrib.migrate.migrate_tasks:1 of
msgid "Migrate tasks from one broker to another."
msgstr ""

#: celery.bin.migrate.migrate:5 of
msgid ""
"This command is experimental, make sure you have a backup of the tasks "
"before you continue."
msgstr ""

#: ../../reference/celery.bin.multi.rst:3
msgid "``celery.bin.multi``"
msgstr ""

#: celery.bin.multi:1 of
msgid "Start multiple worker instances from the command-line."
msgstr ""

#: celery.bin.multi.MultiTool:1 of
msgid "The ``celery multi`` program."
msgstr ""

#: ../../reference/celery.bin.purge.rst:3
msgid "``celery.bin.purge``"
msgstr ""

#: celery.bin.purge:1 of
msgid "The ``celery purge`` program, used to delete messages from queues."
msgstr ""

#: celery.bin.purge.purge:1 of
msgid "Erase all messages from all known task queues."
msgstr ""

#: celery.bin.purge.purge:3 of
msgid "There's no undo operation for this command."
msgstr ""

#: ../../reference/celery.bin.result.rst:3
msgid "``celery.bin.result``"
msgstr ""

#: celery.bin.result:1 of
msgid "The ``celery result`` program, used to inspect task results."
msgstr ""

#: celery.bin.result.result:1 of
msgid "Gives the return value for a given task id."
msgstr ""

#: ../../reference/celery.bin.shell.rst:3
msgid "``celery.bin.shell``"
msgstr ""

#: celery.bin.shell:1 of
msgid "The ``celery shell`` program, used to start a REPL."
msgstr ""

#: celery.bin.shell.shell:1 of
msgid "Start shell session with convenient access to celery symbols."
msgstr ""

#: celery.bin.shell.shell:3 of
msgid "The following symbols will be added to the main globals:"
msgstr ""

#: celery.bin.shell.shell:5 of
msgid "``celery``:  the current application."
msgstr ""

#: celery.bin.shell.shell:6 of
msgid ""
"``chord``, ``group``, ``chain``, ``chunks``, ``xmap``, ``xstarmap`` "
"``subtask``, ``Task``"
msgstr ""

#: celery.bin.shell.shell:8 of
msgid "all registered tasks."
msgstr ""

#: ../../reference/celery.bin.upgrade.rst:3
msgid "``celery.bin.upgrade``"
msgstr ""

#: celery.bin.upgrade:1 of
msgid "The ``celery upgrade`` command, used to upgrade from previous versions."
msgstr ""

#: celery.bin.upgrade.upgrade:1 of
msgid "Perform upgrade between versions."
msgstr ""

#: ../../reference/celery.bin.worker.rst:3
msgid "``celery.bin.worker``"
msgstr ""

#: celery.bin.worker:1 of
msgid "Program used to start a Celery worker instance."
msgstr ""

#: celery.bin.worker:3 of
msgid "The :program:`celery worker` command (previously known as ``celeryd``)"
msgstr ""

#: celery.bin.worker:9 of
msgid "See :ref:`preload-options`."
msgstr ""

#: celery.bin.worker:13 of
msgid ""
"Number of child processes processing the queue.  The default is the "
"number of CPUs available on your system."
msgstr ""

#: celery.bin.worker:18 of
msgid "Pool implementation:"
msgstr ""

#: celery.bin.worker:20 of
msgid "prefork (default), eventlet, gevent or solo."
msgstr ""

#: celery.bin.worker:24 of
#, python-format
msgid ""
"Set custom hostname (e.g., 'w1@%%h').  Expands: %%h (hostname), %%n "
"(name) and %%d, (domain)."
msgstr ""

#: celery.bin.worker:29 of
msgid ""
"Also run the `celery beat` periodic task scheduler.  Please note that "
"there must only be one instance of this service."
msgstr ""

#: celery.bin.worker:34 of
msgid ""
"``-B`` is meant to be used for development purposes. For production "
"environment, you need to start :program:`celery beat` separately."
msgstr ""

#: celery.bin.worker:39 of
msgid ""
"List of queues to enable for this worker, separated by comma. By default "
"all configured queues are enabled. Example: `-Q video,image`"
msgstr ""

#: celery.bin.worker:45 of
msgid ""
"List of queues to disable for this worker, separated by comma. By default"
" all configured queues are enabled. Example: `-X video,image`."
msgstr ""

#: celery.bin.worker:51 of
msgid ""
"Comma separated list of additional modules to import. Example: -I "
"foo.tasks,bar.tasks"
msgstr ""

#: celery.bin.worker:56 of
msgid ""
"Path to the schedule database if running with the `-B` option. Defaults "
"to `celerybeat-schedule`.  The extension \".db\" may be appended to the "
"filename."
msgstr ""

#: celery.bin.worker:62 of
msgid "Apply optimization profile.  Supported: default, fair"
msgstr ""

#: celery.bin.worker:66 of
msgid "Set custom prefetch multiplier value for this worker instance."
msgstr ""

#: celery.bin.worker:70 of
msgid ""
"Scheduler class to use.  Default is "
":class:`celery.beat.PersistentScheduler`"
msgstr ""

#: celery.bin.worker:75 of
msgid ""
"Path to the state database.  The extension '.db' may be appended to the "
"filename.  Default: {default}"
msgstr ""

#: celery.bin.worker:80 of
msgid ""
"Send task-related events that can be captured by monitors like "
":program:`celery events`, `celerymon`, and others."
msgstr ""

#: celery.bin.worker:85 of
msgid "Don't subscribe to other workers events."
msgstr ""

#: celery.bin.worker:89 of
msgid "Don't synchronize with other workers at start-up."
msgstr ""

#: celery.bin.worker:93 of
msgid "Don't send event heartbeats."
msgstr ""

#: celery.bin.worker:97 of
msgid "Interval in seconds at which to send worker heartbeat"
msgstr ""

#: celery.bin.worker:101 of
msgid ""
"Purges all waiting tasks before the daemon is started. **WARNING**: This "
"is unrecoverable, and the tasks will be deleted from the messaging "
"server."
msgstr ""

#: celery.bin.worker:107 of
msgid "Enables a hard time limit (in seconds int/float) for tasks."
msgstr ""

#: celery.bin.worker:111 of
msgid "Enables a soft time limit (in seconds int/float) for tasks."
msgstr ""

#: celery.bin.worker:115 of
msgid ""
"Maximum number of tasks a pool worker can execute before it's terminated "
"and replaced by a new worker."
msgstr ""

#: celery.bin.worker:120 of
msgid ""
"Maximum amount of resident memory, in KiB, that may be consumed by a "
"child process before it will be replaced by a new one.  If a single task "
"causes a child process to exceed this limit, the task will be completed "
"and the child process will be replaced afterwards. Default: no limit."
msgstr ""

#: celery.bin.worker:128 of
msgid ""
"Enable autoscaling by providing max_concurrency, min_concurrency. "
"Example::"
msgstr ""

#: celery.bin.worker:133 of
msgid "(always keep 3 processes, but grow to 10 if necessary)"
msgstr ""

#: celery.bin.worker:137 of
msgid "Start worker as a background process."
msgstr ""

#: celery.bin.worker:166 of
msgid ""
"Effective :manpage:`umask(1)` (in octal) of the process after detaching. "
"Inherits the :manpage:`umask(1)` of the parent process by default."
msgstr ""

#: celery.bin.worker.worker:1 of
msgid "Start worker instance."
msgstr ""

#: celery.bin.worker.main:1 of
msgid "Start worker."
msgstr ""

#: ../../reference/celery.bootsteps.rst:3
msgid "``celery.bootsteps``"
msgstr ""

#: celery.bootsteps:1 of
msgid "A directed acyclic graph of reusable components."
msgstr ""

#: celery.bootsteps.Blueprint:1 of
msgid "Blueprint containing bootsteps that can be applied to objects."
msgstr ""

#: celery.bootsteps.Blueprint:3 of
msgid "List of steps."
msgstr ""

#: celery.bootsteps.Blueprint:4 of
msgid "Set explicit name for this blueprint."
msgstr ""

#: celery.bootsteps.Blueprint:6 of
msgid "Optional callback applied after blueprint start."
msgstr ""

#: celery.bootsteps.Blueprint:8 of
msgid "Optional callback applied before blueprint close."
msgstr ""

#: celery.bootsteps.Blueprint:10 of
msgid "Optional callback applied after blueprint stopped."
msgstr ""

#: celery.bootsteps.Blueprint.apply:1 of
msgid "Apply the steps in this blueprint to an object."
msgstr ""

#: celery.bootsteps.Blueprint.apply:3 of
msgid ""
"This will apply the ``__init__`` and ``include`` methods of each step, "
"with the object as argument::"
msgstr ""

#: celery.bootsteps.Blueprint.apply:10 of
msgid ""
"For :class:`StartStopStep` the services created will also be added to the"
" objects ``steps`` attribute."
msgstr ""

#: celery.bootsteps.Step:1 of
msgid "A Bootstep."
msgstr ""

#: celery.bootsteps.Step:3 of
msgid ""
"The :meth:`__init__` method is called when the step is bound to a parent "
"object, and can as such be used to initialize attributes in the parent "
"object at parent instantiation-time."
msgstr ""

#: celery.bootsteps.Step.conditional:1 of
msgid "Set this to true if the step is enabled based on some condition."
msgstr ""

#: celery.bootsteps.Step.create:1 celery.worker.consumer.Agent.create:1
#: celery.worker.consumer.agent.Agent.create:1 of
msgid "Create the step."
msgstr ""

#: celery.bootsteps.Step.enabled:1 of
msgid "This provides the default for :meth:`include_if`."
msgstr ""

#: celery.bootsteps.Step.include_if:1
#: celery.worker.consumer.Control.include_if:1
#: celery.worker.consumer.control.Control.include_if:1 of
msgid "Return true if bootstep should be included."
msgstr ""

#: celery.bootsteps.Step.include_if:3
#: celery.worker.consumer.Control.include_if:3
#: celery.worker.consumer.control.Control.include_if:3 of
msgid ""
"You can define this as an optional predicate that decides whether this "
"step should be created."
msgstr ""

#: celery.bootsteps.Step.label:1 of
msgid "Optional short name used for graph outputs and in logs."
msgstr ""

#: celery.bootsteps.Step.last:1 of
msgid ""
"This flag is reserved for the workers Consumer, since it is required to "
"always be started last. There can only be one object marked last in every"
" blueprint."
msgstr ""

#: celery.bootsteps.Step.name:1 of
msgid "Optional step name, will use ``qualname`` if not specified."
msgstr ""

#: celery.bootsteps.Step.requires:1 of
msgid ""
"List of other steps that that must be started before this step. Note that"
" all dependencies must be in the same blueprint."
msgstr ""

#: celery.bootsteps.StartStopStep:1 of
msgid "Bootstep that must be started and stopped in order."
msgstr ""

#: celery.bootsteps.StartStopStep.obj:1 of
msgid ""
"Optional obj created by the :meth:`create` method. This is used by "
":class:`StartStopStep` to keep the original service object."
msgstr ""

#: celery.bootsteps.ConsumerStep:1 of
msgid "Bootstep that starts a message consumer."
msgstr ""

#: ../../reference/celery.contrib.abortable.rst:3
msgid "``celery.contrib.abortable``"
msgstr ""

#: celery.contrib.abortable:1 of
msgid "Abortable Tasks."
msgstr ""

#: celery.contrib.abortable:4 of
msgid "Abortable tasks overview"
msgstr ""

#: celery.contrib.abortable:6 of
msgid ""
"For long-running :class:`Task`'s, it can be desirable to support aborting"
" during execution.  Of course, these tasks should be built to support "
"abortion specifically."
msgstr ""

#: celery.contrib.abortable:10 of
msgid ""
"The :class:`AbortableTask` serves as a base class for all :class:`Task` "
"objects that should support abortion by producers."
msgstr ""

#: celery.contrib.abortable:13 of
msgid ""
"Producers may invoke the :meth:`abort` method on "
":class:`AbortableAsyncResult` instances, to request abortion."
msgstr ""

#: celery.contrib.abortable:16 of
msgid ""
"Consumers (workers) should periodically check (and honor!) the "
":meth:`is_aborted` method at controlled points in their task's "
":meth:`run` method.  The more often, the better."
msgstr ""

#: celery.contrib.abortable:20 of
msgid ""
"The necessary intermediate communication is dealt with by the "
":class:`AbortableTask` implementation."
msgstr ""

#: celery.contrib.abortable:24 of
msgid "Usage example"
msgstr ""

#: celery.contrib.abortable:26 of
msgid "In the consumer:"
msgstr ""

#: celery.contrib.abortable:55 of
msgid "In the producer:"
msgstr ""

#: celery.contrib.abortable:73 of
msgid ""
"After the `result.abort()` call, the task execution isn't aborted "
"immediately.  In fact, it's not guaranteed to abort at all. Keep checking"
" `result.state` status, or call `result.get(timeout=)` to have it block "
"until the task is finished."
msgstr ""

#: celery.contrib.abortable:80 of
msgid ""
"In order to abort tasks, there needs to be communication between the "
"producer and the consumer.  This is currently implemented through the "
"database backend.  Therefore, this class will only work with the database"
" backends."
msgstr ""

#: celery.contrib.abortable.AbortableAsyncResult:1 of
msgid "Represents an abortable result."
msgstr ""

#: celery.contrib.abortable.AbortableAsyncResult:3 of
msgid ""
"Specifically, this gives the `AsyncResult` a :meth:`abort()` method, that"
" sets the state of the underlying Task to `'ABORTED'`."
msgstr ""

#: celery.contrib.abortable.AbortableAsyncResult.abort:1 of
msgid "Set the state of the task to :const:`ABORTED`."
msgstr ""

#: celery.contrib.abortable.AbortableAsyncResult.abort:3 of
msgid ""
"Abortable tasks monitor their state at regular intervals and terminate "
"execution if so."
msgstr ""

#: celery.contrib.abortable.AbortableAsyncResult.abort:8 of
msgid ""
"Be aware that invoking this method does not guarantee when the task will "
"be aborted (or even if the task will be aborted at all)."
msgstr ""

#: celery.contrib.abortable.AbortableAsyncResult.is_aborted:1 of
msgid "Return :const:`True` if the task is (being) aborted."
msgstr ""

#: celery.contrib.abortable.AbortableTask:1 of
msgid "Task that can be aborted."
msgstr ""

#: celery.contrib.abortable.AbortableTask:3 of
msgid ""
"This serves as a base class for all :class:`Task`'s that support aborting"
" during execution."
msgstr ""

#: celery.contrib.abortable.AbortableTask:6 of
msgid ""
"All subclasses of :class:`AbortableTask` must call the :meth:`is_aborted`"
" method periodically and act accordingly when the call evaluates to "
":const:`True`."
msgstr ""

#: celery.contrib.abortable.AbortableTask.AsyncResult:1 of
msgid "Return the accompanying AbortableAsyncResult instance."
msgstr ""

#: celery.contrib.abortable.AbortableTask.is_aborted:1 of
msgid "Return true if task is aborted."
msgstr ""

#: celery.contrib.abortable.AbortableTask.is_aborted:3 of
msgid ""
"Checks against the backend whether this :class:`AbortableAsyncResult` is "
":const:`ABORTED`."
msgstr ""

#: celery.contrib.abortable.AbortableTask.is_aborted:6 of
msgid ""
"Always return :const:`False` in case the `task_id` parameter refers to a "
"regular (non-abortable) :class:`Task`."
msgstr ""

#: celery.contrib.abortable.AbortableTask.is_aborted:9 of
msgid ""
"Be aware that invoking this method will cause a hit in the backend (for "
"example a database query), so find a good balance between calling it "
"regularly (for responsiveness), but not too often (for performance)."
msgstr ""

#: ../../reference/celery.contrib.migrate.rst:3
msgid "``celery.contrib.migrate``"
msgstr ""

#: celery.contrib.migrate:1 of
msgid "Message migration tools (Broker <-> Broker)."
msgstr ""

#: celery.contrib.migrate.StopFiltering:1 of
msgid "Semi-predicate used to signal filter stop."
msgstr ""

#: celery.contrib.migrate.State:1 of
msgid "Migration progress state."
msgstr ""

#: celery.contrib.migrate.republish:1 of
msgid "Republish message."
msgstr ""

#: celery.contrib.migrate.migrate_task:1 of
msgid "Migrate single task message."
msgstr ""

#: celery.contrib.migrate.move:1 celery.contrib.migrate.move_direct:1 of
msgid "Find tasks by filtering them and move the tasks to a new queue."
msgstr ""

#: celery.contrib.migrate.move:3 celery.contrib.migrate.move_direct:3 of
msgid ""
"Filter function used to decide the messages to move.  Must accept the "
"standard signature of ``(body, message)`` used by Kombu consumer "
"callbacks.  If the predicate wants the message to be moved it must return"
" either:      1) a tuple of ``(exchange, routing_key)``, or      2) a "
":class:`~kombu.entity.Queue` instance, or      3) any other true value "
"means the specified         ``exchange`` and ``routing_key`` arguments "
"will be used."
msgstr ""

#: celery.contrib.migrate.move:3 celery.contrib.migrate.move_direct:3 of
msgid ""
"Filter function used to decide the messages to move.  Must accept the "
"standard signature of ``(body, message)`` used by Kombu consumer "
"callbacks.  If the predicate wants the message to be moved it must return"
" either:"
msgstr ""

#: celery.contrib.migrate.move:8 celery.contrib.migrate.move_direct:8 of
msgid "a tuple of ``(exchange, routing_key)``, or"
msgstr ""

#: celery.contrib.migrate.move:10 celery.contrib.migrate.move_direct:10 of
msgid "a :class:`~kombu.entity.Queue` instance, or"
msgstr ""

#: celery.contrib.migrate.move:12 celery.contrib.migrate.move_direct:12 of
msgid "any other true value means the specified"
msgstr ""

#: celery.contrib.migrate.move:13 celery.contrib.migrate.move_direct:13 of
msgid "``exchange`` and ``routing_key`` arguments will be used."
msgstr ""

#: celery.contrib.migrate.move:15 celery.contrib.migrate.move_direct:15 of
msgid "Custom connection to use."
msgstr ""

#: celery.contrib.migrate.move:17 celery.contrib.migrate.move_direct:17 of
msgid ""
"List[Union[str, kombu.Queue]]: Optional list of source queues to use "
"instead of the default (queues in :setting:`task_queues`).  This list can"
" also contain :class:`~kombu.entity.Queue` instances."
msgstr ""

#: celery.contrib.migrate.move:21 celery.contrib.migrate.move_direct:21 of
msgid "Default destination exchange."
msgstr ""

#: celery.contrib.migrate.move:23 celery.contrib.migrate.move_direct:23 of
msgid "Default destination routing key."
msgstr ""

#: celery.contrib.migrate.move:25 celery.contrib.migrate.move_direct:25 of
msgid "Limit number of messages to filter."
msgstr ""

#: celery.contrib.migrate.move:27 celery.contrib.migrate.move_direct:27 of
msgid ""
"Callback called after message moved, with signature ``(state, body, "
"message)``."
msgstr ""

#: celery.contrib.migrate.move:30 celery.contrib.migrate.move_direct:30
#: celery.contrib.migrate.move_direct_by_id:6
#: celery.contrib.migrate.move_task_by_id:6 of
msgid ""
"Optional function to transform the return value (destination) of the "
"filter function."
msgstr ""

#: celery.contrib.migrate.move:34 celery.contrib.migrate.move_direct:34 of
msgid "Also supports the same keyword arguments as :func:`start_filter`."
msgstr ""

#: celery.contrib.migrate.move:36 celery.contrib.migrate.move_direct:36 of
msgid ""
"To demonstrate, the :func:`move_task_by_id` operation can be implemented "
"like this:"
msgstr ""

#: celery.contrib.migrate.move:48 celery.contrib.migrate.move_direct:48 of
msgid "or with a transform:"
msgstr ""

#: celery.contrib.migrate.move:61 celery.contrib.migrate.move_direct:61 of
msgid ""
"The predicate may also return a tuple of ``(exchange, routing_key)`` to "
"specify the destination to where the task should be moved, or a "
":class:`~kombu.entitiy.Queue` instance. Any other true value means that "
"the task will be moved to the default exchange/routing_key."
msgstr ""

#: celery.contrib.migrate.task_id_eq:1 of
msgid "Return true if task id equals task_id'."
msgstr ""

#: celery.contrib.migrate.task_id_in:1 of
msgid "Return true if task id is member of set ids'."
msgstr ""

#: celery.contrib.migrate.start_filter:1 of
msgid "Filter tasks."
msgstr ""

#: celery.contrib.migrate.move_direct_by_id:1
#: celery.contrib.migrate.move_task_by_id:1 of
msgid "Find a task by id and move it to another queue."
msgstr ""

#: celery.contrib.migrate.move_direct_by_id:3
#: celery.contrib.migrate.move_task_by_id:3 of
msgid "Id of task to find and move."
msgstr ""

#: celery.contrib.migrate.move_direct_by_id:5
#: celery.contrib.migrate.move_task_by_id:5 of
msgid "(str, kombu.Queue): Destination queue."
msgstr ""

#: celery.contrib.migrate.move_direct_by_id:9
#: celery.contrib.migrate.move_task_by_id:9 of
msgid "Also supports the same keyword arguments as :func:`move`."
msgstr ""

#: celery.contrib.migrate.move_by_idmap:1 of
msgid "Move tasks by matching from a ``task_id: queue`` mapping."
msgstr ""

#: celery.contrib.migrate.move_by_idmap:3 of
msgid "Where ``queue`` is a queue to move the task to."
msgstr ""

#: celery.contrib.migrate.move_by_taskmap:1 of
msgid "Move tasks by matching from a ``task_name: queue`` mapping."
msgstr ""

#: celery.contrib.migrate.move_by_taskmap:3 of
msgid "``queue`` is the queue to move the task to."
msgstr ""

#: ../../reference/celery.contrib.pytest.rst:3
msgid "``celery.contrib.pytest``"
msgstr ""

#: ../../reference/celery.contrib.pytest.rst:9
#: ../../reference/celery.contrib.testing.app.rst:9
#: ../../reference/celery.contrib.testing.manager.rst:9
#: ../../reference/celery.contrib.testing.mocks.rst:9
#: ../../reference/celery.contrib.testing.worker.rst:9
#: ../../reference/celery.utils.debug.rst:34 ../../reference/index.rst:5
msgid "API Reference"
msgstr ""

#: celery.contrib.pytest:1 of
msgid "Fixtures and testing utilities for :pypi:`py.test <pytest>`."
msgstr ""

#: celery.contrib.pytest.celery_app:1 of
msgid "Fixture creating a Celery application instance."
msgstr ""

#: celery.contrib.pytest.celery_config:1 of
msgid "Redefine this fixture to configure the test Celery app."
msgstr ""

#: celery.contrib.pytest.celery_config:3 of
msgid ""
"The config returned by your fixture will then be used to configure the "
":func:`celery_app` fixture."
msgstr ""

#: celery.contrib.pytest.celery_enable_logging:1 of
msgid "You can override this fixture to enable logging."
msgstr ""

#: celery.contrib.pytest.celery_includes:1 of
msgid "You can override this include modules when a worker start."
msgstr ""

#: celery.contrib.pytest.celery_includes:3 of
msgid ""
"You can have this return a list of module names to import, these can be "
"task modules, modules registering signals, and so on."
msgstr ""

#: celery.contrib.pytest.celery_parameters:1 of
msgid "Redefine this fixture to change the init parameters of test Celery app."
msgstr ""

#: celery.contrib.pytest.celery_parameters:3 of
msgid ""
"The dict returned by your fixture will then be used as parameters when "
"instantiating :class:`~celery.Celery`."
msgstr ""

#: celery.contrib.pytest.celery_session_app:1 of
msgid "Session Fixture: Return app for session fixtures."
msgstr ""

#: celery.contrib.pytest.celery_session_worker:1 of
msgid "Session Fixture: Start worker that lives throughout test suite."
msgstr ""

#: celery.contrib.pytest.celery_worker:1 of
msgid "Fixture: Start worker in a thread, stop it when the test returns."
msgstr ""

#: celery.contrib.pytest.celery_worker_parameters:1 of
msgid "Redefine this fixture to change the init parameters of Celery workers."
msgstr ""

#: celery.contrib.pytest.celery_worker_parameters:3 of
msgid ""
"This can be used e. g. to define queues the worker will consume tasks "
"from."
msgstr ""

#: celery.contrib.pytest.celery_worker_parameters:5 of
msgid ""
"The dict returned by your fixture will then be used as parameters when "
"instantiating :class:`~celery.worker.WorkController`."
msgstr ""

#: celery.contrib.pytest.celery_worker_pool:1 of
msgid "You can override this fixture to set the worker pool."
msgstr ""

#: celery.contrib.pytest.celery_worker_pool:3 of
msgid ""
"The \"solo\" pool is used by default, but you can set this to return e.g."
" \"prefork\"."
msgstr ""

#: celery.contrib.pytest.depends_on_current_app:1 of
msgid "Fixture that sets app as current."
msgstr ""

#: celery.contrib.pytest.use_celery_app_trap:1 of
msgid "You can override this fixture to enable the app trap."
msgstr ""

#: celery.contrib.pytest.use_celery_app_trap:3 of
msgid ""
"The app trap raises an exception whenever something attempts to use the "
"current or default apps."
msgstr ""

#: ../../reference/celery.contrib.rdb.rst:3
msgid "``celery.contrib.rdb``"
msgstr ""

#: celery.contrib.rdb:1 of
msgid "Remote Debugger."
msgstr ""

#: celery.contrib.rdb:4 celery.contrib.sphinx:4 of
msgid "Introduction"
msgstr ""

#: celery.contrib.rdb:6 of
msgid ""
"This is a remote debugger for Celery tasks running in multiprocessing "
"pool workers.  Inspired by a lost post on dzone.com."
msgstr ""

#: celery.contrib.rdb:10 celery.contrib.sphinx:7 of
msgid "Usage"
msgstr ""

#: celery.contrib.rdb:24 of
msgid "Environment Variables"
msgstr ""

#: celery.contrib.rdb:29 of
msgid "``CELERY_RDB_HOST``"
msgstr ""

#: celery.contrib.rdb:31 of
msgid ""
"Hostname to bind to.  Default is '127.0.0.1' (only accessable from "
"localhost)."
msgstr ""

#: celery.contrib.rdb:37 of
msgid "``CELERY_RDB_PORT``"
msgstr ""

#: celery.contrib.rdb:39 of
msgid ""
"Base port to bind to.  Default is 6899. The debugger will try to find an "
"available port starting from the base port.  The selected port will be "
"logged by the worker."
msgstr ""

#: celery.contrib.rdb.set_trace:1 of
msgid "Set break-point at current location, or a specified frame."
msgstr ""

#: celery.contrib.rdb.debugger:1 of
msgid "Return the current debugger instance, or create if none."
msgstr ""

#: celery.contrib.rdb.Rdb:1 of
msgid "Remote debugger."
msgstr ""

#: ../../reference/celery.contrib.sphinx.rst:3
msgid "celery.contrib.sphinx"
msgstr ""

#: celery.contrib.sphinx:1 of
msgid "Sphinx documentation plugin used to document tasks."
msgstr ""

#: celery.contrib.sphinx:9 of
msgid "Add the extension to your :file:`docs/conf.py` configuration module:"
msgstr ""

#: celery.contrib.sphinx:16 of
msgid ""
"If you'd like to change the prefix for tasks in reference documentation "
"then you can change the ``celery_task_prefix`` configuration value:"
msgstr ""

#: celery.contrib.sphinx:23 of
msgid ""
"With the extension installed `autodoc` will automatically find task "
"decorated objects (e.g. when using the automodule directive) and generate"
" the correct (as well as add a ``(task)`` prefix), and you can also refer"
" to the tasks using `:task:proj.tasks.add` syntax."
msgstr ""

#: celery.contrib.sphinx:29 of
msgid "Use ``.. autotask::`` to alternatively manually document a task."
msgstr ""

#: celery.contrib.sphinx.TaskDirective:1 of
msgid "Sphinx task directive."
msgstr ""

#: celery.contrib.sphinx.TaskDirective.get_signature_prefix:1 of
msgid "May return a prefix to put before the object name in the signature."
msgstr ""

#: celery.contrib.sphinx.TaskDocumenter:1 of
msgid "Document task definitions."
msgstr ""

#: celery.contrib.sphinx.TaskDocumenter.can_document_member:1 of
msgid "Called to see if a member can be documented by this documenter."
msgstr ""

#: celery.contrib.sphinx.TaskDocumenter.check_module:1 of
msgid ""
"Check if *self.object* is really defined in the module given by "
"*self.modname*."
msgstr ""

#: celery.contrib.sphinx.TaskDocumenter.document_members:1 of
msgid "Generate reST for member documentation."
msgstr ""

#: celery.contrib.sphinx.TaskDocumenter.document_members:3 of
msgid ""
"If *all_members* is True, do all members, else those given by "
"*self.options.members*."
msgstr ""

#: celery.contrib.sphinx.TaskDocumenter.format_args:1 of
msgid "Format the argument signature of *self.object*."
msgstr ""

#: celery.contrib.sphinx.TaskDocumenter.format_args:3 of
msgid "Should return None if the object does not have a signature."
msgstr ""

#: celery.contrib.sphinx.autodoc_skip_member_handler:1 of
msgid "Handler for autodoc-skip-member event."
msgstr ""

#: celery.contrib.sphinx.setup:1 of
msgid "Setup Sphinx extension."
msgstr ""

#: ../../reference/celery.contrib.testing.app.rst:3
msgid "``celery.contrib.testing.app``"
msgstr ""

#: celery.contrib.testing.app:1 of
msgid "Create Celery app instances used for testing."
msgstr ""

#: celery.contrib.testing.app.DEFAULT_TEST_CONFIG:1 of
msgid "Contains the default configuration values for the test app."
msgstr ""

#: celery.contrib.testing.app.TestApp:1 of
msgid "App used for testing."
msgstr ""

#: celery.contrib.testing.app.Trap:1 of
msgid "Trap that pretends to be an app but raises an exception instead."
msgstr ""

#: celery.contrib.testing.app.Trap:3 of
msgid ""
"This to protect from code that does not properly pass app instances, then"
" falls back to the current_app."
msgstr ""

#: celery.contrib.testing.app.UnitLogging:1 of
msgid "Sets up logging for the test application."
msgstr ""

#: celery.contrib.testing.app.set_trap:1 of
msgid "Contextmanager that installs the trap app."
msgstr ""

#: celery.contrib.testing.app.set_trap:3 of
msgid ""
"The trap means that anything trying to use the current or default app "
"will raise an exception."
msgstr ""

#: celery.contrib.testing.app.setup_default_app:1 of
msgid "Setup default app for testing."
msgstr ""

#: celery.contrib.testing.app.setup_default_app:3 of
msgid "Ensures state is clean after the test returns."
msgstr ""

#: ../../reference/celery.contrib.testing.manager.rst:3
msgid "``celery.contrib.testing.manager``"
msgstr ""

#: celery.contrib.testing.manager:1 of
msgid "Integration testing utilities."
msgstr ""

#: celery.contrib.testing.manager.Manager:1 of
msgid "Test helpers for task integration tests."
msgstr ""

#: celery.contrib.testing.manager.ManagerMixin:1 of
msgid "Mixin that adds :class:`Manager` capabilities."
msgstr ""

#: celery.contrib.testing.manager.ManagerMixin.ensure_not_for_a_while:1 of
msgid "Make sure something does not happen (at least for a while)."
msgstr ""

#: celery.contrib.testing.manager.ManagerMixin.wait_for:1 of
msgid "Wait for event to happen."
msgstr ""

#: celery.contrib.testing.manager.ManagerMixin.wait_for:3 of
msgid ""
"The `catch` argument specifies the exception that means the event has not"
" happened yet."
msgstr ""

#: celery.contrib.testing.manager.Sentinel:1 of
msgid "Signifies the end of something."
msgstr ""

#: celery.contrib.testing.manager.humanize_seconds:1 of
msgid "Show seconds in human form."
msgstr ""

#: celery.contrib.testing.manager.humanize_seconds:3 of
msgid "For example, 60 becomes \"1 minute\", and 7200 becomes \"2 hours\"."
msgstr ""

#: celery.contrib.testing.manager.humanize_seconds:5 of
msgid ""
"can be used to add a preposition to the output (e.g., 'in' will give 'in "
"1 second', but add nothing to 'now')."
msgstr ""

#: celery.contrib.testing.manager.humanize_seconds:8 of
msgid "Literal 'now'."
msgstr ""

#: celery.contrib.testing.manager.humanize_seconds:10 of
msgid "Include microseconds."
msgstr ""

#: ../../reference/celery.contrib.testing.mocks.rst:3
msgid "``celery.contrib.testing.mocks``"
msgstr ""

#: celery.contrib.testing.mocks:1 of
msgid "Useful mocks for unit testing."
msgstr ""

#: celery.contrib.testing.mocks.TaskMessage:1 of
msgid "Create task message in protocol 2 format."
msgstr ""

#: celery.contrib.testing.mocks.TaskMessage1:1 of
msgid "Create task message in protocol 1 format."
msgstr ""

#: celery.contrib.testing.mocks.task_message_from_sig:1 of
msgid "Create task message from :class:`celery.Signature`."
msgstr ""

#: ../../reference/celery.contrib.testing.worker.rst:3
msgid "``celery.contrib.testing.worker``"
msgstr ""

#: celery.contrib.testing.worker:1 of
msgid "Embedded workers for integration tests."
msgstr ""

#: celery.contrib.testing.worker.TestWorkController:1 of
msgid "Worker that can synchronize on being fully started."
msgstr ""

#: celery.contrib.testing.worker.TestWorkController.ensure_started:1 of
msgid "Wait for worker to be fully up and running."
msgstr ""

#: celery.contrib.testing.worker.TestWorkController.ensure_started:5 of
msgid ""
"Worker must be started within a thread for this to work, or it will block"
" forever."
msgstr ""

#: celery.contrib.testing.worker.TestWorkController.on_consumer_ready:1 of
msgid "Callback called when the Consumer blueprint is fully started."
msgstr ""

#: celery.contrib.testing.worker.setup_app_for_worker:1 of
msgid "Setup the app to be used for starting an embedded worker."
msgstr ""

#: celery.contrib.testing.worker.start_worker:1 of
msgid "Start embedded worker."
msgstr ""

#: celery.contrib.testing.worker.start_worker
#: celery.events.state.State.tasks_by_time
#: celery.events.state.State.tasks_by_timestamp
#: celery.result.AsyncResult.collect of
msgid "Yields"
msgstr ""

#: celery.contrib.testing.worker.start_worker:3 of
msgid "*celery.app.worker.Worker* -- worker instance."
msgstr ""

#: ../../reference/celery.events.rst:3
msgid "``celery.events``"
msgstr ""

#: celery.events:1 of
msgid "Monitoring Event Receiver+Dispatcher."
msgstr ""

#: celery.events:3 of
msgid ""
"Events is a stream of messages sent for certain actions occurring in the "
"worker (and clients if :setting:`task_send_sent_event` is enabled), used "
"for monitoring purposes."
msgstr ""

#: celery.events.Event:1 celery.events.event.Event:1 of
msgid "Create an event."
msgstr ""

#: celery.events.Event:5 celery.events.event.Event:5 of
msgid ""
"An event is simply a dictionary: the only required field is ``type``. A "
"``timestamp`` field will be set to the current time if not provided."
msgstr ""

#: celery.events.EventDispatcher:1 celery.events.dispatcher.EventDispatcher:1
#: of
msgid "Dispatches event messages."
msgstr ""

#: celery.events.EventDispatcher:3 celery.events.EventReceiver:3
#: celery.events.dispatcher.EventDispatcher:3
#: celery.events.receiver.EventReceiver:3 of
msgid "Connection to the broker."
msgstr ""

#: celery.events.EventDispatcher:5 celery.events.dispatcher.EventDispatcher:5
#: of
msgid ""
"Hostname to identify ourselves as, by default uses the hostname returned "
"by :func:`~celery.utils.anon_nodename`."
msgstr ""

#: celery.events.EventDispatcher:9 celery.events.dispatcher.EventDispatcher:9
#: of
msgid ""
"List of groups to send events for. :meth:`send` will ignore send requests"
" to groups not in this list. If this is :const:`None`, all events will be"
" sent. Example groups include ``\"task\"`` and ``\"worker\"``."
msgstr ""

#: celery.events.EventDispatcher:14 celery.events.dispatcher.EventDispatcher:14
#: of
msgid ""
"Set to :const:`False` to not actually publish any events, making "
":meth:`send` a no-op."
msgstr ""

#: celery.events.EventDispatcher:17 celery.events.dispatcher.EventDispatcher:17
#: of
msgid ""
"Can be used instead of `connection` to specify an exact channel to use "
"when sending events."
msgstr ""

#: celery.events.EventDispatcher:20 celery.events.dispatcher.EventDispatcher:20
#: of
msgid ""
"If enabled events will be buffered while the connection is down. "
":meth:`flush` must be called as soon as the connection is re-established."
msgstr ""

#: celery.events.EventDispatcher:25 celery.events.dispatcher.EventDispatcher:25
#: of
msgid "You need to :meth:`close` this after use."
msgstr ""

#: celery.events.EventDispatcher.close:1
#: celery.events.dispatcher.EventDispatcher.close:1 of
msgid "Close the event dispatcher."
msgstr ""

#: celery.events.EventDispatcher.extend_buffer:1
#: celery.events.dispatcher.EventDispatcher.extend_buffer:1 of
msgid "Copy the outbound buffer of another instance."
msgstr ""

#: celery.events.EventDispatcher.flush:1
#: celery.events.dispatcher.EventDispatcher.flush:1 of
msgid "Flush the outbound buffer."
msgstr ""

#: celery.events.EventDispatcher.publish:1
#: celery.events.dispatcher.EventDispatcher.publish:1 of
msgid "Publish event using custom :class:`~kombu.Producer`."
msgstr ""

#: celery.events.EventDispatcher.publish:3
#: celery.events.dispatcher.EventDispatcher.publish:3 of
msgid ""
"Event type name, with group separated by dash (`-`). fields: Dictionary "
"of event fields, must be json serializable."
msgstr ""

#: celery.events.EventDispatcher.publish:6
#: celery.events.dispatcher.EventDispatcher.publish:6 of
msgid "Producer instance to use: only the ``publish`` method will be called."
msgstr ""

#: celery.events.EventDispatcher.publish:9 celery.events.EventDispatcher.send:5
#: celery.events.dispatcher.EventDispatcher.publish:9
#: celery.events.dispatcher.EventDispatcher.send:5 of
msgid "Retry in the event of connection failure."
msgstr ""

#: celery.events.EventDispatcher.publish:11
#: celery.events.EventDispatcher.send:7
#: celery.events.dispatcher.EventDispatcher.publish:11
#: celery.events.dispatcher.EventDispatcher.send:7 of
msgid "Map of custom retry policy options. See :meth:`~kombu.Connection.ensure`."
msgstr ""

#: celery.events.EventDispatcher.publish:14
#: celery.events.EventDispatcher.send:10
#: celery.events.dispatcher.EventDispatcher.publish:14
#: celery.events.dispatcher.EventDispatcher.send:10 of
msgid ""
"Don't set logical clock value (also don't forward the internal logical "
"clock)."
msgstr ""

#: celery.events.EventDispatcher.publish:17
#: celery.events.dispatcher.EventDispatcher.publish:17 of
msgid "Event type used to create event. Defaults to :func:`Event`."
msgstr ""

#: celery.events.EventDispatcher.publish:20
#: celery.events.dispatcher.EventDispatcher.publish:20 of
msgid "Function returning the current utc offset in hours."
msgstr ""

#: celery.events.EventDispatcher.send:1
#: celery.events.dispatcher.EventDispatcher.send:1 of
msgid "Send event."
msgstr ""

#: celery.events.EventDispatcher.send:3
#: celery.events.dispatcher.EventDispatcher.send:3 of
msgid "Event type name, with group separated by dash (`-`)."
msgstr ""

#: celery.events.EventDispatcher.send:13
#: celery.events.dispatcher.EventDispatcher.send:13 of
msgid "Event type used to create event, defaults to :func:`Event`."
msgstr ""

#: celery.events.EventDispatcher.send:16
#: celery.events.dispatcher.EventDispatcher.send:16 of
msgid "unction returning the current utc offset in hours."
msgstr ""

#: celery.events.EventDispatcher.send:19
#: celery.events.dispatcher.EventDispatcher.send:19 of
msgid "Event fields -- must be json serializable."
msgstr ""

#: celery.events.EventReceiver:1 celery.events.receiver.EventReceiver:1 of
msgid "Capture events."
msgstr ""

#: celery.events.EventReceiver:5 celery.events.receiver.EventReceiver:5 of
msgid ""
"Event handlers. This is  a map of event type names and their handlers. "
"The special handler `\"*\"` captures all events that don't have a "
"handler."
msgstr ""

#: celery.events.EventReceiver.capture:1
#: celery.events.receiver.EventReceiver.capture:1 of
msgid "Open up a consumer capturing events."
msgstr ""

#: celery.events.EventReceiver.capture:3
#: celery.events.receiver.EventReceiver.capture:3 of
msgid ""
"This has to run in the main process, and it will never stop unless "
":attr:`EventDispatcher.should_stop` is set to True, or forced via "
":exc:`KeyboardInterrupt` or :exc:`SystemExit`."
msgstr ""

#: celery.events.EventReceiver.process:1
#: celery.events.receiver.EventReceiver.process:1 of
msgid "Process event by dispatching to configured handler."
msgstr ""

#: celery.events.event.get_exchange:1 celery.events.get_exchange:1 of
msgid "Get exchange used for sending events."
msgstr ""

#: celery.events.event.get_exchange:3 celery.events.get_exchange:3 of
msgid "Connection used for sending/receving events."
msgstr ""

#: celery.events.event.get_exchange:5 celery.events.get_exchange:5 of
msgid "Name of the exchange. Default is ``celeryev``."
msgstr ""

#: celery.events.event.get_exchange:10 celery.events.get_exchange:10 of
msgid ""
"The event type changes if Redis is used as the transport (from topic -> "
"fanout)."
msgstr ""

#: celery.events.event.group_from:1 celery.events.group_from:1 of
msgid "Get the group part of an event type name."
msgstr ""

#: ../../reference/celery.events.dispatcher.rst:3
#: ../../reference/celery.events.state.rst:3
msgid "``celery.events.state``"
msgstr ""

#: celery.events.dispatcher:1 of
msgid "Event dispatcher sends events."
msgstr ""

#: ../../reference/celery.events.event.rst:3
msgid "``celery.events.event``"
msgstr ""

#: celery.events.event:1 of
msgid "Creating events, and event exchange definition."
msgstr ""

#: celery.events.event.event_exchange:1 of
msgid ""
"Exchange used to send events on. Note: Use :func:`get_exchange` instead, "
"as the type of exchange will vary depending on the broker connection."
msgstr ""

#: ../../reference/celery.events.receiver.rst:3
msgid "``celery.events.receiver``"
msgstr ""

#: celery.events.receiver:1 of
msgid "Event receiver implementation."
msgstr ""

#: celery.events.state:1 of
msgid "In-memory representation of cluster state."
msgstr ""

#: celery.events.state:3 of
msgid ""
"This module implements a data-structure used to keep track of the state "
"of a cluster of workers and the tasks it is working on (by consuming "
"events)."
msgstr ""

#: celery.events.state:7 of
msgid ""
"For every event consumed the state is updated, so the state represents "
"the state of the cluster at the time of the last event."
msgstr ""

#: celery.events.state:11 of
msgid ""
"Snapshots (:mod:`celery.events.snapshot`) can be used to take "
"\"pictures\" of this state at regular intervals to for example, store "
"that in a database."
msgstr ""

#: celery.events.state.State.Worker:1 celery.events.state.Worker:1 of
msgid "Worker State."
msgstr ""

#: celery.events.state.State.Task:1 celery.events.state.Task:1 of
msgid "Task State."
msgstr ""

#: celery.events.state.State.Task.info:1 celery.events.state.Task.info:1 of
msgid "Information about this task suitable for on-screen display."
msgstr ""

#: celery.events.state.Task.merge_rules:1 of
msgid ""
"How to merge out of order events. Disorder is detected by logical "
"ordering (e.g., :event:`task-received` must've happened before a :event"
":`task-failed` event)."
msgstr ""

#: celery.events.state.Task.merge_rules:5 of
msgid ""
"A merge rule consists of a state and a list of fields to keep from that "
"state. ``(RECEIVED, ('name', 'args')``, means the name and args fields "
"are always taken from the RECEIVED state, and any values for these fields"
" received before or after is simply ignored."
msgstr ""

#: celery.events.state.State:1 of
msgid "Records clusters state."
msgstr ""

#: celery.events.state.State.alive_workers:1 of
msgid "Return a list of (seemingly) alive workers."
msgstr ""

#: celery.events.state.State.get_or_create_task:1 of
msgid "Get or create task by uuid."
msgstr ""

#: celery.events.state.State.get_or_create_worker:1 of
msgid "Get or create worker by hostname."
msgstr ""

#: celery.events.state.State.get_or_create_worker:3 of
msgid "of ``(worker, was_created)`` pairs."
msgstr ""

#: celery.events.state.State.task_event:1
#: celery.events.state.State.worker_event:1 of
msgid "Deprecated, use :meth:`event`."
msgstr ""

#: celery.events.state.State.task_types:1 of
msgid "Return a list of all seen task types."
msgstr ""

#: celery.events.state.State.tasks_by_time:1
#: celery.events.state.State.tasks_by_timestamp:1 of
msgid "Generator yielding tasks ordered by time."
msgstr ""

#: celery.events.state.State.tasks_by_time:3
#: celery.events.state.State.tasks_by_timestamp:3 of
msgid "Tuples of ``(uuid, Task)``."
msgstr ""

#: celery.events.state.heartbeat_expires:1 of
msgid "Return time when heartbeat expires."
msgstr ""

#: ../../reference/celery.exceptions.rst:3
msgid "``celery.exceptions``"
msgstr ""

#: celery.exceptions:1 of
msgid "Celery error types."
msgstr ""

#: celery.exceptions:4 of
msgid "Error Hierarchy"
msgstr ""

#: celery.exceptions:36 of
msgid ":exc:`Exception`"
msgstr ""

#: celery.exceptions:22 of
msgid ":exc:`celery.exceptions.CeleryError`"
msgstr ""

#: celery.exceptions:8 of
msgid ":exc:`~celery.exceptions.ImproperlyConfigured`"
msgstr ""

#: celery.exceptions:9 of
msgid ":exc:`~celery.exceptions.SecurityError`"
msgstr ""

#: celery.exceptions:12 of
msgid ":exc:`~celery.exceptions.TaskPredicate`"
msgstr ""

#: celery.exceptions:11 of
msgid ":exc:`~celery.exceptions.Ignore`"
msgstr ""

#: celery.exceptions:12 of
msgid ":exc:`~celery.exceptions.Reject`"
msgstr ""

#: celery.exceptions:13 of
msgid ":exc:`~celery.exceptions.Retry`"
msgstr ""

#: celery.exceptions:22 of
msgid ":exc:`~celery.exceptions.TaskError`"
msgstr ""

#: celery.exceptions:15 of
msgid ":exc:`~celery.exceptions.QueueNotFound`"
msgstr ""

#: celery.exceptions:16 of
msgid ":exc:`~celery.exceptions.IncompleteStream`"
msgstr ""

#: celery.exceptions:17 of
msgid ":exc:`~celery.exceptions.NotRegistered`"
msgstr ""

#: celery.exceptions:18 of
msgid ":exc:`~celery.exceptions.AlreadyRegistered`"
msgstr ""

#: celery.exceptions:19 of
msgid ":exc:`~celery.exceptions.TimeoutError`"
msgstr ""

#: celery.exceptions:20 of
msgid ":exc:`~celery.exceptions.MaxRetriesExceededError`"
msgstr ""

#: celery.exceptions:21 of
msgid ":exc:`~celery.exceptions.TaskRevokedError`"
msgstr ""

#: celery.exceptions:22 of
msgid ":exc:`~celery.exceptions.InvalidTaskError`"
msgstr ""

#: celery.exceptions:23 of
msgid ":exc:`~celery.exceptions.ChordError`"
msgstr ""

#: celery.exceptions:31 of
msgid ":class:`kombu.exceptions.KombuError`"
msgstr ""

#: celery.exceptions:25 of
msgid ":exc:`~celery.exceptions.OperationalError`"
msgstr ""

#: celery.exceptions:27 of
msgid ""
"Raised when a transport connection error occurs while sending a message "
"(be it a task, remote control command error)."
msgstr ""

#: celery.exceptions:31 of
msgid ""
"This exception does not inherit from "
":exc:`~celery.exceptions.CeleryError`."
msgstr ""

#: celery.exceptions:36 of
msgid "**billiard errors** (prefork pool)"
msgstr ""

#: celery.exceptions:34 of
msgid ":exc:`~celery.exceptions.SoftTimeLimitExceeded`"
msgstr ""

#: celery.exceptions:35 of
msgid ":exc:`~celery.exceptions.TimeLimitExceeded`"
msgstr ""

#: celery.exceptions:36 of
msgid ":exc:`~celery.exceptions.WorkerLostError`"
msgstr ""

#: celery.exceptions:37 of
msgid ":exc:`~celery.exceptions.Terminated`"
msgstr ""

#: celery.exceptions:42 of
msgid ":class:`UserWarning`"
msgstr ""

#: celery.exceptions:42 of
msgid ":class:`~celery.exceptions.CeleryWarning`"
msgstr ""

#: celery.exceptions:40 of
msgid ":class:`~celery.exceptions.AlwaysEagerIgnored`"
msgstr ""

#: celery.exceptions:41 of
msgid ":class:`~celery.exceptions.DuplicateNodenameWarning`"
msgstr ""

#: celery.exceptions:42 of
msgid ":class:`~celery.exceptions.FixupWarning`"
msgstr ""

#: celery.exceptions:43 of
msgid ":class:`~celery.exceptions.NotConfigured`"
msgstr ""

#: celery.exceptions:48 of
msgid ":exc:`BaseException`"
msgstr ""

#: celery.exceptions:48 of
msgid ":exc:`SystemExit`"
msgstr ""

#: celery.exceptions:46 of
msgid ":exc:`~celery.exceptions.WorkerTerminate`"
msgstr ""

#: celery.exceptions:47 of
msgid ":exc:`~celery.exceptions.WorkerShutdown`"
msgstr ""

#: celery.exceptions.CeleryWarning:1 of
msgid "Base class for all Celery warnings."
msgstr ""

#: celery.exceptions.AlwaysEagerIgnored:1 of
msgid "send_task ignores :setting:`task_always_eager` option."
msgstr ""

#: celery.exceptions.DuplicateNodenameWarning:1 of
msgid "Multiple workers are using the same nodename."
msgstr ""

#: celery.exceptions.FixupWarning:1 of
msgid "Fixup related warning."
msgstr ""

#: celery.exceptions.NotConfigured:1 of
msgid "Celery hasn't been configured, as no config module has been found."
msgstr ""

#: celery.exceptions.CeleryError:1 of
msgid "Base class for all Celery errors."
msgstr ""

#: celery.exceptions.ImproperlyConfigured:1 of
msgid "Celery is somehow improperly configured."
msgstr ""

#: celery.exceptions.SecurityError:1 of
msgid "Security related exception."
msgstr ""

#: celery.exceptions.TaskPredicate:1 of
msgid "Base class for task-related semi-predicates."
msgstr ""

#: celery.exceptions.Ignore:1 of
msgid "A task can raise this to ignore doing state updates."
msgstr ""

#: celery.exceptions.Reject:1 of
msgid "A task can raise this if it wants to reject/re-queue the message."
msgstr ""

#: celery.exceptions.Retry:1 of
msgid "The task is to be retried later."
msgstr ""

#: celery.exceptions.Retry.exc:1 of
msgid "Exception (if any) that caused the retry to happen."
msgstr ""

#: celery.exceptions.Retry.message:1 of
msgid "Optional message describing context of retry."
msgstr ""

#: celery.exceptions.Retry.when:1 of
msgid ""
"Time of retry (ETA), either :class:`numbers.Real` or "
":class:`~datetime.datetime`."
msgstr ""

#: celery.exceptions.TaskError:1 of
msgid "Task related errors."
msgstr ""

#: celery.exceptions.QueueNotFound:1 of
msgid "Task routed to a queue not in ``conf.queues``."
msgstr ""

#: celery.exceptions.IncompleteStream:1 of
msgid "Found the end of a stream of data, but the data isn't complete."
msgstr ""

#: celery.exceptions.AlreadyRegistered:1 of
msgid "The task is already registered."
msgstr ""

#: celery.exceptions.TimeoutError:1 celery.result.AsyncResult.TimeoutError:1 of
msgid "The operation timed out."
msgstr ""

#: celery.exceptions.TaskRevokedError:1 of
msgid "The task has been revoked, so no result available."
msgstr ""

#: celery.exceptions.InvalidTaskError:1 of
msgid "The task has invalid data or ain't properly constructed."
msgstr ""

#: celery.exceptions.ChordError:1 of
msgid "A task part of the chord raised an exception."
msgstr ""

#: celery.exceptions.SoftTimeLimitExceeded:1 of
msgid ""
"The soft time limit has been exceeded. This exception is raised to give "
"the task a chance to clean up."
msgstr ""

#: celery.exceptions.TimeLimitExceeded:1 of
msgid "The time limit has been exceeded and the job has been terminated."
msgstr ""

#: celery.exceptions.WorkerLostError:1 of
msgid "The worker processing a job has exited prematurely."
msgstr ""

#: celery.exceptions.Terminated:1 of
msgid "The worker processing a job has been terminated by user request."
msgstr ""

#: celery.exceptions.CPendingDeprecationWarning:1 of
msgid "Warning of pending deprecation."
msgstr ""

#: celery.exceptions.CDeprecationWarning:1 of
msgid "Warning of deprecation."
msgstr ""

#: celery.exceptions.WorkerShutdown:1 of
msgid "Signals that the worker should perform a warm shutdown."
msgstr ""

#: celery.exceptions.WorkerTerminate:1 of
msgid "Signals that the worker should terminate immediately."
msgstr ""

#: ../../reference/celery.loaders.rst:3
msgid "``celery.loaders``"
msgstr ""

#: celery.loaders:1 of
msgid "Get loader by name."
msgstr ""

#: celery.loaders:3 of
msgid ""
"Loaders define how configuration is read, what happens when workers "
"start, when tasks are executed and so on."
msgstr ""

#: celery.loaders.get_loader_cls:1 of
msgid "Get loader class by name/alias."
msgstr ""

#: ../../reference/celery.loaders.app.rst:3
msgid "``celery.loaders.app``"
msgstr ""

#: celery.loaders.app:1 of
msgid "The default loader used with custom app instances."
msgstr ""

#: celery.loaders.app.AppLoader:1 of
msgid "Default loader used when an app is specified."
msgstr ""

#: ../../reference/celery.loaders.base.rst:3
msgid "``celery.loaders.base``"
msgstr ""

#: celery.loaders.base:1 of
msgid "Loader base class."
msgstr ""

#: celery.loaders.base.BaseLoader:1 of
msgid "Base class for loaders."
msgstr ""

#: celery.loaders.base.BaseLoader:3 of
msgid "Loaders handles,"
msgstr ""

#: celery.loaders.base.BaseLoader:5 of
msgid "Reading celery client/worker configurations."
msgstr ""

#: celery.loaders.base.BaseLoader:8 of
msgid "What happens when a task starts?"
msgstr ""

#: celery.loaders.base.BaseLoader:8 of
msgid "See :meth:`on_task_init`."
msgstr ""

#: celery.loaders.base.BaseLoader:11 of
msgid "What happens when the worker starts?"
msgstr ""

#: celery.loaders.base.BaseLoader:11 of
msgid "See :meth:`on_worker_init`."
msgstr ""

#: celery.loaders.base.BaseLoader:14 of
msgid "What happens when the worker shuts down?"
msgstr ""

#: celery.loaders.base.BaseLoader:14 of
msgid "See :meth:`on_worker_shutdown`."
msgstr ""

#: celery.loaders.base.BaseLoader:16 of
msgid "What modules are imported to find tasks?"
msgstr ""

#: celery.loaders.base.BaseLoader.conf:1 of
msgid "Loader configuration."
msgstr ""

#: celery.loaders.base.BaseLoader.on_process_cleanup:1 of
msgid "Called after a task is executed."
msgstr ""

#: celery.loaders.base.BaseLoader.on_task_init:1 of
msgid "Called before a task is executed."
msgstr ""

#: celery.loaders.base.BaseLoader.on_worker_init:1 of
msgid "Called when the worker (:program:`celery worker`) starts."
msgstr ""

#: celery.loaders.base.BaseLoader.on_worker_process_init:1 of
msgid "Called when a child process starts."
msgstr ""

#: celery.loaders.base.BaseLoader.on_worker_shutdown:1 of
msgid "Called when the worker (:program:`celery worker`) shuts down."
msgstr ""

#: ../../reference/celery.loaders.default.rst:3
msgid "``celery.loaders.default``"
msgstr ""

#: celery.loaders.default:1 of
msgid "The default loader used when no custom app has been initialized."
msgstr ""

#: celery.loaders.default.Loader:1 of
msgid "The loader used by the default app."
msgstr ""

#: celery.loaders.default.Loader.read_configuration:1 of
msgid "Read configuration from :file:`celeryconfig.py`."
msgstr ""

#: ../../reference/celery.result.rst:3
msgid "``celery.result``"
msgstr ""

#: celery.result:1 of
msgid "Task results/state and results for groups of tasks."
msgstr ""

#: celery.result.ResultBase:1 of
msgid "Base class for results."
msgstr ""

#: celery.result.ResultBase.parent:1 of
msgid "Parent result (if part of a chain)"
msgstr ""

#: celery.result.AsyncResult:1 of
msgid "Query task state."
msgstr ""

#: celery.result.AsyncResult:3 of
msgid "See :attr:`id`."
msgstr ""

#: celery.result.AsyncResult:5 of
msgid "See :attr:`backend`."
msgstr ""

#: celery.result.AsyncResult.backend:1 of
msgid "The task result backend to use."
msgstr ""

#: celery.result.AsyncResult.collect:1 of
msgid "Collect results as they return."
msgstr ""

#: celery.result.AsyncResult.collect:3 of
msgid ""
"Iterator, like :meth:`get` will wait for the task to complete, but will "
"also follow :class:`AsyncResult` and :class:`ResultSet` returned by the "
"task, yielding ``(result, value)`` tuples for each result in the tree."
msgstr ""

#: celery.result.AsyncResult.collect:8 of
msgid "An example would be having the following tasks:"
msgstr ""

#: celery.result.AsyncResult.collect:39 of
msgid ""
"The ``Task.trail`` option must be enabled so that the list of children is"
" stored in ``result.children``. This is the default but enabled "
"explicitly for illustration."
msgstr ""

#: celery.result.AsyncResult.collect:43 of
msgid ""
"*Tuple[AsyncResult, Any]* -- tuples containing the result instance of the"
" child task, and the return value of that task."
msgstr ""

#: celery.result.AsyncResult.failed:1 of
msgid "Return :const:`True` if the task failed."
msgstr ""

#: celery.result.AsyncResult.forget:1 celery.result.EagerResult.forget:1 of
msgid "Forget the result of this task and its parents."
msgstr ""

#: celery.result.AsyncResult.get:1 celery.result.AsyncResult.wait:1
#: celery.result.EagerResult.get:1 celery.result.EagerResult.wait:1 of
msgid "Wait until task is ready, and return its result."
msgstr ""

#: celery.result.AsyncResult.get:5 celery.result.AsyncResult.wait:5
#: celery.result.EagerResult.get:5 celery.result.EagerResult.wait:5 of
msgid ""
"Waiting for tasks within a task may lead to deadlocks. Please read :ref"
":`task-synchronous-subtasks`."
msgstr ""

#: celery.result.AsyncResult.get:10 celery.result.AsyncResult.wait:10
#: celery.result.EagerResult.get:10 celery.result.EagerResult.wait:10 of
msgid ""
"Backends use resources to store and transmit results. To ensure that "
"resources are released, you must eventually call "
":meth:`~@AsyncResult.get` or :meth:`~@AsyncResult.forget` on EVERY "
":class:`~@AsyncResult` instance returned after calling a task."
msgstr ""

#: celery.result.AsyncResult.get:16 celery.result.AsyncResult.wait:16
#: celery.result.EagerResult.get:16 celery.result.EagerResult.wait:16 of
msgid "How long to wait, in seconds, before the operation times out."
msgstr ""

#: celery.result.AsyncResult.get:19 celery.result.AsyncResult.wait:19
#: celery.result.EagerResult.get:19 celery.result.EagerResult.wait:19 of
msgid "Re-raise exception if the task failed."
msgstr ""

#: celery.result.AsyncResult.get:21 celery.result.AsyncResult.wait:21
#: celery.result.EagerResult.get:21 celery.result.EagerResult.wait:21 of
msgid ""
"Time to wait (in seconds) before retrying to retrieve the result.  Note "
"that this does not have any effect when using the RPC/redis result store "
"backends, as they don't use polling."
msgstr ""

#: celery.result.AsyncResult.get:26 celery.result.AsyncResult.wait:26
#: celery.result.EagerResult.get:26 celery.result.EagerResult.wait:26 of
msgid ""
"Enable amqp no ack (automatically acknowledge message).  If this is "
":const:`False` then the message will **not be acked**."
msgstr ""

#: celery.result.AsyncResult.get:30 celery.result.AsyncResult.wait:30
#: celery.result.EagerResult.get:30 celery.result.EagerResult.wait:30 of
msgid "Re-raise any exception raised by parent tasks."
msgstr ""

#: celery.result.AsyncResult.get:33 celery.result.AsyncResult.wait:33
#: celery.result.EagerResult.get:33 celery.result.EagerResult.wait:33
#: celery.result.ResultSet.join:42 of
msgid ""
"Disable tasks to wait for sub tasks this is the default configuration. "
"CAUTION do not enable this unless you must."
msgstr ""

#: celery.result.AsyncResult.get:38 celery.result.AsyncResult.wait:38
#: celery.result.EagerResult.get:38 celery.result.EagerResult.wait:38 of
msgid ""
":exc:`celery.exceptions.TimeoutError` -- if `timeout` isn't :const:`None`"
" and the result does not arrive within `timeout` seconds."
msgstr ""

#: celery.result.AsyncResult.get:41 celery.result.AsyncResult.wait:41
#: celery.result.EagerResult.get:41 celery.result.EagerResult.wait:41 of
msgid ""
":exc:`Exception` -- If the remote call raised an exception then that "
"exception will be re-raised in the caller process."
msgstr ""

#: celery.result.AsyncResult.id:1 of
msgid "The task's UUID."
msgstr ""

#: celery.result.AsyncResult.ignored:1 of
msgid "\"If True, task result retrieval is disabled."
msgstr ""

#: celery.result.AsyncResult.info:1 celery.result.AsyncResult.result:1 of
msgid "Task return value."
msgstr ""

#: celery.result.AsyncResult.info:5 celery.result.AsyncResult.result:5 of
msgid ""
"When the task has been executed, this contains the return value. If the "
"task raised an exception, this will be the exception instance."
msgstr ""

#: celery.result.AsyncResult.ready:1 celery.result.EagerResult.ready:1 of
msgid "Return :const:`True` if the task has executed."
msgstr ""

#: celery.result.AsyncResult.ready:3 celery.result.EagerResult.ready:3 of
msgid ""
"If the task is still running, pending, or is waiting for retry then "
":const:`False` is returned."
msgstr ""

#: celery.result.AsyncResult.revoke:1 celery.result.EagerResult.revoke:1 of
msgid "Send revoke signal to all workers."
msgstr ""

#: celery.result.AsyncResult.revoke:3 celery.result.EagerResult.revoke:3 of
msgid ""
"Any worker receiving the task, or having reserved the task, *must* ignore"
" it."
msgstr ""

#: celery.result.AsyncResult.revoke:12 celery.result.EagerResult.revoke:12 of
msgid ""
"Wait for replies from workers. The ``timeout`` argument specifies the "
"seconds to wait. Disabled by default."
msgstr ""

#: celery.result.AsyncResult.revoke:16 celery.result.EagerResult.revoke:16 of
msgid "Time in seconds to wait for replies when ``wait`` is enabled."
msgstr ""

#: celery.result.AsyncResult.state:1 celery.result.AsyncResult.status:1 of
msgid "The tasks current state."
msgstr ""

#: celery.result.AsyncResult.state:3 celery.result.AsyncResult.status:3 of
msgid "Possible values includes:"
msgstr ""

#: celery.result.AsyncResult.state:5 celery.result.AsyncResult.status:5 of
msgid "*PENDING*"
msgstr ""

#: celery.result.AsyncResult.state:7 celery.result.AsyncResult.status:7 of
msgid "The task is waiting for execution."
msgstr ""

#: celery.result.AsyncResult.state:9 celery.result.AsyncResult.status:9 of
msgid "*STARTED*"
msgstr ""

#: celery.result.AsyncResult.state:11 celery.result.AsyncResult.status:11 of
msgid "The task has been started."
msgstr ""

#: celery.result.AsyncResult.state:13 celery.result.AsyncResult.status:13 of
msgid "*RETRY*"
msgstr ""

#: celery.result.AsyncResult.state:15 celery.result.AsyncResult.status:15 of
msgid "The task is to be retried, possibly because of failure."
msgstr ""

#: celery.result.AsyncResult.state:17 celery.result.AsyncResult.status:17 of
msgid "*FAILURE*"
msgstr ""

#: celery.result.AsyncResult.state:19 celery.result.AsyncResult.status:19 of
msgid ""
"The task raised an exception, or has exceeded the retry limit. The "
":attr:`result` attribute then contains the exception raised by the task."
msgstr ""

#: celery.result.AsyncResult.state:23 celery.result.AsyncResult.status:23 of
msgid "*SUCCESS*"
msgstr ""

#: celery.result.AsyncResult.state:25 celery.result.AsyncResult.status:25 of
msgid ""
"The task executed successfully.  The :attr:`result` attribute then "
"contains the tasks return value."
msgstr ""

#: celery.result.AsyncResult.successful:1 of
msgid "Return :const:`True` if the task executed successfully."
msgstr ""

#: celery.result.AsyncResult.task_id:1 of
msgid "Compat. alias to :attr:`id`."
msgstr ""

#: celery.result.AsyncResult.traceback:1 of
msgid "Get the traceback of a failed task."
msgstr ""

#: celery.result.ResultSet:1 of
msgid "A collection of results."
msgstr ""

#: celery.result.GroupResult:10 celery.result.ResultSet:3 of
msgid "List of result instances."
msgstr ""

#: celery.result.ResultSet.add:1 of
msgid "Add :class:`AsyncResult` as a new member of the set."
msgstr ""

#: celery.result.ResultSet.add:3 of
msgid "Does nothing if the result is already a member."
msgstr ""

#: celery.result.ResultSet.clear:1 of
msgid "Remove all results from this set."
msgstr ""

#: celery.result.ResultSet.completed_count:1 of
msgid "Task completion count."
msgstr ""

#: celery.result.ResultSet.completed_count:3 of
msgid "the number of tasks completed."
msgstr ""

#: celery.result.ResultSet.discard:1 of
msgid "Remove result from the set if it is a member."
msgstr ""

#: celery.result.ResultSet.discard:3 of
msgid "Does nothing if it's not a member."
msgstr ""

#: celery.result.ResultSet.failed:1 of
msgid "Return true if any of the tasks failed."
msgstr ""

#: celery.result.ResultSet.failed:3 of
msgid "true if one of the tasks failed.     (i.e., raised an exception)"
msgstr ""

#: celery.result.ResultSet.failed:5 of
msgid "true if one of the tasks failed."
msgstr ""

#: celery.result.ResultSet.failed:6 of
msgid "(i.e., raised an exception)"
msgstr ""

#: celery.result.ResultSet.forget:1 of
msgid "Forget about (and possible remove the result of) all the tasks."
msgstr ""

#: celery.result.ResultSet.get:1 of
msgid "See :meth:`join`."
msgstr ""

#: celery.result.ResultSet.get:3 of
msgid ""
"This is here for API compatibility with :class:`AsyncResult`, in addition"
" it uses :meth:`join_native` if available for the current result backend."
msgstr ""

#: celery.result.ResultSet.iter_native:1 of
msgid "Backend optimized version of :meth:`iterate`."
msgstr ""

#: celery.result.ResultSet.iter_native:5 celery.result.ResultSet.join_native:5
#: of
msgid ""
"Note that this does not support collecting the results for different task"
" types using different backends."
msgstr ""

#: celery.result.ResultSet.iter_native:8 celery.result.ResultSet.join_native:8
#: of
msgid ""
"This is currently only supported by the amqp, Redis and cache result "
"backends."
msgstr ""

#: celery.result.ResultSet.iterate:1 of
msgid "Deprecated method, use :meth:`get` with a callback argument."
msgstr ""

#: celery.result.ResultSet.join:1 of
msgid "Gather the results of all tasks as a list in order."
msgstr ""

#: celery.result.ResultSet.join:5 of
msgid ""
"This can be an expensive operation for result store backends that must "
"resort to polling (e.g., database)."
msgstr ""

#: celery.result.ResultSet.join:8 of
msgid "You should consider using :meth:`join_native` if your backend supports it."
msgstr ""

#: celery.result.ResultSet.join:13 of
msgid ""
"Waiting for tasks within a task may lead to deadlocks. Please see :ref"
":`task-synchronous-subtasks`."
msgstr ""

#: celery.result.ResultSet.join:16 of
msgid "The number of seconds to wait for results before the operation times out."
msgstr ""

#: celery.result.ResultSet.join:19 of
msgid ""
"If any of the tasks raises an exception, the exception will be re-raised "
"when this flag is set."
msgstr ""

#: celery.result.ResultSet.join:22 of
msgid ""
"Time to wait (in seconds) before retrying to retrieve a result from the "
"set.  Note that this does not have any effect when using the amqp result "
"store backend, as it does not use polling."
msgstr ""

#: celery.result.ResultSet.join:27 of
msgid ""
"Optional callback to be called for every result received.  Must have "
"signature ``(task_id, value)`` No results will be returned by this "
"function if a callback is specified.  The order of results is also "
"arbitrary when a callback is used.  To get access to the result object "
"for a particular id you'll have to generate an index first: ``index = "
"{r.id: r for r in gres.results.values()}`` Or you can create new result "
"objects on the fly: ``result = app.AsyncResult(task_id)`` (both will take"
" advantage of the backend cache anyway)."
msgstr ""

#: celery.result.ResultSet.join:38 of
msgid ""
"Automatic message acknowledgment (Note that if this is set to "
":const:`False` then the messages *will not be acknowledged*)."
msgstr ""

#: celery.result.ResultSet.join:47 of
msgid ""
":exc:`celery.exceptions.TimeoutError` -- if ``timeout`` isn't "
":const:`None` and the operation takes longer than ``timeout`` seconds."
msgstr ""

#: celery.result.ResultSet.join_native:1 of
msgid "Backend optimized version of :meth:`join`."
msgstr ""

#: celery.result.ResultSet.ready:1 of
msgid "Did all of the tasks complete? (either by success of failure)."
msgstr ""

#: celery.result.ResultSet.ready:3 of
msgid "true if all of the tasks have been executed."
msgstr ""

#: celery.result.ResultSet.remove:1 of
msgid "Remove result from the set; it must be a member."
msgstr ""

#: celery.result.ResultSet.remove:3 of
msgid ":exc:`KeyError` -- if the result isn't a member."
msgstr ""

#: celery.result.ResultSet.results:1 of
msgid "List of results in in the set."
msgstr ""

#: celery.result.ResultSet.revoke:1 of
msgid "Send revoke signal to all workers for all tasks in the set."
msgstr ""

#: celery.result.ResultSet.revoke:9 of
msgid ""
"Wait for replies from worker. The ``timeout`` argument specifies the "
"number of seconds to wait.  Disabled by default."
msgstr ""

#: celery.result.ResultSet.revoke:13 of
msgid "Time in seconds to wait for replies when the ``wait`` argument is enabled."
msgstr ""

#: celery.result.ResultSet.successful:1 of
msgid "Return true if all tasks successful."
msgstr ""

#: celery.result.ResultSet.successful:3 of
msgid ""
"true if all of the tasks finished     successfully (i.e. didn't raise an "
"exception)."
msgstr ""

#: celery.result.ResultSet.successful:5 of
msgid "true if all of the tasks finished"
msgstr ""

#: celery.result.ResultSet.successful:6 of
msgid "successfully (i.e. didn't raise an exception)."
msgstr ""

#: celery.result.ResultSet.update:1 of
msgid "Extend from iterable of results."
msgstr ""

#: celery.result.ResultSet.waiting:1 of
msgid "Return true if any of the tasks are incomplete."
msgstr ""

#: celery.result.ResultSet.waiting:3 of
msgid "true if one of the tasks are still     waiting for execution."
msgstr ""

#: celery.result.ResultSet.waiting:5 of
msgid "true if one of the tasks are still"
msgstr ""

#: celery.result.ResultSet.waiting:6 of
msgid "waiting for execution."
msgstr ""

#: celery.result.GroupResult:1 of
msgid "Like :class:`ResultSet`, but with an associated id."
msgstr ""

#: celery.result.GroupResult:3 of
msgid "This type is returned by :class:`~celery.group`."
msgstr ""

#: celery.result.GroupResult:5 of
msgid ""
"It enables inspection of the tasks state and return values as a single "
"entity."
msgstr ""

#: celery.result.GroupResult:8 of
msgid "The id of the group."
msgstr ""

#: celery.result.GroupResult:12 of
msgid "Parent result of this group."
msgstr ""

#: celery.result.GroupResult.delete:1 of
msgid "Remove this result if it was previously saved."
msgstr ""

#: celery.result.GroupResult.id:1 of
msgid "The UUID of the group."
msgstr ""

#: celery.result.GroupResult.restore:1 of
msgid "Restore previously saved group result."
msgstr ""

#: celery.result.GroupResult.results:1 of
msgid "List/iterator of results in the group"
msgstr ""

#: celery.result.GroupResult.save:1 of
msgid "Save group-result for later retrieval using :meth:`restore`."
msgstr ""

#: celery.result.EagerResult:1 of
msgid "Result that we know has already been executed."
msgstr ""

#: celery.result.EagerResult.result:1 of
msgid "The tasks return value."
msgstr ""

#: celery.result.EagerResult.state:1 celery.result.EagerResult.status:1 of
msgid "The tasks state."
msgstr ""

#: celery.result.EagerResult.traceback:1 of
msgid "The traceback if the task failed."
msgstr ""

#: celery.result.result_from_tuple:1 of
msgid "Deserialize result from tuple."
msgstr ""

#: ../../reference/celery.schedules.rst:3
msgid "``celery.schedules``"
msgstr ""

#: celery.schedules:1 of
msgid "Schedules define the intervals at which periodic tasks run."
msgstr ""

#: celery.schedules.ParseException:1
#: celery.schedules.crontab_parser.ParseException:1 of
msgid "Raised by :class:`crontab_parser` when the input can't be parsed."
msgstr ""

#: celery.schedules.schedule:1 of
msgid "Schedule for periodic task."
msgstr ""

#: celery.schedules.schedule:3 of
msgid "Time interval."
msgstr ""

#: celery.schedules.schedule:5 of
msgid ""
"If set to True the run time will be rounded to the resolution of the "
"interval."
msgstr ""

#: celery.schedules.crontab:61 celery.schedules.schedule:8 of
msgid ""
"Function returning the current date and time "
"(:class:`~datetime.datetime`)."
msgstr ""

#: celery.schedules.schedule:11 celery.schedules.solar:30 of
msgid "Celery app instance."
msgstr ""

#: celery.schedules.schedule.is_due:1 of
msgid "Return tuple of ``(is_due, next_time_to_check)``."
msgstr ""

#: celery.schedules.schedule.is_due:5 of
msgid "next time to check is in seconds."
msgstr ""

#: celery.schedules.schedule.is_due:8 of
msgid "``(True, 20)``, means the task should be run now, and the next"
msgstr ""

#: celery.schedules.schedule.is_due:8 of
msgid "time to check is in 20 seconds."
msgstr ""

#: celery.schedules.schedule.is_due:10 of
msgid ""
"``(False, 12.3)``, means the task is not due, but that the scheduler "
"should check again in 12.3 seconds."
msgstr ""

#: celery.schedules.schedule.is_due:13 of
msgid ""
"The next time to check is used to save energy/CPU cycles, it does not "
"need to be accurate but will influence the precision of your schedule.  "
"You must also keep in mind the value of "
":setting:`beat_max_loop_interval`, that decides the maximum number of "
"seconds the scheduler can sleep between re-checking the periodic task "
"intervals.  So if you have a task that changes schedule at run-time then "
"your next_run_at check will decide how long it will take before a change "
"to the schedule takes effect.  The max loop interval takes precedence "
"over the next check at value returned."
msgstr ""

#: celery.schedules.schedule.is_due:24 of
msgid "Scheduler max interval variance"
msgstr ""

#: celery.schedules.schedule.is_due:26 of
msgid ""
"The default max loop interval may vary for different schedulers. For the "
"default scheduler the value is 5 minutes, but for example the :pypi"
":`django-celery-beat` database scheduler the value is 5 seconds."
msgstr ""

#: celery.schedules.crontab:1 of
msgid "Crontab schedule."
msgstr ""

#: celery.schedules.crontab:3 of
msgid ""
"A Crontab can be used as the ``run_every`` value of a periodic task entry"
" to add :manpage:`crontab(5)`-like scheduling."
msgstr ""

#: celery.schedules.crontab:6 of
msgid ""
"Like a :manpage:`cron(5)`-job, you can specify units of time of when "
"you'd like the task to execute.  It's a reasonably complete "
"implementation of :command:`cron`'s features, so it should provide a fair"
" degree of scheduling needs."
msgstr ""

#: celery.schedules.crontab:11 of
msgid ""
"You can specify a minute, an hour, a day of the week, a day of the month,"
" and/or a month in the year in any of the following formats:"
msgstr ""

#: celery.schedules.crontab:16 of
msgid ""
"A (list of) integers from 0-59 that represent the minutes of an hour of "
"when execution should occur; or"
msgstr ""

#: celery.schedules.crontab:18 of
msgid ""
"A string representing a Crontab pattern.  This may get pretty advanced, "
"like ``minute='*/15'`` (for every quarter) or "
"``minute='1,13,30-45,50-59/2'``."
msgstr ""

#: celery.schedules.crontab:24 of
msgid ""
"A (list of) integers from 0-23 that represent the hours of a day of when "
"execution should occur; or"
msgstr ""

#: celery.schedules.crontab:26 of
msgid ""
"A string representing a Crontab pattern.  This may get pretty advanced, "
"like ``hour='*/3'`` (for every three hours) or ``hour='0,8-17/2'`` (at "
"midnight, and every two hours during office hours)."
msgstr ""

#: celery.schedules.crontab:33 of
msgid ""
"A (list of) integers from 0-6, where Sunday = 0 and Saturday = 6, that "
"represent the days of a week that execution should occur."
msgstr ""

#: celery.schedules.crontab:36 of
msgid ""
"A string representing a Crontab pattern.  This may get pretty advanced, "
"like ``day_of_week='mon-fri'`` (for weekdays only). (Beware that "
"``day_of_week='*/2'`` does not literally mean 'every two days', but "
"'every day that is divisible by two'!)"
msgstr ""

#: celery.schedules.crontab:43 of
msgid ""
"A (list of) integers from 1-31 that represents the days of the month that"
" execution should occur."
msgstr ""

#: celery.schedules.crontab:45 of
msgid ""
"A string representing a Crontab pattern.  This may get pretty advanced, "
"such as ``day_of_month='2-30/2'`` (for every even numbered day) or "
"``day_of_month='1-7,15-21'`` (for the first and third weeks of the "
"month)."
msgstr ""

#: celery.schedules.crontab:52 of
msgid ""
"A (list of) integers from 1-12 that represents the months of the year "
"during which execution can occur."
msgstr ""

#: celery.schedules.crontab:54 of
msgid ""
"A string representing a Crontab pattern.  This may get pretty advanced, "
"such as ``month_of_year='*/3'`` (for the first month of every quarter) or"
" ``month_of_year='2-12/2'`` (for every even numbered month)."
msgstr ""

#: celery.schedules.crontab:66 of
msgid "The Celery app instance."
msgstr ""

#: celery.schedules.crontab:68 of
msgid ""
"It's important to realize that any day on which execution should occur "
"must be represented by entries in all three of the day and month "
"attributes.  For example, if ``day_of_week`` is 0 and ``day_of_month`` is"
" every seventh day, only months that begin on Sunday and are also in the "
"``month_of_year`` attribute will have execution events.  Or, "
"``day_of_week`` is 1 and ``day_of_month`` is '1-7,15-21' means every "
"first and third Monday of every month present in ``month_of_year``."
msgstr ""

#: celery.schedules.crontab.is_due:1 celery.schedules.solar.is_due:1 of
msgid "Return tuple of ``(is_due, next_time_to_run)``."
msgstr ""

#: celery.schedules.crontab.is_due:3 of
msgid "Next time to run is in seconds."
msgstr ""

#: celery.schedules.crontab.is_due:5 of
msgid "SeeAlso:"
msgstr ""

#: celery.schedules.crontab.is_due:6 celery.schedules.solar.is_due:5 of
msgid ":meth:`celery.schedules.schedule.is_due` for more information."
msgstr ""

#: celery.schedules.crontab.remaining_estimate:1 of
msgid "Estimate of next run time."
msgstr ""

#: celery.schedules.crontab.remaining_estimate:3 of
msgid ""
"Returns when the periodic task should run next as a "
":class:`~datetime.timedelta`."
msgstr ""

#: celery.schedules.crontab_parser:1 of
msgid "Parser for Crontab expressions."
msgstr ""

#: celery.schedules.crontab_parser:3 of
msgid ""
"Any expression of the form 'groups' (see BNF grammar below) is accepted "
"and expanded to a set of numbers. These numbers represent the units of "
"time that the Crontab needs to run on:"
msgstr ""

#: celery.schedules.crontab_parser:19 of
msgid ""
"The parser is a general purpose one, useful for parsing hours, minutes "
"and day of week expressions.  Example usage:"
msgstr ""

#: celery.schedules.crontab_parser:31 of
msgid ""
"It can also parse day of month and month of year expressions if "
"initialized with a minimum of 1.  Example usage:"
msgstr ""

#: celery.schedules.crontab_parser:43 of
msgid "The maximum possible expanded value returned is found by the formula:"
msgstr ""

#: celery.schedules.crontab_parser:45 of
msgid ":math:`max_ + min_ - 1`"
msgstr ""

#: celery.schedules.maybe_schedule:1 of
msgid "Return schedule from number, timedelta, or actual schedule."
msgstr ""

#: celery.schedules.solar:1 of
msgid "Solar event."
msgstr ""

#: celery.schedules.solar:3 of
msgid ""
"A solar event can be used as the ``run_every`` value of a periodic task "
"entry to schedule based on certain solar events."
msgstr ""

#: celery.schedules.solar:8 of
msgid "Available event valus are:"
msgstr ""

#: celery.schedules.solar:10 of
msgid "``dawn_astronomical``"
msgstr ""

#: celery.schedules.solar:11 of
msgid "``dawn_nautical``"
msgstr ""

#: celery.schedules.solar:12 of
msgid "``dawn_civil``"
msgstr ""

#: celery.schedules.solar:13 of
msgid "``sunrise``"
msgstr ""

#: celery.schedules.solar:14 of
msgid "``solar_noon``"
msgstr ""

#: celery.schedules.solar:15 of
msgid "``sunset``"
msgstr ""

#: celery.schedules.solar:16 of
msgid "``dusk_civil``"
msgstr ""

#: celery.schedules.solar:17 of
msgid "``dusk_nautical``"
msgstr ""

#: celery.schedules.solar:18 of
msgid "``dusk_astronomical``"
msgstr ""

#: celery.schedules.solar:20 of
msgid "Solar event that triggers this task. See note for available values."
msgstr ""

#: celery.schedules.solar:23 of
msgid "The latitude of the observer."
msgstr ""

#: celery.schedules.solar:25 of
msgid "The longitude of the observer."
msgstr ""

#: celery.schedules.solar:27 of
msgid ""
"Function returning the current date and time as a "
"class:`~datetime.datetime`."
msgstr ""

#: celery.schedules.solar.is_due:3 of
msgid "next time to run is in seconds."
msgstr ""

#: celery.schedules.solar.remaining_estimate:1 of
msgid "Return estimate of next time to run."
msgstr ""

#: celery.schedules.solar.remaining_estimate:3 of
msgid ""
"when the periodic task should     run next, or if it shouldn't run today "
"(e.g., the sun does     not rise today), returns the time when the next "
"check     should take place."
msgstr ""

#: celery.schedules.solar.remaining_estimate:7 of
msgid "when the periodic task should"
msgstr ""

#: celery.schedules.solar.remaining_estimate:6 of
msgid ""
"run next, or if it shouldn't run today (e.g., the sun does not rise "
"today), returns the time when the next check should take place."
msgstr ""

#: ../../reference/celery.security.rst:3
msgid "``celery.security``"
msgstr ""

#: celery.security:1 of
msgid "Message Signing Serializer."
msgstr ""

#: celery.security.setup_security:1 of
msgid "See :meth:`@Celery.setup_security`."
msgstr ""

#: ../../reference/celery.signals.rst:3
msgid "``celery.signals``"
msgstr ""

#: celery.signals:1 of
msgid "Celery Signals."
msgstr ""

#: celery.signals:3 of
msgid ""
"This module defines the signals (Observer pattern) sent by both workers "
"and clients."
msgstr ""

#: celery.signals:6 of
msgid ""
"Functions can be connected to these signals, and connected functions are "
"called whenever a signal is called."
msgstr ""

#: celery.signals:11 of
msgid ":ref:`signals` for more information."
msgstr ""

#: celery.states:1 of
msgid "Built-in task states."
msgstr ""

#: celery.states:6 of
msgid "States"
msgstr ""

#: celery.states:8 of
msgid "See :ref:`task-states`."
msgstr ""

#: celery.states:13 of
msgid "Sets"
msgstr ""

#: celery.states:18 of
msgid "READY_STATES"
msgstr ""

#: celery.states:20 of
msgid "Set of states meaning the task result is ready (has been executed)."
msgstr ""

#: celery.states:25 of
msgid "UNREADY_STATES"
msgstr ""

#: celery.states:27 of
msgid "Set of states meaning the task result is not ready (hasn't been executed)."
msgstr ""

#: celery.states:32 of
msgid "EXCEPTION_STATES"
msgstr ""

#: celery.states:34 of
msgid "Set of states meaning the task returned an exception."
msgstr ""

#: celery.states:39 of
msgid "PROPAGATE_STATES"
msgstr ""

#: celery.states:41 of
msgid "Set of exception states that should propagate exceptions to the user."
msgstr ""

#: celery.states:46 of
msgid "ALL_STATES"
msgstr ""

#: celery.states:48 of
msgid "Set of all possible states."
msgstr ""

#: celery.states:51 of
msgid "Misc"
msgstr ""

#: celery.states.PENDING:1 of
msgid "Task state is unknown (assumed pending since you know the id)."
msgstr ""

#: celery.states.RECEIVED:1 of
msgid "Task was received by a worker (only used in events)."
msgstr ""

#: celery.states.STARTED:1 of
msgid "Task was started by a worker (:setting:`task_track_started`)."
msgstr ""

#: celery.states.SUCCESS:1 of
msgid "Task succeeded"
msgstr ""

#: celery.states.FAILURE:1 of
msgid "Task failed"
msgstr ""

#: celery.states.REVOKED:1 of
msgid "Task was revoked."
msgstr ""

#: celery.states.RETRY:1 of
msgid "Task is waiting for retry."
msgstr ""

#: celery.states.precedence:1 of
msgid "Get the precedence index for state."
msgstr ""

#: celery.states.precedence:3 of
msgid "Lower index means higher precedence."
msgstr ""

#: celery.states.state:1 of
msgid "Task state."
msgstr ""

#: celery.states.state:3 of
msgid ""
"State is a subclass of :class:`str`, implementing comparison methods "
"adhering to state precedence rules::"
msgstr ""

#: celery.states.state:11 of
msgid ""
"Any custom state is considered to be lower than :state:`FAILURE` and "
":state:`SUCCESS`, but higher than any of the other built-in states::"
msgstr ""

#: ../../reference/celery.utils.debug.rst:3
msgid "``celery.utils.debug``"
msgstr ""

#: ../../reference/celery.utils.debug.rst:9
msgid "Sampling Memory Usage"
msgstr ""

#: ../../reference/celery.utils.debug.rst:11
msgid ""
"This module can be used to diagnose and sample the memory usage used by "
"parts of your application."
msgstr ""

#: ../../reference/celery.utils.debug.rst:14
msgid "For example, to sample the memory usage of calling tasks you can do this:"
msgstr ""

#: celery.utils.debug:1 of
msgid "Utilities for debugging memory usage, blocking calls, etc."
msgstr ""

#: celery.utils.debug.sample_mem:1 of
msgid "Sample RSS memory usage."
msgstr ""

#: celery.utils.debug.sample_mem:3 of
msgid "Statistics can then be output by calling :func:`memdump`."
msgstr ""

#: celery.utils.debug.memdump:1 of
msgid "Dump memory statistics."
msgstr ""

#: celery.utils.debug.memdump:3 of
msgid ""
"Will print a sample of all RSS memory samples added by calling "
":func:`sample_mem`, and in addition print used RSS memory after "
":func:`gc.collect`."
msgstr ""

#: celery.utils.debug.sample:1 of
msgid "Given a list `x` a sample of length ``n`` of that list is returned."
msgstr ""

#: celery.utils.debug.sample:3 of
msgid ""
"For example, if `n` is 10, and `x` has 100 items, a list of every tenth. "
"item is returned."
msgstr ""

#: celery.utils.debug.sample:6 of
msgid "``k`` can be used as offset."
msgstr ""

#: celery.utils.debug.mem_rss:1 of
msgid "Return RSS memory usage as a humanized string."
msgstr ""

#: celery.utils.debug.ps:1 of
msgid "Return the global :class:`psutil.Process` instance."
msgstr ""

#: celery.utils.debug.ps:3 of
msgid "Returns :const:`None` if :pypi:`psutil` is not installed."
msgstr ""

#: ../../reference/celery.worker.rst:3
msgid "``celery.worker``"
msgstr ""

#: celery.worker:1 of
msgid "Worker implementation."
msgstr ""

#: celery.worker.WorkController:1 celery.worker.worker.WorkController:1 of
msgid "Unmanaged worker instance."
msgstr ""

#: celery.worker.WorkController.Blueprint:1
#: celery.worker.worker.WorkController.Blueprint:1 of
msgid "Worker bootstep blueprint."
msgstr ""

#: celery.worker.WorkController.exitcode:1
#: celery.worker.worker.WorkController.exitcode:1 of
msgid "contains the exit code if a :exc:`SystemExit` event is handled."
msgstr ""

#: celery.worker.WorkController.stop:1
#: celery.worker.worker.WorkController.stop:1 of
msgid "Graceful shutdown of the worker server."
msgstr ""

#: celery.worker.WorkController.terminate:1
#: celery.worker.worker.WorkController.terminate:1 of
msgid "Not so graceful shutdown of the worker server."
msgstr ""

#: ../../reference/celery.worker.consumer.rst:3
msgid "``celery.worker.consumer``"
msgstr ""

#: celery.worker.consumer:1 of
msgid "Worker consumer."
msgstr ""

#: celery.worker.consumer.Consumer:1
#: celery.worker.consumer.Consumer.Blueprint:1
#: celery.worker.consumer.consumer.Consumer:1
#: celery.worker.consumer.consumer.Consumer.Blueprint:1 of
msgid "Consumer blueprint."
msgstr ""

#: celery.worker.consumer.Consumer.apply_eta_task:1
#: celery.worker.consumer.consumer.Consumer.apply_eta_task:1 of
msgid "Method called by the timer to apply a task with an ETA/countdown."
msgstr ""

#: celery.worker.consumer.Consumer.connect:1
#: celery.worker.consumer.consumer.Consumer.connect:1 of
msgid "Establish the broker connection used for consuming tasks."
msgstr ""

#: celery.worker.consumer.Consumer.connect:3
#: celery.worker.consumer.consumer.Consumer.connect:3 of
msgid ""
"Retries establishing the connection if the "
":setting:`broker_connection_retry` setting is enabled"
msgstr ""

#: celery.worker.consumer.Consumer.init_callback:1
#: celery.worker.consumer.consumer.Consumer.init_callback:1 of
msgid ""
"Optional callback called the first time the worker is ready to receive "
"tasks."
msgstr ""

#: celery.worker.consumer.Consumer.on_decode_error:1
#: celery.worker.consumer.consumer.Consumer.on_decode_error:1 of
msgid "Callback called if an error occurs while decoding a message."
msgstr ""

#: celery.worker.consumer.Consumer.on_decode_error:3
#: celery.worker.consumer.consumer.Consumer.on_decode_error:3 of
msgid ""
"Simply logs the error and acknowledges the message so it doesn't enter a "
"loop."
msgstr ""

#: celery.worker.consumer.Consumer.on_decode_error:6
#: celery.worker.consumer.consumer.Consumer.on_decode_error:6 of
msgid "The message received."
msgstr ""

#: celery.worker.consumer.Consumer.on_decode_error:8
#: celery.worker.consumer.consumer.Consumer.on_decode_error:8 of
msgid "The exception being handled."
msgstr ""

#: celery.worker.consumer.Consumer.pool:1
#: celery.worker.consumer.consumer.Consumer.pool:1 of
msgid "The current worker pool instance."
msgstr ""

#: celery.worker.consumer.Consumer.timer:1
#: celery.worker.consumer.consumer.Consumer.timer:1 of
msgid "A timer used for high-priority internal tasks, such as sending heartbeats."
msgstr ""

#: celery.worker.consumer.Agent:1 celery.worker.consumer.agent.Agent:1 of
msgid "Agent starts :pypi:`cell` actors."
msgstr ""

#: celery.worker.consumer.Connection:1
#: celery.worker.consumer.connection.Connection:1 of
msgid "Service managing the consumer broker connection."
msgstr ""

#: celery.worker.consumer.Control:1 celery.worker.consumer.control.Control:1 of
msgid "Remote control command service."
msgstr ""

#: celery.worker.consumer.Events:1 celery.worker.consumer.events.Events:1 of
msgid "Service used for sending monitoring events."
msgstr ""

#: celery.worker.consumer.Gossip:1 celery.worker.consumer.gossip.Gossip:1 of
msgid "Bootstep consuming events from other workers."
msgstr ""

#: celery.worker.consumer.Gossip:3 celery.worker.consumer.gossip.Gossip:3 of
msgid "This keeps the logical clock value up to date."
msgstr ""

#: celery.worker.consumer.Heart:1 celery.worker.consumer.heart.Heart:1 of
msgid "Bootstep sending event heartbeats."
msgstr ""

#: celery.worker.consumer.Heart:3 celery.worker.consumer.heart.Heart:3 of
msgid "This service sends a ``worker-heartbeat`` message every n seconds."
msgstr ""

#: celery.worker.consumer.Heart:5 celery.worker.consumer.heart.Heart:5 of
msgid "Not to be confused with AMQP protocol level heartbeats."
msgstr ""

#: celery.worker.consumer.Mingle:1 celery.worker.consumer.mingle.Mingle:1 of
msgid "Bootstep syncing state with neighbor workers."
msgstr ""

#: celery.worker.consumer.Mingle:3 celery.worker.consumer.mingle.Mingle:3 of
msgid "At startup, or upon consumer restart, this will:"
msgstr ""

#: celery.worker.consumer.Mingle:5 celery.worker.consumer.mingle.Mingle:5 of
msgid "Sync logical clocks."
msgstr ""

#: celery.worker.consumer.Mingle:6 celery.worker.consumer.mingle.Mingle:6 of
msgid "Sync revoked tasks."
msgstr ""

#: celery.worker.consumer.Tasks:1 celery.worker.consumer.tasks.Tasks:1 of
msgid "Bootstep starting the task message consumer."
msgstr ""

#: celery.worker.consumer.Tasks.info:1
#: celery.worker.consumer.tasks.Tasks.info:1 of
msgid "Return task consumer info."
msgstr ""

#: celery.worker.consumer.Tasks.shutdown:1
#: celery.worker.consumer.tasks.Tasks.shutdown:1 of
msgid "Shutdown task consumer."
msgstr ""

#: celery.worker.consumer.Tasks.start:1
#: celery.worker.consumer.tasks.Tasks.start:1 of
msgid "Start task consumer."
msgstr ""

#: celery.worker.consumer.Tasks.stop:1
#: celery.worker.consumer.tasks.Tasks.stop:1 of
msgid "Stop task consumer."
msgstr ""

#: ../../reference/celery.worker.consumer.agent.rst:3
msgid "``celery.worker.consumer.agent``"
msgstr ""

#: celery.worker.consumer.agent:1 of
msgid "Celery + :pypi:`cell` integration."
msgstr ""

#: ../../reference/celery.worker.consumer.connection.rst:3
msgid "``celery.worker.consumer.connection``"
msgstr ""

#: celery.worker.consumer.connection:1 of
msgid "Consumer Broker Connection Bootstep."
msgstr ""

#: ../../reference/celery.worker.consumer.consumer.rst:3
msgid "``celery.worker.consumer.consumer``"
msgstr ""

#: celery.worker.consumer.consumer:1 of
msgid "Worker Consumer Blueprint."
msgstr ""

#: celery.worker.consumer.consumer:3 of
msgid ""
"This module contains the components responsible for consuming messages "
"from the broker, processing the messages and keeping the broker "
"connections up and running."
msgstr ""

#: celery.worker.consumer.consumer.Evloop:1 of
msgid "Event loop service."
msgstr ""

#: celery.worker.consumer.consumer.Evloop:3 of
msgid "This is always started last."
msgstr ""

#: celery.worker.consumer.consumer.dump_body:1 of
msgid "Format message body for debugging purposes."
msgstr ""

#: ../../reference/celery.worker.consumer.control.rst:3
msgid "``celery.worker.consumer.control``"
msgstr ""

#: celery.worker.consumer.control:1 of
msgid "Worker Remote Control Bootstep."
msgstr ""

#: celery.worker.consumer.control:3 of
msgid "``Control`` -> :mod:`celery.worker.pidbox` -> :mod:`kombu.pidbox`."
msgstr ""

#: celery.worker.consumer.control:5 of
msgid "The actual commands are implemented in :mod:`celery.worker.control`."
msgstr ""

#: ../../reference/celery.worker.consumer.events.rst:3
msgid "``celery.worker.consumer.events``"
msgstr ""

#: celery.worker.consumer.events:1 of
msgid "Worker Event Dispatcher Bootstep."
msgstr ""

#: celery.worker.consumer.events:3 of
msgid "``Events`` -> :class:`celery.events.EventDispatcher`."
msgstr ""

#: ../../reference/celery.worker.consumer.gossip.rst:3
msgid "``celery.worker.consumer.gossip``"
msgstr ""

#: celery.worker.consumer.gossip:1 of
msgid "Worker <-> Worker communication Bootstep."
msgstr ""

#: ../../reference/celery.worker.consumer.heart.rst:3
msgid "``celery.worker.consumer.heart``"
msgstr ""

#: celery.worker.consumer.heart:1 of
msgid "Worker Event Heartbeat Bootstep."
msgstr ""

#: ../../reference/celery.worker.consumer.mingle.rst:3
msgid "``celery.worker.consumer.mingle``"
msgstr ""

#: celery.worker.consumer.mingle:1 of
msgid "Worker <-> Worker Sync at startup (Bootstep)."
msgstr ""

#: ../../reference/celery.worker.consumer.tasks.rst:3
msgid "``celery.worker.consumer.tasks``"
msgstr ""

#: celery.worker.consumer.tasks:1 of
msgid "Worker Task Consumer Bootstep."
msgstr ""

#: ../../reference/celery.worker.request.rst:3
msgid "``celery.worker.request``"
msgstr ""

#: celery.worker.request:1 of
msgid "Task request."
msgstr ""

#: celery.worker.request:3 of
msgid ""
"This module defines the :class:`Request` class, that specifies how tasks "
"are executed."
msgstr ""

#: celery.worker.request.Request:1 of
msgid "A request for task execution."
msgstr ""

#: celery.worker.request.Request.acknowledge:1 of
msgid "Acknowledge task."
msgstr ""

#: celery.worker.request.Request.execute:1 of
msgid "Execute the task in a :func:`~celery.app.trace.trace_task`."
msgstr ""

#: celery.worker.request.Request.execute:3 of
msgid "The loglevel used by the task."
msgstr ""

#: celery.worker.request.Request.execute:5 of
msgid "The logfile used by the task."
msgstr ""

#: celery.worker.request.Request.execute_using_pool:1 of
msgid "Used by the worker to send this task to the pool."
msgstr ""

#: celery.worker.request.Request.execute_using_pool:3 of
msgid "The execution pool used to execute this request."
msgstr ""

#: celery.worker.request.Request.execute_using_pool:7 of
msgid ":exc:`celery.exceptions.TaskRevokedError` -- if the task was revoked."
msgstr ""

#: celery.worker.request.Request.maybe_expire:1 of
msgid "If expired, mark the task as revoked."
msgstr ""

#: celery.worker.request.Request.on_accepted:1 of
msgid "Handler called when task is accepted by worker pool."
msgstr ""

#: celery.worker.request.Request.on_failure:1 of
msgid "Handler called if the task raised an exception."
msgstr ""

#: celery.worker.request.Request.on_retry:1 of
msgid "Handler called if the task should be retried."
msgstr ""

#: celery.worker.request.Request.on_success:1 of
msgid "Handler called if the task was successfully processed."
msgstr ""

#: celery.worker.request.Request.on_timeout:1 of
msgid "Handler called if the task times out."
msgstr ""

#: celery.worker.request.Request.revoked:1 of
msgid "If revoked, skip task and mark state."
msgstr ""

#: ../../reference/celery.worker.state.rst:3
msgid "``celery.worker.state``"
msgstr ""

#: celery.worker.state:1 of
msgid "Internal worker state (global)."
msgstr ""

#: celery.worker.state:3 of
msgid ""
"This includes the currently active and reserved tasks, statistics, and "
"revoked tasks."
msgstr ""

#: celery.worker.state.SOFTWARE_INFO:1 of
msgid "Worker software/platform information."
msgstr ""

#: celery.worker.state.reserved_requests:1 of
msgid "set of all reserved :class:`~celery.worker.request.Request`'s."
msgstr ""

#: celery.worker.state.active_requests:1 of
msgid "set of currently active :class:`~celery.worker.request.Request`'s."
msgstr ""

#: celery.worker.state.total_count:1 of
msgid "count of tasks accepted by the worker, sorted by type."
msgstr ""

#: celery.worker.state.revoked:1 of
msgid "the list of currently revoked tasks.  Persistent if ``statedb`` set."
msgstr ""

#: celery.worker.state.task_reserved:1 of
msgid "Update global state when a task has been reserved."
msgstr ""

#: celery.worker.state.maybe_shutdown:1 of
msgid "Shutdown if flags have been set."
msgstr ""

#: celery.worker.state.task_accepted:1 of
msgid "Update global state when a task has been accepted."
msgstr ""

#: celery.worker.state.task_ready:1 of
msgid "Update global state when a task is ready."
msgstr ""

#: celery.worker.state.Persistent:1 of
msgid "Stores worker state between restarts."
msgstr ""

#: celery.worker.state.Persistent:3 of
msgid ""
"This is the persistent data stored by the worker when :option:`celery "
"worker --statedb` is enabled."
msgstr ""

#: celery.worker.state.Persistent:6 of
msgid "Currently only stores revoked task id's."
msgstr ""

#: celery.worker.state.Persistent.compress:1 of
msgid "Returns a bytes object containing compressed data."
msgstr ""

#: celery.worker.state.Persistent.compress:3
#: celery.worker.state.Persistent.decompress:3 of
msgid "data"
msgstr ""

#: celery.worker.state.Persistent.compress:4 of
msgid "Binary data to be compressed."
msgstr ""

#: celery.worker.state.Persistent.compress:5 of
msgid "level"
msgstr ""

#: celery.worker.state.Persistent.compress:6 of
msgid "Compression level, in 0-9 or -1."
msgstr ""

#: celery.worker.state.Persistent.decompress:1 of
msgid "Returns a bytes object containing the uncompressed data."
msgstr ""

#: celery.worker.state.Persistent.decompress:4 of
msgid "Compressed data."
msgstr ""

#: celery.worker.state.Persistent.decompress:5 of
msgid "wbits"
msgstr ""

#: celery.worker.state.Persistent.decompress:6 of
msgid "The window buffer size and container format."
msgstr ""

#: celery.worker.state.Persistent.decompress:7 of
msgid "bufsize"
msgstr ""

#: celery.worker.state.Persistent.decompress:8 of
msgid "The initial output buffer size."
msgstr ""

#: ../../reference/celery.worker.strategy.rst:3
msgid "``celery.worker.strategy``"
msgstr ""

#: celery.worker.strategy:1 of
msgid "Task execution strategy (optimization)."
msgstr ""

#: celery.worker.strategy.default:1 of
msgid "Default task execution strategy."
msgstr ""

#: celery.worker.strategy.default:5 of
msgid ""
"Strategies are here as an optimization, so sadly it's not very easy to "
"override."
msgstr ""

#: ../../reference/celery.worker.worker.rst:3
msgid "``celery.worker.worker``"
msgstr ""

#: celery.worker.worker:1 of
msgid "WorkController can be used to instantiate in-process workers."
msgstr ""

#: celery.worker.worker:3 of
msgid ""
"The command-line interface for the worker is in :mod:`celery.bin.worker`,"
" while the worker program is in :mod:`celery.apps.worker`."
msgstr ""

#: celery.worker.worker:6 of
msgid ""
"The worker program is responsible for adding signal handlers, setting up "
"logging, etc.  This is a bare-bones worker without global side-effects "
"(i.e., except for the global state stored in :mod:`celery.worker.state`)."
msgstr ""

#: celery.worker.worker:11 of
msgid ""
"The worker consists of several components, all managed by bootsteps "
"(mod:`celery.bootsteps`)."
msgstr ""

#: ../../reference/index.rst
msgid "Release"
msgstr ""

#: ../../reference/index.rst:7
msgid "|version|"
msgstr ""

#: ../../reference/index.rst
msgid "Date"
msgstr ""

#: ../../reference/index.rst:8
msgid "|today|"
msgstr ""

