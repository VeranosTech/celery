
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>셀러리와의 첫 걸음 &#8212; Celery 4.3.0 documentation</title>
    <link rel="stylesheet" href="../_static/celery.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="다음 단계" href="next-steps.html" />
    <link rel="prev" title="Using Amazon SQS" href="brokers/sqs.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="next-steps.html" title="다음 단계"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="brokers/sqs.html" title="Using Amazon SQS"
             accesskey="P">이전</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Celery 4.3.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">시작하기</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
<div class="deck">

    
        <p>
        This document describes the current stable version of Celery (4.3).
        For development docs,
        <a href="http://docs.celeryproject.org/en/master/getting-started/first-steps-with-celery.html">go here</a>.
        </p>
    

</div>
    <div class="section" id="first-steps-with-celery">
<span id="first-steps"></span><span id="tut-celery"></span><h1>셀러리와의 첫 걸음<a class="headerlink" href="#first-steps-with-celery" title="제목 주소">¶</a></h1>
<p>셀러리는 배터리(batteries)가 포함된 태스크 큐(task queue)이다. 셀러리는 우리가 앞으로 해결해야하는 문제의 모든 복잡성을 완전히 알지 못한 상태에서도 쉽게 시작할 수 있도록 사용하기 쉽다. 셀러리는 제품(production)이 다른 언어와 통합되고 확장될 수 있도록 가장 좋은 실습(practice)을 위주로 설계되었으며, 제품 단계에서 이러한 시스템을 실행하는데 필요한 도구와 지원을 함께 제공한다.</p>
<p>이 튜토리얼에서는 셀러리 사용의 가장 기본을 배울 것이다.</p>
<p>다음에 대해 배워본다;</p>
<ul class="simple">
<li>메세지 전송 수단(브로커)의 선택 및 설치.</li>
<li>셀러리 설치와 첫 번째 태스크 만들기.</li>
<li>워커(worker)를 시작하고 태스크 호출하기.</li>
<li>태스크가 다른 상태(state)로 변할 때 이를 추적하고, 반환 값 검사하기.</li>
</ul>
<p>셀러리가 처음에는 위압적으로 보일 수도 있지만 - 걱정하지 마라 - 이 튜토리얼은 바로 셀러리를 시작해 보도록 할 것이다. 일부러 단순하게 전달하여, 고급 기능들과 혼동하지 않도록 할 것이다. 이 튜토리얼을 마치고 나서, 문서의 나머지 부분을 살펴보는 것이 좋다. 예를 들어 <a class="reference internal" href="next-steps.html#next-steps"><span class="std std-ref">다음 단계</span></a> 튜토리얼은 셀러리의 가능성을 보여줄 것이다.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#choosing-a-broker" id="id3">브로커 선택하기</a><ul>
<li><a class="reference internal" href="#rabbitmq" id="id4">RabbitMQ</a></li>
<li><a class="reference internal" href="#redis" id="id5">Redis</a></li>
<li><a class="reference internal" href="#other-brokers" id="id6">다른 브로커들</a></li>
</ul>
</li>
<li><a class="reference internal" href="#installing-celery" id="id7">셀러리 설치</a></li>
<li><a class="reference internal" href="#application" id="id8">어플리케이션</a></li>
<li><a class="reference internal" href="#running-the-celery-worker-server" id="id9">셀러리 워커(Celery worker) 서버 실행</a></li>
<li><a class="reference internal" href="#calling-the-task" id="id10">태스크(task) 호출</a></li>
<li><a class="reference internal" href="#keeping-results" id="id11">결과 보관</a></li>
<li><a class="reference internal" href="#configuration" id="id12">구성 설정(Configuration)</a></li>
<li><a class="reference internal" href="#where-to-go-from-here" id="id13">지금부터 가야할 곳</a></li>
<li><a class="reference internal" href="#troubleshooting" id="id14">트러블슈팅(Troubleshooting)</a><ul>
<li><a class="reference internal" href="#worker-doesn-t-start-permission-error" id="id15">워커가 시작하지 않는다: 권한 에러(Permission Error)</a></li>
<li><a class="reference internal" href="#result-backend-doesn-t-work-or-tasks-are-always-in-pending-state" id="id16">결과 백엔드가 동작하지 않거나 태스크가 항상 <code class="docutils literal notranslate"><span class="pre">PENDING</span></code> 상태이다</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="choosing-a-broker">
<span id="celerytut-broker"></span><h2><a class="toc-backref" href="#id3">브로커 선택하기</a><a class="headerlink" href="#choosing-a-broker" title="제목 주소">¶</a></h2>
<p>셀러리는 메세지를 전달하고 받을 수 있는 방법이 필요하다; 이것은 일반적으로 <em>메세지 브로커(message broker)</em>라고 불리는 별도의 서비스 형태로 나와있다.</p>
<p>사용할 수 있는 몇가지 옵션은 다음과 같다:</p>
<div class="section" id="rabbitmq">
<h3><a class="toc-backref" href="#id4">RabbitMQ</a><a class="headerlink" href="#rabbitmq" title="제목 주소">¶</a></h3>
<p><a class="reference external" href="http://www.rabbitmq.com/">RabbitMQ</a>는 기능이 완전하고, 안정적이며, 내구성이 있고 설치하기 쉽다. 제품 환경을 위해 아주 좋은 선택지이다. 셀러리와 함께 RabbitMQ 사용하는 것에 대한 자세한 정보는:</p>
<blockquote>
<div><a class="reference internal" href="brokers/rabbitmq.html#broker-rabbitmq"><span class="std std-ref">RabbitMQ 사용</span></a></div></blockquote>
<p>우분투(Ubuntu)또는 데비안(Debian)을 사용할 경우 다음의 명령을 실행하여 RabbitMQ를 설치한다:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> sudo apt-get install rabbitmq-server
</pre></div>
</div>
<p>또는, 도커(Docker)에서 실행하기 원하면 다음과 같다:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> docker run -d -p <span class="m">5462</span>:5462 rabbitmq
</pre></div>
</div>
<p>명령이 완료되면, 브로커는 이미 백그라운드에서 동작하고 있을 것이며, 메세지를 옮길 준비가 되어 있다: <code class="docutils literal notranslate"><span class="pre">Starting</span> <span class="pre">rabbitmq-server:</span> <span class="pre">SUCCESS</span></code>.</p>
<p>만약 우분투 또는 데비안에서 실행하지 않더라도 걱정하지마라, 여기 웹사이트로 이동하여 마이크로소프트 윈도우즈를 포함한 다른 플랫폼에서 설치할 수 있는 비슷하면서 간단한 명령어를 찾아라:</p>
<blockquote>
<div><a class="reference external" href="http://www.rabbitmq.com/download.html">http://www.rabbitmq.com/download.html</a></div></blockquote>
</div>
<div class="section" id="redis">
<h3><a class="toc-backref" href="#id5">Redis</a><a class="headerlink" href="#redis" title="제목 주소">¶</a></h3>
<p><a class="reference external" href="https://redis.io/">Redis</a> 또한 기능이 완전하지만, 갑작스러운 전력 장애(power failures)나 갑작스러운 종료 상황이 발생할 경우 데이터 손실에 더 취약하다. Redis에 대한 자세한 정보는:</p>
<p><a class="reference internal" href="brokers/redis.html#broker-redis"><span class="std std-ref">Using Redis</span></a></p>
<p>도커에서 실행하려면 다음 명령을 실행하라:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> docker run -d -p <span class="m">6379</span>:6379 redis
</pre></div>
</div>
</div>
<div class="section" id="other-brokers">
<h3><a class="toc-backref" href="#id6">다른 브로커들</a><a class="headerlink" href="#other-brokers" title="제목 주소">¶</a></h3>
<p>위의 브로커들 이외에도, 선택할 수 있는 다른 실험적인 전송 구현 방법들이 있으며, <a class="reference internal" href="brokers/sqs.html#broker-sqs"><span class="std std-ref">Amazon SQS</span></a>를 포함한다.</p>
<p>전체 목록은 <a class="reference internal" href="brokers/index.html#broker-overview"><span class="std std-ref">Broker Overview</span></a>를 보라.</p>
</div>
</div>
<div class="section" id="installing-celery">
<span id="celerytut-installation"></span><h2><a class="toc-backref" href="#id7">셀러리 설치</a><a class="headerlink" href="#installing-celery" title="제목 주소">¶</a></h2>
<p>셀러리는 파이썬 패키지 인덱스(PyPI)에 있으며, 따라서 표준 파이썬 도구인 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">easy_install</span></code>을 사용하여 설치할 수 있다:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> pip install celery
</pre></div>
</div>
</div>
<div class="section" id="application">
<h2><a class="toc-backref" href="#id8">어플리케이션</a><a class="headerlink" href="#application" title="제목 주소">¶</a></h2>
<p>첫 번째로 필요한 것은 셀러리 인스턴스이다. 이것을 <em>셀러리 어플리케이션</em> 또는 그냥 짧게 줄여 <em>앱(app)</em>이라고 부른다. 이 인스턴스는 태스크를 생성하거나 워커를 관리하는 것처럼 셀러리에서 하려는 모든 작업의 진입점(entry-point)로 사용되며, 반드시 다른 모듈에서 이 인스턴스를 가져오기(import)할 수 있어야 한다.</p>
<p>이 튜토리얼에서는 단일 모듈에 포함된 모든 것을 다루지만, 더 큰 프로젝트를 위해서는 <a class="reference internal" href="next-steps.html#project-layout"><span class="std std-ref">dedicated module</span></a>을 생성하고자 한다.</p>
<p>이제 <code class="file docutils literal notranslate"><span class="pre">tasks.py</span></code> 파일을 생성해보자:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">celery</span> <span class="kn">import</span> <span class="n">Celery</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Celery</span><span class="p">(</span><span class="s1">&#39;tasks&#39;</span><span class="p">,</span> <span class="n">broker</span><span class="o">=</span><span class="s1">&#39;pyamqp://guest@localhost//&#39;</span><span class="p">)</span>

<span class="nd">@app.task</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">Celery</span></code>의 첫번째 인수(argument)는 현재 모듈의 이름이다. 이것만 있으면, 태스크가 <cite>__main__</cite> 모듈 내에 정의되었을 때 이름이 자동적으로 생성되도록 한다.</p>
<p>두 번째 인수는 브로커 키워드 인수인데, 사용하고자 하는 메세지 브로커의 URL을 지정한다. 여기서는 RabbitMQ(그리고 기본 옵션)를 사용한다.</p>
<p>자세한 내용은 위의 <a class="reference internal" href="#celerytut-broker"><span class="std std-ref">브로커 선택하기</span></a>를 참조하라 — RabbitMQ의 경우 <code class="docutils literal notranslate"><span class="pre">amqp://localhost</span></code>를 사용하거나, Redis를 위해서는 <code class="docutils literal notranslate"><span class="pre">redis://localhost</span></code>를 사용할 수 있다.</p>
<p>두 숫자의 합을 반환하는, <code class="docutils literal notranslate"><span class="pre">add</span></code>라는 이름의 단일 태스크를 정의하였다.</p>
</div>
<div class="section" id="running-the-celery-worker-server">
<span id="celerytut-running-the-worker"></span><h2><a class="toc-backref" href="#id9">셀러리 워커(Celery worker) 서버 실행</a><a class="headerlink" href="#running-the-celery-worker-server" title="제목 주소">¶</a></h2>
<p>이제 <code class="docutils literal notranslate"><span class="pre">worker</span></code> 인수를 사용하여 프로그램을 실행함으로써 워커를 동작시킬 수 있다:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> celery -A tasks worker --loglevel<span class="o">=</span>info
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">만약 워커가 시작하지 않는다면, <a class="reference internal" href="#celerytut-troubleshooting"><span class="std std-ref">트러블슈팅(Troubleshooting)</span></a> 섹션을 보라.</p>
</div>
<p>제품(production)에서 데몬(daemon)으로 백그라운드에서 워커를 실행시키기를 원할 것이다. 이를 위해서는 플랫폼에서 제공하는 도구나, <a class="reference external" href="http://supervisord.org">supervisord</a> 등을 사용해야 한다(보다 자세한 내용을 위해서 <a class="reference internal" href="../userguide/daemonizing.html#daemonizing"><span class="std std-ref">Daemonization</span></a>를 보라).</p>
<p>사용 가능한 커맨드 라인(command-line) 옵션의 전체 목록을 보려면, 다음과 같이 하라:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span>  celery worker --help
</pre></div>
</div>
<p>또한 몇 가지의 사용 가능한 다른 명령어들이 있으며, 도움말(help) 또한 사용 가능하다:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> celery <span class="nb">help</span>
</pre></div>
</div>
</div>
<div class="section" id="calling-the-task">
<span id="celerytut-calling"></span><h2><a class="toc-backref" href="#id10">태스크(task) 호출</a><a class="headerlink" href="#calling-the-task" title="제목 주소">¶</a></h2>
<p>태스크를 호출하기 위해서 <a class="reference internal" href="../reference/celery.app.task.html#celery.app.task.Task.delay" title="celery.app.task.Task.delay"><code class="xref py py-meth docutils literal notranslate"><span class="pre">delay()</span></code></a> 방법을 사용할 수 있다.</p>
<p>이것은 <a class="reference internal" href="../reference/celery.app.task.html#celery.app.task.Task.apply_async" title="celery.app.task.Task.apply_async"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apply_async()</span></code></a>을 손쉽게 사용하는 방법으로 태스크 실행에 대한 효과적인 제어를 할 수 있게 한다 (<a class="reference internal" href="../userguide/calling.html#guide-calling"><span class="std std-ref">Calling Tasks</span></a>를 보라):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">tasks</span> <span class="k">import</span> <span class="n">add</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="o">.</span><span class="n">delay</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>태스크는 아까 시작시켰던 워커에 의해 처리되었다. 워커의 콘솔 결과(console output)을 보고 확인할 수 있다.</p>
<p>태스크 호출은 class:<cite>~&#64;AsyncResult</cite> 인스턴스를 반환한다. 이것은 태스크의 상태를 체크하고, 태스크가 끝날 때까지 기다리고, 반환 값을 받는 데 사용할 수 있다(또는 태스크가 실패(failed)되었을 때, 예외와 traceback을 받는 데 사용할 수 있다).</p>
<p>결과(Result)는 기본적으로 실행되지 않는다. 원격 프로시져(remote procedure) 호출을 하거나 데이터베이스에서 태스크 결과를 추적하기 위하여, 셀러리가 결과 백엔드(result backend)를 사용하도록 설정하는 것이 필요하다.  이것은 다음 섹션에서 설명한다.</p>
</div>
<div class="section" id="keeping-results">
<span id="celerytut-keeping-results"></span><h2><a class="toc-backref" href="#id11">결과 보관</a><a class="headerlink" href="#keeping-results" title="제목 주소">¶</a></h2>
<p>만약 계속해서 태스크의 상태를 추적하고 싶다면, 셀러리는 상태를 어딘가로 보내거나 저장해야 한다. 내장되어 있는 결과 백엔드가 몇가지 있는데: <a class="reference external" href="http://www.sqlalchemy.org/">SQLAlchemy</a>/<a class="reference external" href="http://djangoproject.com">Django</a> ORM, <a class="reference external" href="http://memcached.org">Memcached</a>, <a class="reference external" href="https://redis.io/">Redis</a>, <a class="reference internal" href="../userguide/configuration.html#conf-rpc-result-backend"><span class="std std-ref">RPC</span></a> (<a class="reference external" href="http://www.rabbitmq.com/">RabbitMQ</a>/AMQP)에서 선택할 수 있고, 또는 자체적으로 정의해서 사용할 수 있다.</p>
<p>예시에서는 상태를 일시적 메세지(transient message)로 전송하는 <cite>rpc</cite> 결과 백엔드를 사용한다. 백엔드는 <code class="docutils literal notranslate"><span class="pre">backend</span></code> 인수를 통해서(또는 설정 모듈을 선택했을 경우 <a class="reference internal" href="../userguide/configuration.html#std:setting-result_backend"><code class="xref std std-setting docutils literal notranslate"><span class="pre">result_backend</span></code></a> 설정을 통해서) <a class="reference internal" href="../reference/celery.html#celery.Celery" title="celery.Celery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Celery</span></code></a>로 지정된다:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">app</span> <span class="o">=</span> <span class="n">Celery</span><span class="p">(</span><span class="s1">&#39;tasks&#39;</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="s1">&#39;rpc://&#39;</span><span class="p">,</span> <span class="n">broker</span><span class="o">=</span><span class="s1">&#39;pyamqp://&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>혹은 결과 백엔드로 Redis를 사용하지만, 메세지 브로커로는 계속해서 RabbitMQ를 사용한다면(일반적인 조합이다):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">app</span> <span class="o">=</span> <span class="n">Celery</span><span class="p">(</span><span class="s1">&#39;tasks&#39;</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="s1">&#39;redis://localhost&#39;</span><span class="p">,</span> <span class="n">broker</span><span class="o">=</span><span class="s1">&#39;pyamqp://&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>결과 백엔드에 대한 더 자세한 내용은 <a class="reference internal" href="../userguide/tasks.html#task-result-backends"><span class="std std-ref">Result Backends</span></a>를 읽어보아라.</p>
<p>결과 백엔드 설정과 함께, 이제 다시 태스크를 호출해보자. 이번에는 태스크를 호출할 때 <a class="reference internal" href="../reference/celery.result.html#celery.result.AsyncResult" title="celery.result.AsyncResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResult</span></code></a> 인스턴스가 반환될 것이다:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="n">delay</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="../reference/celery.result.html#celery.result.AsyncResult.ready" title="celery.result.AsyncResult.ready"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ready()</span></code></a> 방법은 태스크가 작업(processing)을 마쳤는지 여부를 반환한다:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">ready</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>결과가 완료되기까지 기다릴 수 있지만, 비동기적 호출을 동기적으로 변환하기 때문에 거의 사용되지 않는다:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">8</span>
</pre></div>
</div>
<p>태스크가 예외(exception)을 발생시킨 경우에는, <a class="reference internal" href="../reference/celery.result.html#celery.result.AsyncResult.get" title="celery.result.AsyncResult.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a>가 다시 예외를 발생시게 되는데, <code class="docutils literal notranslate"><span class="pre">propagate</span></code> 인수를 명시하여 이를 무시할 수 있다:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">propagate</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>태스크가 예외를 발생시키면, 원본 traceback에 대한 접근 권한도 얻을 수 있다:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">traceback</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">경고</p>
<p class="last">백엔드가 결과를 저장하고 전달하는데 리소스가 사용된다. 사용된 리소스가 확실히 릴리즈되도록 하기 위해, 결국에는 태스크 호출 후 <a class="reference internal" href="../reference/celery.result.html#celery.result.AsyncResult" title="celery.result.AsyncResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResult</span></code></a> 인스턴스가 반환될 때 마다 <a class="reference internal" href="../reference/celery.result.html#celery.result.AsyncResult.get" title="celery.result.AsyncResult.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a> 또는 <a class="reference internal" href="../reference/celery.result.html#celery.result.AsyncResult.forget" title="celery.result.AsyncResult.forget"><code class="xref py py-meth docutils literal notranslate"><span class="pre">forget()</span></code></a>를 호출해야만 한다.</p>
</div>
<p>전체 결과 객체 참조를 위하여 <a class="reference internal" href="../reference/celery.result.html#module-celery.result" title="celery.result"><code class="xref py py-mod docutils literal notranslate"><span class="pre">celery.result</span></code></a>를 보라.</p>
</div>
<div class="section" id="configuration">
<span id="celerytut-configuration"></span><h2><a class="toc-backref" href="#id12">구성 설정(Configuration)</a><a class="headerlink" href="#configuration" title="제목 주소">¶</a></h2>
<p>가전 제품과 마찬가지로, 셀러리는 실행하는데 많은 구성 설정들이 필요하지 않다. 단지 입력(input)과 출력(output)을 가진다. 입력은 브로커와 반드시 연결되어 있어야 하고, 출력은 선택적으로 결과 백엔드와 연결할 수 있다. 하지만, 가전 제품도 뒤쪽을 자세하게 보면, 슬라이더, 다이얼, 그리고 버튼들을 가리고 있는 뚜껑이 있는데: 이것이 셀러리에서는 구성 설정(configuration)이다.</p>
<p>기본 구성 설정은 대부분의 유즈케이스에 충분하지만, 셀러리가 정확히 필요한 대로 작동하도록 만들기 위해서 많은 설정 옵션들이 있다. 사용 가능한 옵션에 대하여 읽어보는 것은 셀러리를 구성하는데 친숙해지기 위한 좋은 방법이다. <a class="reference internal" href="../userguide/configuration.html#configuration"><span class="std std-ref">Configuration and defaults</span></a> 참조에서 옵션들에 대해 읽어볼 수 있다.</p>
<p>구성은 앱(app)에서 직접적으로 설정할 수 있고, 설정 모듈을 사용하여 할 수도 있다. 예를 들어 <a class="reference internal" href="../userguide/configuration.html#std:setting-task_serializer"><code class="xref std std-setting docutils literal notranslate"><span class="pre">task_serializer</span></code></a> 설정을 변경하여 태스크 페이로드(payloads)를 일련화하기 위해 기본 serializer를 구성할 수 있다:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">app</span><span class="o">.</span><span class="n">conf</span><span class="o">.</span><span class="n">task_serializer</span> <span class="o">=</span> <span class="s1">&#39;json&#39;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">update</span></code>를 사용하여 한 번에 많은 설정을 구성할 수도 있다:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">app</span><span class="o">.</span><span class="n">conf</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
    <span class="n">task_serializer</span><span class="o">=</span><span class="s1">&#39;json&#39;</span><span class="p">,</span>
    <span class="n">accept_content</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;json&#39;</span><span class="p">],</span>  <span class="c1"># Ignore other content</span>
    <span class="n">result_serializer</span><span class="o">=</span><span class="s1">&#39;json&#39;</span><span class="p">,</span>
    <span class="n">timezone</span><span class="o">=</span><span class="s1">&#39;Europe/Oslo&#39;</span><span class="p">,</span>
    <span class="n">enable_utc</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>보다 큰 프로젝트를 위해서, 전용 구성 모듈을 추천한다. 하드 코딩(hard coding)된 주기적인 태스크 간격과 태스크 라우팅 옵션은 허용되지 않는다. 중앙화된 위치에서 이것들을 보관하는 것이 훨씬 좋다. 특히 라이브러리의 경우에 더욱 좋은데, 사용자들이 태스크가 어떻게 동작하는지 제어할 수 있도록 하기 때문이다. 중앙화된 구성 설정(centrailized configuration)은 시스템 문제가 발생했을 때 SysAdmin을 간단히 변경하는 것을 허용한다.</p>
<p><a class="reference internal" href="../reference/celery.html#celery.Celery.config_from_object" title="celery.Celery.config_from_object"><code class="xref py py-meth docutils literal notranslate"><span class="pre">app.config_from_object()</span></code></a> 방법을 호출하여 셀러리 인스턴스가 구성 모듈을 사용하도록 만들 수 있다:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">app</span><span class="o">.</span><span class="n">config_from_object</span><span class="p">(</span><span class="s1">&#39;celeryconfig&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>이 모듈은 보통 “<code class="docutils literal notranslate"><span class="pre">celeryconfig</span></code>”라고 불리는데, 아무 이름을 사용해도 상관없다.</p>
<p>위의 경우에서, <code class="docutils literal notranslate"><span class="pre">celeryconfig.py</span></code> 이름의 모듈은 현재 디렉토리 또는 파이썬 경로로부터 로드할 수 있어야 한다. 이런식으로 보일 수도 있다:</p>
<p><code class="file docutils literal notranslate"><span class="pre">celeryconfig.py</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">broker_url</span> <span class="o">=</span> <span class="s1">&#39;pyamqp://&#39;</span>
<span class="n">result_backend</span> <span class="o">=</span> <span class="s1">&#39;rpc://&#39;</span>

<span class="n">task_serializer</span> <span class="o">=</span> <span class="s1">&#39;json&#39;</span>
<span class="n">result_serializer</span> <span class="o">=</span> <span class="s1">&#39;json&#39;</span>
<span class="n">accept_content</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;json&#39;</span><span class="p">]</span>
<span class="n">timezone</span> <span class="o">=</span> <span class="s1">&#39;Europe/Oslo&#39;</span>
<span class="n">enable_utc</span> <span class="o">=</span> <span class="bp">True</span>
</pre></div>
</div>
<p>구성 파일이 제대로 작동하고 문구 오류(syntax errors)가 포함되어 있는지 확인하기 위하여, 이것을 가져오도록(import) 시도할 수 있다:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> python -m celeryconfig
</pre></div>
</div>
<p>구성 설정 옵션에 대한 전체적인 내용은 <a class="reference internal" href="../userguide/configuration.html#configuration"><span class="std std-ref">Configuration and defaults</span></a>을 보라.</p>
<p>구성 파일의 성능을 보여주기 위해(demonstrate), 잘못된 태스크를 전용 대기열(dedicated queue)에 라우팅한다:</p>
<p><code class="file docutils literal notranslate"><span class="pre">celeryconfig.py</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">task_routes</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;tasks.add&#39;</span><span class="p">:</span> <span class="s1">&#39;low-priority&#39;</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<p>또는 라우팅하는 대신에 태스크 인스턴스의 한도(limit)을 조정하여, 이 타입의 10개의 태스크만1분에 실행될 수 있도록 한다 (10/m):</p>
<p><code class="file docutils literal notranslate"><span class="pre">celeryconfig.py</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">task_annotations</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;tasks.add&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;rate_limit&#39;</span><span class="p">:</span> <span class="s1">&#39;10/m&#39;</span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>브로커로 RabbitMQ 또는 Redis를 사용할 경우 워커에게 런타임의 태스크에 대한 새로운 제한(rate limit)을 설정하도록 지시할 수 있다:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> celery -A tasks control rate_limit tasks.add <span class="m">10</span>/m
<span class="go">worker@example.com: OK</span>
<span class="go">    new rate limit set successfully</span>
</pre></div>
</div>
<p><a class="reference internal" href="../userguide/routing.html#guide-routing"><span class="std std-ref">Routing Tasks</span></a>에서 태스크 라우팅에 대해 읽어보고, 주석(annocation)에 대한 자세한 내용은 <a class="reference internal" href="../userguide/configuration.html#std:setting-task_annotations"><code class="xref std std-setting docutils literal notranslate"><span class="pre">task_annotations</span></code></a> 설정을 참조하거나, 원격 제어 명령 및 작업자의 활동을 모니터하는 방법에 대한 내용은 <a class="reference internal" href="../userguide/monitoring.html#guide-monitoring"><span class="std std-ref">Monitoring and Management Guide</span></a>을 참조하라.</p>
</div>
<div class="section" id="where-to-go-from-here">
<h2><a class="toc-backref" href="#id13">지금부터 가야할 곳</a><a class="headerlink" href="#where-to-go-from-here" title="제목 주소">¶</a></h2>
<p>계속해서 더 많은 내용을 배우고 싶다면 <a class="reference internal" href="next-steps.html#next-steps"><span class="std std-ref">Next Steps</span></a> 튜토리얼을 보고, 그 이후에는 <a class="reference internal" href="../userguide/index.html#guide"><span class="std std-ref">User Guide</span></a>을 읽어보라.</p>
</div>
<div class="section" id="troubleshooting">
<span id="celerytut-troubleshooting"></span><h2><a class="toc-backref" href="#id14">트러블슈팅(Troubleshooting)</a><a class="headerlink" href="#troubleshooting" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="../faq.html#faq"><span class="std std-ref">Frequently Asked Questions</span></a>에 트러블슈팅 섹션도 함께 있다.</p>
<div class="section" id="worker-doesn-t-start-permission-error">
<h3><a class="toc-backref" href="#id15">워커가 시작하지 않는다: 권한 에러(Permission Error)</a><a class="headerlink" href="#worker-doesn-t-start-permission-error" title="제목 주소">¶</a></h3>
<ul>
<li><p class="first">데비안(Debianm), 우분투(Ubuntu)또는 데비안 기반의 다른 배포판을 사용할 경우:</p>
<blockquote>
<div><p>데비안은 최근 <code class="file docutils literal notranslate"><span class="pre">/dev/shm</span></code>의 특수 파일 이름을 <code class="file docutils literal notranslate"><span class="pre">/run/shm</span></code>로 변경하였다.</p>
<p>간단한 해결 방법은 심볼릭 링크(symbolic link)를 생성하는 것이다:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> ln -s /run/shm /dev/shm
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">기타:</p>
<blockquote>
<div><p><code class="xref std std-option docutils literal notranslate"><span class="pre">—pidfile</span></code>, <code class="xref std std-option docutils literal notranslate"><span class="pre">—logfile</span></code> 또는 <code class="xref std std-option docutils literal notranslate"><span class="pre">—statedb</span></code> 인수를 사용할 경우에는, 워커를 시작하는 사용자(user)가 읽고 쓸 수 있는 파일 또는 디렉토리를 확실하게 가리키는지 확인하여야 한다.</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="result-backend-doesn-t-work-or-tasks-are-always-in-pending-state">
<h3><a class="toc-backref" href="#id16">결과 백엔드가 동작하지 않거나 태스크가 항상 <code class="docutils literal notranslate"><span class="pre">PENDING</span></code> 상태이다</a><a class="headerlink" href="#result-backend-doesn-t-work-or-tasks-are-always-in-pending-state" title="제목 주소">¶</a></h3>
<p>모든 태스크는 기본적으로 <a class="reference internal" href="../userguide/tasks.html#std:state-PENDING"><code class="xref std std-state docutils literal notranslate"><span class="pre">PENDING</span></code></a> 상태로, “unknown”으로 명명되는 것이 더 낫다. 셀러리는 태스크가 전송되었을 때 상태를 업데이트하고, 히스토리가 없는 태스크는 모두 보류(pending) 상태인 것으로 가정한다(어쨌든 태스크 id는 알고있을 것이다).</p>
<ol class="arabic">
<li><p class="first">태스크가 활성화된 <code class="docutils literal notranslate"><span class="pre">ignore_result</span></code> 가지지 않도록 해야 한다.</p>
<blockquote>
<div><p>이 옵션을 활서오하하면 워커는 상태 업데이트를 강제로 생략할 것이다.</p>
</div></blockquote>
</li>
<li><p class="first"><a class="reference internal" href="../userguide/configuration.html#std:setting-task_ignore_result"><code class="xref std std-setting docutils literal notranslate"><span class="pre">task_ignore_result</span></code></a> 설정이 활성화되지 않았는지 확인하라.</p>
</li>
<li><p class="first">아직 작업하고 있는 오래된 워커가 있는지 확인하라.</p>
<blockquote>
<div><p>실수로, 여러 워커들이 시작하게 하는 것은 쉽기 때문에, 새로운 워커가 시작하기 전에 이전 워커들이 제대로 종료되도록 해야 한다.</p>
<p>예상 결과 백엔드로 설정되지 않은 예전 워커가 혹시 실행중이면서 태스크를 가로채고 있을 수 있다.</p>
<p><code class="xref std std-option docutils literal notranslate"><span class="pre">—pidfile</span></code> 인수는 이러한 일이 발생하지 않도록 절대 경로로 설정될 수 있다.</p>
</div></blockquote>
</li>
<li><p class="first">클라이언트가 맞는 백엔드로 설정되어 있는지 확인하라.</p>
<blockquote>
<div><p>어떠한 이유로, 클라이언트가 워커와 다른 백엔드로 설정되어 있으면, 결과를 전달받지 못할 것이다. 백엔드가 올바르게 설정되었는지 확인하라:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">delay</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">backend</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ol>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/celery_512.png" alt="Logo"/>
            </a></p><iframe src="https://ghbtns.com/github-btn.html?user=celery&repo=celery&type=watch&count=true&size=large"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>
<div id="donate">
    <b>Please help support this community project with a donation:</b>
    <form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
    <input type="hidden" name="cmd" value="_s-xclick">
    <input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----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-----END PKCS7-----
    ">
    <input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
    <img alt="" border="0" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
    </form>
</div>
  <h4>이전 항목</h4>
  <p class="topless"><a href="brokers/sqs.html"
                        title="이전 장">Using Amazon SQS</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="next-steps.html"
                        title="다음 장">다음 단계</a></p>
  <div role="note" aria-label="source link">
    <h3>현재 문서</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/getting-started/first-steps-with-celery.rst.txt"
            rel="nofollow">소스 코드를 보려면</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>빠른 검색</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="바로 가기" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="next-steps.html" title="다음 단계"
             >다음</a> |</li>
        <li class="right" >
          <a href="brokers/sqs.html" title="Using Amazon SQS"
             >이전</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Celery 4.3.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >시작하기</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; <a href="../copyright.html">Copyright</a> 2009-2018, Ask Solem &amp; contributors.
    </div>
  </body>
</html>